From 46fd1b598ab78b7c50f6a7e6b983ea78c8038650 Mon Sep 17 00:00:00 2001
From: gamer <gamely-code@gmail.com>
Date: Fri, 28 Feb 2025 15:29:38 +0800
Subject: [PATCH] =?UTF-8?q?=E4=B8=8A=E4=BC=A0rk915=E7=9A=84=E7=9B=B8?=
 =?UTF-8?q?=E5=85=B3=E6=96=87=E4=BB=B6?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: gamer <gamely-code@gmail.com>
---
 .../boot/dts/rockchip/rk3326-evb-lp3-v10.dtsi |   40 +-
 drivers/mmc/core/core.c                       |   24 +-
 drivers/mmc/core/host.c                       |   67 +-
 drivers/mmc/core/sdio.c                       |    3 +-
 drivers/mmc/core/sdio_cis.c                   |    7 +-
 drivers/mmc/host/dw_mmc.c                     |   33 +-
 drivers/net/wireless/rockchip_wlan/Kconfig    |    1 +
 drivers/net/wireless/rockchip_wlan/Makefile   |    1 +
 .../net/wireless/rockchip_wlan/rk915/Kconfig  |   14 +
 .../net/wireless/rockchip_wlan/rk915/Makefile |   87 +
 .../wireless/rockchip_wlan/rk915/inc/core.h   | 1116 ++++++
 .../wireless/rockchip_wlan/rk915/inc/debug.h  |  470 +++
 .../rockchip_wlan/rk915/inc/firmware.h        |   51 +
 .../rockchip_wlan/rk915/inc/fw_data.h         |  777 ++++
 .../rockchip_wlan/rk915/inc/hal_common.h      |  462 +++
 .../wireless/rockchip_wlan/rk915/inc/hal_io.h |   24 +
 .../wireless/rockchip_wlan/rk915/inc/if_io.h  |   79 +
 .../wireless/rockchip_wlan/rk915/inc/p2p.h    |   26 +
 .../rockchip_wlan/rk915/inc/platform.h        |   18 +
 .../wireless/rockchip_wlan/rk915/inc/rpu.h    |  196 +
 .../wireless/rockchip_wlan/rk915/inc/rpu_if.h |  276 ++
 .../wireless/rockchip_wlan/rk915/inc/sdio.h   |  131 +
 .../wireless/rockchip_wlan/rk915/inc/soc.h    |   44 +
 .../wireless/rockchip_wlan/rk915/inc/utils.h  |   70 +
 .../rockchip_wlan/rk915/inc/version.h         |   20 +
 .../wireless/rockchip_wlan/rk915/inc/wow.h    |   20 +
 .../rockchip_wlan/rk915/rk915_rftest.sh       |  297 ++
 .../rockchip_wlan/rk915/shared/descriptors.h  |   53 +
 .../wireless/rockchip_wlan/rk915/shared/hal.h |  153 +
 .../rockchip_wlan/rk915/shared/host_rpu_if.h  | 1811 ++++++++++
 .../rockchip_wlan/rk915/src/add_license.sh    |   23 +
 .../wireless/rockchip_wlan/rk915/src/beacon.c |  151 +
 .../rockchip_wlan/rk915/src/firmware.c        |  913 +++++
 .../wireless/rockchip_wlan/rk915/src/hal.c    | 1971 ++++++++++
 .../wireless/rockchip_wlan/rk915/src/hal_io.c |  324 ++
 .../wireless/rockchip_wlan/rk915/src/init.c   |  288 ++
 .../wireless/rockchip_wlan/rk915/src/main.c   |  397 +++
 .../wireless/rockchip_wlan/rk915/src/p2p.c    |  284 ++
 .../wireless/rockchip_wlan/rk915/src/pktgen.c |  643 ++++
 .../rockchip_wlan/rk915/src/platform.c        |   95 +
 .../wireless/rockchip_wlan/rk915/src/procfs.c | 2148 +++++++++++
 .../wireless/rockchip_wlan/rk915/src/rpu_if.c | 3154 +++++++++++++++++
 .../net/wireless/rockchip_wlan/rk915/src/rx.c |  875 +++++
 .../wireless/rockchip_wlan/rk915/src/sdio.c   | 1090 ++++++
 .../wireless/rockchip_wlan/rk915/src/soc.c    |   47 +
 .../net/wireless/rockchip_wlan/rk915/src/tx.c | 1401 ++++++++
 .../rockchip_wlan/rk915/src/umac_if.c         | 2390 +++++++++++++
 .../wireless/rockchip_wlan/rk915/src/utils.c  |  468 +++
 .../wireless/rockchip_wlan/rk915/src/vif.c    |  504 +++
 .../wireless/rockchip_wlan/rk915/src/wow.c    |  265 ++
 include/linux/genhd.h                         |    1 +
 include/linux/mmc/host.h                      |    6 +
 net/mac80211/main.c                           |   12 +
 net/rfkill/rfkill-wlan.c                      |    4 +-
 54 files changed, 23791 insertions(+), 34 deletions(-)
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/Kconfig
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/Makefile
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/core.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/debug.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/firmware.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/fw_data.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/hal_common.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/hal_io.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/if_io.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/p2p.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/platform.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/rpu.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/rpu_if.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/sdio.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/soc.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/utils.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/version.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/inc/wow.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/rk915_rftest.sh
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/shared/descriptors.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/shared/hal.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/shared/host_rpu_if.h
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/add_license.sh
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/beacon.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/firmware.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/hal.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/hal_io.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/init.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/main.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/p2p.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/pktgen.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/platform.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/procfs.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/rpu_if.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/rx.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/sdio.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/soc.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/tx.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/umac_if.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/utils.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/vif.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rk915/src/wow.c

diff --git a/arch/arm64/boot/dts/rockchip/rk3326-evb-lp3-v10.dtsi b/arch/arm64/boot/dts/rockchip/rk3326-evb-lp3-v10.dtsi
index d214a0695..e7d48d417 100755
--- a/arch/arm64/boot/dts/rockchip/rk3326-evb-lp3-v10.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3326-evb-lp3-v10.dtsi
@@ -194,8 +194,8 @@
 		compatible = "mmc-pwrseq-simple";
 		//clocks = <&cru SCLK_WIFI_PMU>;
 		//clock-names = "clk_wifi_pmu";
-		//pinctrl-names = "default";
-		//pinctrl-0 = <&wifi_enable_h>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
 
 		/*
 		 * On the module itself this is one of these (depending
@@ -203,7 +203,7 @@
 		 * - SDIO_RESET_L_WL_REG_ON
 		 * - PDN (power down when low)
 		 */
-		//reset-gpios = <&gpio0 RK_PA2 GPIO_ACTIVE_LOW>; /* GPIO3_A4 */
+		reset-gpios = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>; /* GPIO3_A4 */
 	};
 
 	test-power {
@@ -236,18 +236,16 @@
 		gpio_chip_wake = <&gpio0 1 GPIO_ACTIVE_HIGH>;/*GPIO0_A3 AP2CP*/
 		gpio_chip_en = <&gpio0 2 GPIO_ACTIVE_HIGH>;/*GPIO0_B1 CP POWERON*/
 	};
-/*
+
 	wireless-wlan {
 		compatible = "wlan-platdata";
-		clocks = <&rk809 1>; 
-		clock-names = "ext_clock";
-		wifi_chip_type = "rtl8723cs";
+		wifi_chip_type = "rk915";
 		WIFI,host_wake_irq = <&gpio0 RK_PA5 GPIO_ACTIVE_HIGH>;
-		//WIFI,poweren_gpio = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
-		status = "disabled";
+		WIFI,poweren_gpio = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
+		status = "okay";
 	};
-*/
-	wireless-bluetooth {
+
+/*	wireless-bluetooth {
 		compatible = "bluetooth-platdata";
 		//clocks = <&rk809 1>;
 		clock-names = "ext_clock";
@@ -260,7 +258,7 @@
 		BT,wake_host_irq = <&gpio0 RK_PA7 GPIO_ACTIVE_HIGH>;
 		status = "disabled";
 	};
-
+*/
 	vcc18_lcd_n: vcc18-lcd-n {
 		compatible = "regulator-fixed";
 		regulator-name = "vcc18_lcd_n";
@@ -957,20 +955,16 @@
 };
 
 &sdio {
-	max-frequency = <100000000>; 
+	max-frequency = <50000000>; 
 	bus-width = <4>;
 	cap-sd-highspeed;
-	//cap-mmc-highspeed;
-	supports-sd;
+	no-sd;
+	no-mmc;
+	supports-sdio;
 	ignore-pm-notify;
-	card-detect-delay = <800>;
-	cd-gpios = <&gpio0 2 GPIO_ACTIVE_LOW>;// [> CD GPIO <]   GPIO_ACTIVE_HIGH
-	sd-uhs-sdr12;
-    sd-uhs-sdr25;
-    sd-uhs-sdr50;
-	sd-uhs-sdr104;
-	vqmmc-supply = <&vcc2v8_dvp>;
-	vmmc-supply = <&vcc1v8_dvp>;
+	keep-power-in-suspend;
+	supports-rk912;
+	/delete-property/ non-removable;
 	status = "okay";
 };
 
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index da283ed3d..444b8f88d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -231,10 +231,10 @@ static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	 */
 	if (sdio_is_io_busy(mrq->cmd->opcode, mrq->cmd->arg) &&
 	    host->ops->card_busy) {
-		int tries = 500; /* Wait aprox 500ms at maximum */
+		int tries = 500*1000; /* Wait aprox 500ms at maximum */
 
 		while (host->ops->card_busy(host) && --tries)
-			mmc_delay(1);
+			udelay(1);
 
 		if (tries == 0) {
 			mrq->cmd->error = -EBUSY;
@@ -2164,6 +2164,7 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 	 * should be ignored by SD/eMMC cards.
 	 * Skip it if we already know that we do not support SDIO commands
 	 */
+#if 1//def MMC_STANDARD_PROBE
 	if (!(host->caps2 & MMC_CAP2_NO_SDIO))
 		sdio_reset(host);
 
@@ -2184,7 +2185,26 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 	if (!(host->caps2 & MMC_CAP2_NO_MMC))
 		if (!mmc_attach_mmc(host))
 			return 0;
+#else
+	if (host->restrict_caps & RESTRICT_CARD_TYPE_SDIO)
+		sdio_reset(host);
+
+	mmc_go_idle(host);
 
+	if (host->restrict_caps &
+	    (RESTRICT_CARD_TYPE_SDIO | RESTRICT_CARD_TYPE_SD))
+		mmc_send_if_cond(host, host->ocr_avail);
+	/* Order's important: probe SDIO, then SD, then MMC */
+	if ((host->restrict_caps & RESTRICT_CARD_TYPE_SDIO) &&
+	    !mmc_attach_sdio(host))
+		return 0;
+	if ((host->restrict_caps & RESTRICT_CARD_TYPE_SD) &&
+	    !mmc_attach_sd(host))
+		return 0;
+	if ((host->restrict_caps & RESTRICT_CARD_TYPE_EMMC) &&
+	    !mmc_attach_mmc(host))
+		return 0;
+#endif
 	mmc_power_off(host);
 	return -EIO;
 }
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 10116f781..6374643e9 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -225,7 +225,7 @@ int mmc_of_parse(struct mmc_host *host)
 	struct device *dev = host->parent;
 	u32 bus_width, drv_type, cd_debounce_delay_ms;
 	int ret;
-
+printk("bruce test ----000 .\n");
 	if (!dev || !dev_fwnode(dev))
 		return 0;
 
@@ -235,7 +235,7 @@ int mmc_of_parse(struct mmc_host *host)
 			"\"bus-width\" property is missing, assuming 1 bit.\n");
 		bus_width = 1;
 	}
-
+printk("bruce test ---- 3333.\n");
 	switch (bus_width) {
 	case 8:
 		host->caps |= MMC_CAP_8_BIT_DATA;
@@ -250,7 +250,7 @@ int mmc_of_parse(struct mmc_host *host)
 			"Invalid \"bus-width\" value %u!\n", bus_width);
 		return -EINVAL;
 	}
-
+printk("bruce test ---- 4444.\n");
 	/* f_max is obtained from the optional "max-frequency" property */
 	device_property_read_u32(dev, "max-frequency", &host->f_max);
 
@@ -288,7 +288,7 @@ int mmc_of_parse(struct mmc_host *host)
 		else if (ret != -ENOENT && ret != -ENOSYS)
 			return ret;
 	}
-
+printk("bruce test ----5555 .\n");
 	/* Parse Write Protection */
 
 	if (device_property_read_bool(dev, "wp-inverted"))
@@ -354,6 +354,8 @@ int mmc_of_parse(struct mmc_host *host)
 		host->caps2 |= MMC_CAP2_NO_SD;
 	if (device_property_read_bool(dev, "no-mmc"))
 		host->caps2 |= MMC_CAP2_NO_MMC;
+	if (device_property_read_bool(dev, "supports-rk912"))
+		host->caps2 |= MMC_CAP2_WIFI_RK912;
 	if (device_property_read_bool(dev, "no-prescan-powerup"))
 		host->caps2 |= MMC_CAP2_NO_PRESCAN_POWERUP;
 
@@ -365,6 +367,15 @@ int mmc_of_parse(struct mmc_host *host)
 			dev_err(host->parent,
 				"can't use fixed driver type, media is removable\n");
 	}
+	printk("bruce test ---- 666.\n");
+	if (device_property_read_bool(dev, "supports-sd"))
+		host->restrict_caps |= RESTRICT_CARD_TYPE_SD;
+	if (device_property_read_bool(dev, "supports-sdio")){
+		host->restrict_caps |= RESTRICT_CARD_TYPE_SDIO;
+		printk("bruce test ---- 11.\n");
+		}
+	if (device_property_read_bool(dev, "supports-emmc"))
+		host->restrict_caps |= RESTRICT_CARD_TYPE_EMMC;
 
 	host->dsr_req = !device_property_read_u32(dev, "dsr", &host->dsr);
 	if (host->dsr_req && (host->dsr & ~0xffff)) {
@@ -447,6 +458,7 @@ static int mmc_first_nonreserved_index(void)
  *
  *	Initialise the per-host structure.
  */
+static struct mmc_host *primary_sdio_host;
 struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 {
 	int index;
@@ -551,6 +563,10 @@ int mmc_add_host(struct mmc_host *host)
 #ifdef CONFIG_DEBUG_FS
 	mmc_add_host_debugfs(host);
 #endif
+	printk("bruce test ---- 222.\n");
+	if (host->restrict_caps & RESTRICT_CARD_TYPE_SDIO){
+		primary_sdio_host = host;
+	}
 
 	mmc_start_host(host);
 	return 0;
@@ -594,3 +610,46 @@ void mmc_free_host(struct mmc_host *host)
 }
 
 EXPORT_SYMBOL(mmc_free_host);
+
+
+/**
+ * mmc_host_rescan - triger software rescan flow
+ * @host: mmc host
+ *
+ * rescan slot attach in the assigned host.
+ * If @host is NULL, default rescan primary_sdio_host
+ * saved by mmc_add_host().
+ * OR, rescan host from argument.
+ *
+ */
+int mmc_host_rescan(struct mmc_host *host, int val, int is_cap_sdio_irq)
+{
+	if (NULL != primary_sdio_host) {
+		if (!host)
+			host = primary_sdio_host;
+		else
+			pr_info("%s: mmc_host_rescan pass in host from argument!\n",
+				mmc_hostname(host));
+	} else {
+		pr_err("bruce --- sdio: host isn't  initialization successfully.\n");
+		return -ENOMEDIUM;
+	}
+
+	pr_info("%s:mmc host rescan start!\n", mmc_hostname(host));
+
+	/*  0: oob  1:cap-sdio-irq */
+	if (is_cap_sdio_irq == 1) {
+		host->caps |= MMC_CAP_SDIO_IRQ;
+	} else if (is_cap_sdio_irq == 0) {
+		host->caps &= ~MMC_CAP_SDIO_IRQ;
+	} else {
+		dev_err(&host->class_dev, "sdio: host doesn't identify oob or sdio_irq mode!\n");
+		return -ENOMEDIUM;
+	}
+
+	if (!(host->caps & MMC_CAP_NONREMOVABLE) && host->ops->set_sdio_status)
+		host->ops->set_sdio_status(host, val);
+
+	return 0;
+}
+EXPORT_SYMBOL(mmc_host_rescan);
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 73dc5c37d..a35218afc 100755
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1060,7 +1060,8 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	 * removable card is checked from a detect work later on in the resume
 	 * process.
 	 */
-	if (!mmc_card_keep_power(host)) {
+	if (!mmc_card_keep_power(host) &&
+		!(host->caps2 & MMC_CAP2_WIFI_RK912)) {
 		mmc_power_up(host, host->card->ocr);
 		/*
 		 * Tell runtime PM core we just powered up the card,
diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index b23773583..03715a0a5 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -172,6 +172,7 @@ static int cistpl_funce_common(struct mmc_card *card, struct sdio_func *func,
 static int cistpl_funce_func(struct mmc_card *card, struct sdio_func *func,
 			     const unsigned char *buf, unsigned size)
 {
+	struct mmc_host *host = card->host;
 	unsigned vsn;
 	unsigned min_size;
 
@@ -190,15 +191,17 @@ static int cistpl_funce_func(struct mmc_card *card, struct sdio_func *func,
 		pr_warn("%s: card has broken SDIO 1.1 CIS, forcing SDIO 1.0\n",
 			mmc_hostname(card->host));
 		vsn = SDIO_SDIO_REV_1_00;
-	} else if (size < min_size) {
+	} else if (size < min_size && !(host->caps2 & MMC_CAP2_WIFI_RK912)) {
 		return -EINVAL;
 	}
 
 	/* TPLFE_MAX_BLK_SIZE */
 	func->max_blksize = buf[12] | (buf[13] << 8);
+	if (host->caps2 & MMC_CAP2_WIFI_RK912)
+		func->max_blksize = 512;
 
 	/* TPLFE_ENABLE_TIMEOUT_VAL, present in ver 1.1 and above */
-	if (vsn > SDIO_SDIO_REV_1_00)
+	if (vsn > SDIO_SDIO_REV_1_00 && !(host->caps2 & MMC_CAP2_WIFI_RK912))
 		func->enable_timeout = (buf[28] | (buf[29] << 8)) * 10;
 	else
 		func->enable_timeout = jiffies_to_msecs(HZ);
diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c
index a88d9b908..de528639a 100644
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@ -318,6 +318,10 @@ static u32 dw_mci_prepare_command(struct mmc_host *mmc, struct mmc_command *cmd)
 			     SDMMC_CMD_PRV_DAT_WAIT, 0);
 	}
 
+	if (mmc->caps2 & MMC_CAP2_WIFI_RK912 &&
+		cmd->opcode == SD_IO_RW_DIRECT)
+		cmdr |= SDMMC_CMD_PRV_DAT_WAIT;
+
 	if (cmd->flags & MMC_RSP_PRESENT) {
 		/* We expect a response, so set this bit */
 		cmdr |= SDMMC_CMD_RESP_EXP;
@@ -985,6 +989,28 @@ static void dw_mci_post_req(struct mmc_host *mmc,
 	data->host_cookie = COOKIE_UNMAPPED;
 }
 
+static int dw_mci_set_sdio_status(struct mmc_host *mmc, int val)
+{
+	struct dw_mci_slot *slot = mmc_priv(mmc);
+	struct dw_mci *host = slot->host;
+
+	if (!(mmc->restrict_caps & RESTRICT_CARD_TYPE_SDIO))
+		return 0;
+
+	spin_lock_bh(&host->lock);
+
+	if (val)
+		set_bit(DW_MMC_CARD_PRESENT, &slot->flags);
+	else
+		clear_bit(DW_MMC_CARD_PRESENT, &slot->flags);
+
+	spin_unlock_bh(&host->lock);
+
+	mmc_detect_change(slot->mmc, 20);
+
+	return 0;
+}
+
 static int dw_mci_get_cd(struct mmc_host *mmc)
 {
 	int present;
@@ -1303,7 +1329,8 @@ static void dw_mci_setup_bus(struct dw_mci_slot *slot, bool force_clkinit)
 
 		/* enable clock; only low power if no SDIO */
 		clk_en_a = SDMMC_CLKEN_ENABLE << slot->id;
-		if (!test_bit(DW_MMC_CARD_NO_LOW_PWR, &slot->flags))
+		if (!test_bit(DW_MMC_CARD_NO_LOW_PWR, &slot->flags) &&
+			!(slot->mmc->caps2 & MMC_CAP2_WIFI_RK912))
 			clk_en_a |= SDMMC_CLKEN_LOW_PWR << slot->id;
 		mci_writel(host, CLKENA, clk_en_a);
 
@@ -1853,6 +1880,7 @@ static const struct mmc_host_ops dw_mci_ops = {
 	.pre_req		= dw_mci_pre_req,
 	.post_req		= dw_mci_post_req,
 	.set_ios		= dw_mci_set_ios,
+	.set_sdio_status	= dw_mci_set_sdio_status,
 	.get_ro			= dw_mci_get_ro,
 	.get_cd			= dw_mci_get_cd,
 	.hw_reset               = dw_mci_hw_reset,
@@ -2970,6 +2998,9 @@ static int dw_mci_init_slot(struct dw_mci *host)
 	}
 
 	dw_mci_get_cd(mmc);
+	
+	if (mmc->caps2 & MMC_CAP2_WIFI_RK912)
+		clear_bit(DW_MMC_CARD_PRESENT, &slot->flags);
 
 	ret = mmc_add_host(mmc);
 	if (ret)
diff --git a/drivers/net/wireless/rockchip_wlan/Kconfig b/drivers/net/wireless/rockchip_wlan/Kconfig
index 6bd54d60f..1206e2d92 100755
--- a/drivers/net/wireless/rockchip_wlan/Kconfig
+++ b/drivers/net/wireless/rockchip_wlan/Kconfig
@@ -37,6 +37,7 @@ source "drivers/net/wireless/rockchip_wlan/rkwifi/Kconfig"
 endif
 
 source "drivers/net/wireless/rockchip_wlan/cywdhd/Kconfig"
+source "drivers/net/wireless/rockchip_wlan/rk915/Kconfig"
 source "drivers/net/wireless/rockchip_wlan/infineon/Kconfig"
 source "drivers/net/wireless/rockchip_wlan/rtl8188eu/Kconfig"
 source "drivers/net/wireless/rockchip_wlan/rtl8188fu/Kconfig"
diff --git a/drivers/net/wireless/rockchip_wlan/Makefile b/drivers/net/wireless/rockchip_wlan/Makefile
index 17e3329d9..a4a5a85ee 100755
--- a/drivers/net/wireless/rockchip_wlan/Makefile
+++ b/drivers/net/wireless/rockchip_wlan/Makefile
@@ -13,5 +13,6 @@ obj-$(CONFIG_RTL8821CS)	+= rtl8821cs/
 obj-$(CONFIG_SSV6051)	+= ssv6xxx/
 obj-$(CONFIG_MVL88W8977)	+= mvl88w8977/
 obj-$(CONFIG_CYW_BCMDHD)	+= cywdhd/
+obj-$(CONFIG_RK915)    += rk915/
 obj-$(CONFIG_INFINEON_DHD)	+= infineon/
 obj-$(CONFIG_WLAN_VENDOR_SEEKWAVE)	+= seekwave/
\ No newline at end of file
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/Kconfig b/drivers/net/wireless/rockchip_wlan/rk915/Kconfig
new file mode 100755
index 000000000..f86318c46
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/Kconfig
@@ -0,0 +1,14 @@
+#
+# Rockchip RK915 Wireless drivers
+#
+
+config RK915
+	tristate "Rockchip RK915 Wireless drivers"
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	select CFG80211
+	select MAC80211
+	select NL80211_TESTMODE
+
+	help
+		Rockchip RK915 Wireless drivers
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/Makefile b/drivers/net/wireless/rockchip_wlan/rk915/Makefile
new file mode 100755
index 000000000..d217f0f06
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/Makefile
@@ -0,0 +1,87 @@
+BUSIF=SDIO
+MY_PWD=$(PWD)
+ROM=true
+CHIP=RK915
+
+ifeq ($(CONFIG_RK915),)
+CONFIG_RK915=m
+endif
+
+L_BUSIF=$(shell echo $(BUSIF) | tr A-Z a-z)
+
+NAME     = rk915
+
+EXTRA_CFLAGS += -Idrivers/net/wireless/rockchip_wlan/rk915/inc \
+                -Idrivers/net/wireless/rockchip_wlan/rk915/shared
+
+EXTRA_CFLAGS += -DDEBUG
+
+OBJS        =   src/main.o \
+		src/hal.o \
+		src/umac_if.o \
+		src/rpu_if.o \
+		src/tx.o \
+		src/rx.o \
+		src/beacon.o \
+		src/p2p.o \
+		src/pktgen.o \
+		src/procfs.o \
+		src/utils.o \
+		src/vif.o \
+		src/wow.o \
+		src/soc.o \
+		src/hal_io.o \
+		src/platform.o \
+		src/firmware.o \
+		src/init.o
+
+## To enable sleep functionality
+## we need to enable ROM
+ifeq ($(ROM),true)
+EXTRA_CFLAGS += -DRPU_SLEEP_ENABLE
+#EXTRA_CFLAGS += -DPS_SLEEP_TEST
+#EXTRA_CFLAGS += -DRPU_NO_SLEEP_FLAG
+#EXTRA_CFLAGS += -DRPU_ENABLE_PS
+else
+EXTRA_CFLAGS += -DNO_HP_READY_WAR
+endif
+# BUSIF
+ifeq ($(BUSIF),SDIO)
+EXTRA_CFLAGS += -DHAL_SDIO
+OBJS	   +=	src/sdio.o
+endif
+
+#EXTRA_CFLAGS += -DSKIP_DL_FW
+ifeq ($(CHIP),RK915)
+EXTRA_CFLAGS += -DRK915
+endif
+
+#EXTRA_CFLAGS += -DRK3036_DONGLE
+#EXTRA_CFLAGS += -DSTA_AP_COEXIST
+EXTRA_CFLAGS += -DSDIO_CLOCK_SWITCH
+
+GCC_VER_49 := $(shell echo `$(CC) -dumpversion | cut -f1-2 -d.` \>= 4.9 | bc )
+ifeq ($(GCC_VER_49),1)
+EXTRA_CFLAGS += -Wno-date-time  # Fix compile error && warning on gcc 4.9 and later
+#EXTRA_CFLAGS += -Wno-error=date-time
+endif
+
+obj-$(CONFIG_RK915) += $(NAME).o
+$(NAME)-objs= $(OBJS)
+
+ifneq ($(KERNELRELEASE),)
+
+#EXTRA_LDFLAGS += --strip-debug
+
+else
+
+all:
+	@echo "BUSIF is $(L_BUSIF)"
+	@echo "Compiling for $(BUSIF)"
+	@make -C $(KROOT) M=$(MY_PWD) modules
+clean:
+	@make -C $(KROOT) M=$(MY_PWD) clean
+	rm -f src/*.o
+
+endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/core.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/core.h
new file mode 100755
index 000000000..b657ecf28
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/core.h
@@ -0,0 +1,1116 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _CORE_H_
+#define _CORE_H_
+
+#include <linux/atomic.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/etherdevice.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/version.h>
+#include <linux/wireless.h>
+#include <linux/firmware.h>
+#include <linux/wakelock.h>
+
+#include <net/mac80211.h>
+
+#include "descriptors.h"
+#include "rpu_if.h"
+#include "hal_common.h"
+#include "version.h"
+#include "debug.h"
+#include "firmware.h"
+
+extern int uccp_reinit;
+extern struct cmd_send_recv_cnt cmd_info;
+
+#ifdef CONFIG_PM
+extern unsigned char img_suspend_status;
+extern unsigned char rx_interrupt_status;
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+enum ieee80211_band {
+        IEEE80211_BAND_2GHZ = NL80211_BAND_2GHZ,
+        IEEE80211_BAND_5GHZ = NL80211_BAND_5GHZ,
+        IEEE80211_BAND_60GHZ = NL80211_BAND_60GHZ,
+
+        /* keep last */
+        IEEE80211_NUM_BANDS
+};
+#endif
+
+/* Wrapper to check return values for all
+ * umac_if layer calls.
+ */
+#define CALL_RPU(prog_rpu, ...) \
+do {                            \
+	ret = prog_rpu(__VA_ARGS__);   \
+	if (ret != 0)                    \
+		goto prog_rpu_fail;      \
+} while (0)
+
+#ifdef CONFIG_NL80211_TESTMODE
+#define MAX_NL_DUMP_LEN (PAGE_SIZE-1024)
+/* This section contains example code for using netlink
+ * attributes with the testmode command in nl80211.
+ */
+
+/* These enums need to be kept in sync with userspace */
+enum rpu_testmode_attr {
+	__RPU_TM_ATTR_INVALID = 0,
+	RPU_TM_ATTR_CMD      = 1,
+	RPU_TM_ATTR_DUMP      = 2,
+	/* keep last */
+	__RPU_TM_ATTR_AFTER_LAST,
+	RPU_TM_ATTR_MAX       = __RPU_TM_ATTR_AFTER_LAST - 1
+};
+
+enum rpu_testmode_cmd {
+	RPU_TM_CMD_ALL	= 0,
+	RPU_TM_CMD_GRAM  = 1,
+	RPU_TM_CMD_COREA  = 2,
+	RPU_TM_CMD_COREB  = 3,
+	RPU_TM_CMD_PERIP = 4,
+	RPU_TM_CMD_SYSBUS = 5,
+};
+
+#endif
+extern unsigned int system_rev;
+extern unsigned int ftm;
+extern unsigned int down_fw_in_probe;
+
+extern unsigned char vif_macs[2][ETH_ALEN];
+
+extern spinlock_t tsf_lock;
+
+#define RESET_RX_CONTROL_INFO 1
+#define MAX_OUTSTANDING_CTRL_REQ 2
+#define RESET_TIMEOUT 1000   /* In milli-seconds*/
+#define RESET_TIMEOUT_TICKS msecs_to_jiffies(RESET_TIMEOUT)
+/*100: For ROC, 500: For initial*/
+#define CH_PROG_TIMEOUT 3000   /* In milli-seconds*/
+#define CH_PROG_TIMEOUT_TICKS msecs_to_jiffies(CH_PROG_TIMEOUT)
+
+#define QUEUE_FLUSH_TIMEOUT  2000   /* Specify delay in milli-seconds*/
+#define QUEUE_FLUSH_TIMEOUT_TICKS   msecs_to_jiffies(QUEUE_FLUSH_TIMEOUT)
+
+#define TX_DEINIT_TIMEOUT 5000
+#define TX_DEINIT_TIMEOUT_TICKS msecs_to_jiffies(TX_DEINIT_TIMEOUT)
+
+#ifdef CONFIG_PM
+#define PS_ECON_CFG_TIMEOUT 1000
+#define PS_ECON_CFG_TIMEOUT_TICKS msecs_to_jiffies(PS_ECON_CFG_TIMEOUT)
+#endif
+
+#define FW_ERR_PROCESS_TIMEOUT 5000   /* In milli-seconds*/
+#define FW_ERR_PROCESS_TIMEOUT_TICKS msecs_to_jiffies(FW_ERR_PROCESS_TIMEOUT)
+
+#define RXQ_EMPTY_TIMEOUT 5000   /* In milli-seconds*/
+#define RXQ_EMPTY_TIMEOUT_TICKS msecs_to_jiffies(RXQ_EMPTY_TIMEOUT)
+
+#define TX_COMPLETE_TIMEOUT 1000  /* In milli-seconds*/
+#define TX_COMPLETE_TIMEOUT_TICKS msecs_to_jiffies(TX_COMPLETE_TIMEOUT)
+#define SCAN_ABORT_TIMEOUT 1000
+#define SCAN_ABORT_TIMEOUT_TICKS msecs_to_jiffies(SCAN_ABORT_TIMEOUT)
+#define CANCEL_HW_ROC_TIMEOUT 1000
+#define CANCEL_HW_ROC_TIMEOUT_TICKS msecs_to_jiffies(CANCEL_HW_ROC_TIMEOUT)
+
+#define DEFAULT_TX_ANT_SELECT 3 /* bitmap of antennas for tx, 3=> both first and
+				 * second antenna to be used
+				 */
+#define DEFAULT_TX_POWER 15
+#define DEFAULT_RTS_THRESHOLD 2347
+#define SUPPORTED_FILTERS (FIF_ALLMULTI | FIF_BCN_PRBRESP_PROMISC)
+#define TX_DESC_BUCKET_BOUND 32
+
+#define MAX_DATA_SIZE (0) /* Defined in HAL (or) can be configured from proc */
+#define MAX_TX_QUEUE_LEN 192
+#define MAX_AUX_ADC_SAMPLES 10
+
+/* Maximum number of Tx streams supported */
+/* Maximum number of RX streams supported */
+	#define MAX_TX_STREAMS 1 
+	#define MAX_RX_STREAMS 1 
+
+#define   MAX_RSSI_SAMPLES 10
+#define   RPU_DBG_DEFAULT		0
+
+#define CLOCK_MASK 0x3FFFFFFF
+#define TICK_NUMRATOR 12288 /* 12288 KHz  */
+#define TICK_DENOMINATOR 1000 /* 1000 KHz */
+
+#define BTS_AP_24GHZ_ETS 195 /* Microsecs */
+#define BTS_AP_5GHZ_ETS 25 /* Microsecs */
+
+#define RF_PARAMS_SIZE 369
+#define DEFAULT_MAC_ADDRESS "001122334455"
+
+#define LPW_RECOVERY_FROM_RPU
+
+//#define PKTGEN_MULTI_TX
+
+enum ptype {
+	UCAST = 0,
+	MCAST
+};
+
+enum noa_triggers {
+	FROM_TX = 0,
+	FROM_TX_DONE,
+	FROM_EVENT_NOA
+};
+
+#define HW_SCAN_TIMEOUT_ABORT
+#ifdef RK3036_DONGLE
+#define HW_SCAN_TIMEOUT 5 // second
+#else
+#define HW_SCAN_TIMEOUT 10 // second
+#endif
+enum rpu_hw_scan_status {
+	HW_SCAN_STATUS_NONE,
+	HW_SCAN_STATUS_PROGRESS
+};
+
+struct wifi_sync {
+	unsigned int  status;
+	unsigned char ts1[8];
+	unsigned long long atu;
+	unsigned char  bssid[8];
+	unsigned char  name[10];
+	unsigned int  ts2;
+};
+
+struct wifi_params {
+	int ed_sensitivity;
+	int num_vifs;
+	int tx_fixed_rate;
+	int tx_fixed_mcs_indx;
+	int mgd_mode_tx_fixed_rate;
+	int mgd_mode_tx_fixed_mcs_indx;
+#ifdef HAL_PCIE
+	unsigned int pci_base_addr;
+	int no_words;
+#endif
+	unsigned int peer_ampdu_factor;
+	unsigned char is_associated;
+	unsigned char rate_protection_type;
+	unsigned char num_spatial_streams;
+	unsigned char enable_early_agg_checks;
+	unsigned char uccp_num_spatial_streams;
+	unsigned char auto_sensitivity;
+	/*RF Params: Input to the RF for operation*/
+	unsigned char  rf_params[RF_PARAMS_SIZE];
+	unsigned char  rf_params_vpd[RF_PARAMS_SIZE];
+	unsigned char production_test;
+	unsigned int dot11a_support;
+	unsigned int dot11g_support;
+	unsigned int chnl_bw;
+	unsigned int prod_mode_chnl_bw_40_mhz;
+	unsigned int sec_ch_offset_40_plus;
+	unsigned int sec_ch_offset_40_minus;
+
+	/*Multicast  Rate config options*/
+	unsigned int mgd_mode_mcast_fixed_rate_flags;
+	int mgd_mode_mcast_fixed_data_rate;
+	unsigned int mgd_mode_mcast_fixed_bcc_or_ldpc;
+	unsigned int mgd_mode_mcast_fixed_stbc_enabled;
+	unsigned int mgd_mode_mcast_fixed_preamble;
+	unsigned char mgd_mode_mcast_fixed_nss;
+	/*End*/
+
+	unsigned int prod_mode_rate_flag;
+	unsigned int prod_mode_rate_preamble_type;
+	unsigned int prod_mode_stbc_enabled;
+	unsigned int prod_mode_bcc_or_ldpc;
+	unsigned int max_tx_streams;
+	unsigned int max_rx_streams;
+	unsigned int max_data_size;
+	unsigned int disable_power_save;
+	unsigned int disable_sm_power_save;
+	unsigned int max_tx_cmds;
+	unsigned int prod_mode_chnl_bw_80_mhz;
+	unsigned int sec_40_ch_offset_80_plus;
+	unsigned int sec_40_ch_offset_80_minus;
+	unsigned int disable_beacon_ibss;
+	unsigned char bg_scan_channel_list[50];
+	unsigned char bg_scan_channel_flags[50];
+	unsigned int bg_scan_enable;
+	unsigned int bg_scan_intval;
+	unsigned int bg_scan_chan_dur;
+	unsigned int bg_scan_serv_chan_dur;
+	unsigned int bg_scan_num_channels;
+	unsigned int nw_selection;
+	unsigned int hw_scan_status;
+	unsigned int scan_type;
+	unsigned int set_tx_power;
+	unsigned int aux_adc_chain_id;
+	unsigned char pdout_voltage[MAX_AUX_ADC_SAMPLES];
+	char rssi_average[MAX_RSSI_SAMPLES];
+	unsigned int extra_scan_ies;
+	unsigned int fw_loaded;
+	struct wifi_sync sync[MAX_VIFS];
+	unsigned int bt_state;
+	unsigned int antenna_sel;
+	int fw_skip_rx_pkt_submit;
+	int pkt_gen_val;
+	int init_pkt_gen;
+	int payload_length;
+	int start_prod_mode;
+	int echo_mode;
+	int init_prod;
+	unsigned char bypass_vpd;
+	unsigned int cont_tx;
+#ifdef RPU_SLEEP_ENABLE
+	unsigned char rpu_sleep_type;
+#endif
+	int dapt_thresh_offset;
+	int dapt_thresh_exponent;
+	int dapt_thresh_min;
+	int dapt_thresh_max;
+
+	int min_dtim_peroid;
+};
+
+struct cmd_send_recv_cnt {
+	int tx_cmd_send_count;
+	int tx_done_recv_count;
+	int total_cmd_send_count;
+	unsigned int outstanding_ctrl_req;
+	unsigned long control_path_flags;
+	spinlock_t control_path_lock;
+	struct sk_buff_head outstanding_cmd;
+};
+
+#define OUTS_CMD_CHECK
+#ifdef OUTS_CMD_CHECK
+#define SET_TIME_TICKS_TO_SKB_CB(skb, ticks)	(*((unsigned long *)&((skb)->cb[0])) = ticks)
+#define GET_TIME_TICKS_FROM_SKB_CB(skb)			(*((unsigned long *)&((skb)->cb[0])))
+#endif
+
+struct wifi_stats {
+	unsigned int ht_tx_mcs0_packet_count;
+	unsigned int ht_tx_mcs1_packet_count;
+	unsigned int ht_tx_mcs2_packet_count;
+	unsigned int ht_tx_mcs3_packet_count;
+	unsigned int ht_tx_mcs4_packet_count;
+	unsigned int ht_tx_mcs5_packet_count;
+	unsigned int ht_tx_mcs6_packet_count;
+	unsigned int ht_tx_mcs7_packet_count;
+	unsigned int ht_tx_mcs8_packet_count;
+	unsigned int ht_tx_mcs9_packet_count;
+	unsigned int ht_tx_mcs10_packet_count;
+	unsigned int ht_tx_mcs11_packet_count;
+	unsigned int ht_tx_mcs12_packet_count;
+	unsigned int ht_tx_mcs13_packet_count;
+	unsigned int ht_tx_mcs14_packet_count;
+	unsigned int ht_tx_mcs15_packet_count;
+	unsigned int tx_cmds_from_stack;
+	unsigned int tx_dones_to_stack;
+	unsigned int system_rev;
+	unsigned int outstanding_cmd_cnt;
+	unsigned int max_outstanding_cmd_queue_cnt;
+	unsigned int pending_tx_cnt;
+	unsigned int umac_scan_req;
+	unsigned int umac_scan_complete;
+	unsigned int gen_cmd_send_count;
+	unsigned int tx_cmd_send_count_single;
+	unsigned int tx_cmd_send_count_multi;
+
+	unsigned int tx_noagg_not_qos;
+	unsigned int tx_noagg_not_ampdu;
+	unsigned int tx_noagg_not_addr;
+
+	unsigned int tx_cmd_send_count_beaconq;
+	unsigned int tx_done_recv_count;
+	unsigned int rx_packet_mgmt_count;
+	unsigned int rx_packet_data_count;
+	/*MAC Stats*/
+	unsigned int roc_start;
+	unsigned int roc_stop;
+	unsigned int roc_complete;
+	unsigned int roc_stop_complete;
+	/* TX related */
+	unsigned int tx_cmd_cnt; /* Num of TX commands received from host */
+	unsigned int tx_done_cnt; /* Num of Tx done events sent to host */
+	unsigned int tx_edca_trigger_cnt; /* Num times EDCA engine was
+					   * triggered
+					   */
+	unsigned int tx_edca_isr_cnt; /* Num of times EDCA ISR was generated */
+	unsigned int tx_start_cnt; /* Num of TX starts to MCP */
+	unsigned int tx_abort_cnt; /* Num of TX aborts detected */
+	unsigned int tx_abort_isr_cnt; /* Num of TX aborts received from MCP */
+	unsigned int tx_underrun_cnt; /* Num of under-runs */
+	unsigned int tx_rts_cnt; /* Num of RTS frames Txd */
+	unsigned int tx_ampdu_cnt; /* Num of AMPDUs txd incremented by 1 for
+				    * each A-MPDU (consisting of one or more
+				    * MPDUs)
+				    */
+	unsigned int tx_mpdu_cnt; /* Num of MPDUs txd  incremented by 1 for
+				   * MPDU (1 for each A-MPDU subframe)
+				   */
+	unsigned int tx_crypto_post; /* Num jobs posted to crypto */  
+	unsigned int tx_crypto_done; /* Jobs completed by crypto */
+	unsigned int rx_pkt_to_umac;  /* Num packets received by umac */
+	unsigned int rx_crypto_post;  /* Num jobs posted to crypto */
+	unsigned int rx_crypto_done;  /* Jobs completed by crypto */
+	/* RX related */
+	unsigned int rx_isr_cnt; /* Num of RX ISRs */
+	unsigned int rx_ack_cts_to_cnt; /* Num of timeouts ACK */
+	unsigned int rx_cts_cnt; /* Num of CTS frames received */
+	unsigned int rx_ack_resp_cnt; /* Num of Ack frames received */
+	unsigned int rx_ba_resp_cnt; /* Num of BA frames received */
+	unsigned int rx_fail_in_ba_bitmap_cnt; /* Num of BA frames indicating at
+						* least one failure in the BA
+						* bitmap
+						*/
+	unsigned int rx_circular_buffer_free_cnt; /* Num of entries returned to
+						   * RX circular buffers
+						   */
+	unsigned int rx_mic_fail_cnt; /* Num of MIC failures */
+
+	/* HAL related */
+	unsigned int hal_cmd_cnt; /* Num of commands received by HAL from the
+				   * host
+				   */
+	unsigned int hal_event_cnt; /* Num of events sent by HAL to the host */
+	unsigned int hal_ext_ptr_null_cnt; /* Num of packets dropped due to lack
+					    * of Ext Ram buffers from host
+					    */
+	/* LPW PHY Related */
+	unsigned int csync_timeout_cntr;      /* lpw phy stats - offset 0x120 */
+	unsigned int fsync_timeout_cntr;      /* lpw phy stats - offset 0x124 */
+	unsigned int acdrop_timeout_cntr;     /* lpw phy stats - offset 0x128 */
+	unsigned int csync_abort_agctrig_cntr;/* lpw phy stats - offset 0x12c */
+	unsigned int crc_success_cnt;  /* lmac crc succ cnt */
+	unsigned int crc_fail_cnt;  /* lmac crc fail cnt */
+#ifdef RPU_SLEEP_ENABLE
+	unsigned int rpu_boot_cnt; /* num of times lmac booted */
+	unsigned int sleep_stats[12];
+#endif
+	/*RF Calibration Data*/
+	unsigned int rf_calib_data_length;
+	unsigned char rf_calib_data[MAX_RF_CALIB_DATA];
+	unsigned int pdout_val;
+	unsigned char rpu_lmac_version[8];
+	unsigned char fw_version[32];
+};
+
+
+struct tx_pkt_info {
+	struct sk_buff_head pkt;
+	unsigned int hdr_len;
+	unsigned int queue;
+	unsigned int vif_index;
+	unsigned int rate[4];
+	unsigned int retries[4];
+	unsigned int curr_retries;
+	unsigned int max_retries;
+	int roc_peer_id;
+	int peer_id;
+	bool adjusted_rates;
+};
+
+
+struct tx_config {
+	/* Used to protect the TX pool */
+	spinlock_t lock;
+
+	/* Used to store tx tokens(buff pool ids) */
+	unsigned long buf_pool_bmp[(NUM_TX_DESCS/TX_DESC_BUCKET_BOUND) + 1];
+
+	unsigned int outstanding_tokens[NUM_ACS];
+	unsigned int next_spare_token_ac;
+
+	/* Used to store the address of pending skbs per ac */
+	struct sk_buff_head pending_pkt[MAX_PEND_Q_PER_AC]
+				       [NUM_ACS];
+
+	unsigned int curr_peer_opp[NUM_ACS];
+
+	/* Used to store the address of tx'ed skb and len of 802.11 hdr
+	 * it will be used in tx complete.
+	 */
+	struct tx_pkt_info pkt_info[NUM_TX_DESCS];
+
+	unsigned int queue_stopped_bmp;
+	struct sk_buff_head proc_tx_list[NUM_TX_DESCS];
+	unsigned int outstanding_pkts[NUM_TX_DESCS];
+	/* if is set to 1, means the tx desc id was sended to fw with no tx done */
+	unsigned int tx_desc_had_send_to_io[NUM_TX_DESCS];
+};
+
+enum device_state {
+	STOPPED = 0,
+	STARTED
+};
+
+enum tid_aggr_state {
+	TID_STATE_INVALID = 0,
+	TID_STATE_AGGR_START,
+	TID_STATE_AGGR_STOP,
+	TID_STATE_AGGR_OPERATIONAL
+};
+
+#define TID_INITIATOR_STA 0x0000
+#define TID_INITIATOR_AP 0x0010
+
+struct sta_tid_info {
+	unsigned short ssn;
+	enum tid_aggr_state tid_state;
+};
+
+#ifdef CONFIG_PM
+struct econ_ps_cfg_status {
+	unsigned char completed;
+	unsigned char result;
+	int wake_trig;
+	int processing;
+};
+#endif
+
+struct current_channel {
+	unsigned int pri_chnl_num;
+	unsigned int center_freq1;
+	unsigned int center_freq2;
+	unsigned int freq_band;
+	unsigned int ch_width;
+};
+
+struct roc_params {
+	unsigned char roc_in_progress;
+	unsigned char roc_starting;
+	unsigned int roc_type;
+	bool need_offchan;
+	atomic_t roc_mgmt_tx_count;
+};
+
+/* send null-frame to keep-alive with AP */
+//#define ENABLE_KEEP_ALIVE
+#define SEND_NULL_FRAME_INTERVAL_SECONDS	30
+
+/* enable recovery work when detect firmware error happens */
+#define ENABLE_FW_ERROR_RECOVERY
+
+/* Dynamic Adaptation of PHY Thresholds */
+#ifndef STA_AP_COEXIST
+#define ENABLE_DAPT
+#endif
+//#define ENABLE_DAPT_BEACON
+
+// half-dBm units without the negative sign
+// 140 represents -70 dBm
+#define DAPT_DEFAULT_PHY_THRESH	140
+#define DAPT_SCAN_PHY_THRESH 180
+#define DAPT_P2P_SCAN_PHY_THRESH 140
+#define DAPT_NON_STA_CONN_PHY_THRESH	140
+
+#ifdef ENABLE_DAPT
+/*
+ * use latest e.g. 100 rx rssi within 1 seconds to calcute average rssi
+ * use average rssi to calcute phy thresh
+ */
+#define DAPT_CALC_INTERVAL 1000 // ms
+#define DAPT_MAX_RSSI_SAMPLE 100
+#define DAPT_MIN_RSSI_SAMPLE 10
+
+#define DAPT_PHY_THRESH_MIN	110
+#define DAPT_PHY_THRESH_MAX	190
+
+#define DAPT_THRESH_OFFSET 50	// means set the PHY thresholds 25 dB below the true RSSI
+								// half-dB  steps  (e.g.,  60  means  30  dBm)
+#define DAPT_THRESH_EXPONENT 4
+
+#define DAPT_SETED_PHY_THRESH_COUNT	60
+
+struct dapt_params {
+	int main_index;
+	int p2p_index;
+	unsigned char vif_addr[MAX_VIFS][ETH_ALEN];
+	unsigned char bssid[MAX_VIFS][ETH_ALEN];
+	int conn_state[MAX_VIFS];
+
+	int dapt_disable;
+	struct timer_list dapt_timer;
+	int timer_start;
+
+	// save rx frame rssi samples
+	s8 sam_history[MAX_VIFS][DAPT_MAX_RSSI_SAMPLE];
+	int sam_read[MAX_VIFS];
+	int sam_write[MAX_VIFS];
+	int sam_size[MAX_VIFS];
+
+	// save beacon rssi samples
+	s8 bcn_history[MAX_VIFS][DAPT_MAX_RSSI_SAMPLE];
+	int bcn_read[MAX_VIFS];
+	int bcn_write[MAX_VIFS];
+	int bcn_size[MAX_VIFS];
+
+	unsigned int thresh_accum[MAX_VIFS];
+	unsigned int avg_thresh[MAX_VIFS];
+	unsigned int new_thresh[MAX_VIFS];	// calc from rssi
+
+	unsigned int cur_seted_thresh[14]; // current seted phy thresh to rpu
+	unsigned int save_seted_thresh[14]; // saved seted phy thresh to rpu
+
+	// history of seted phy thresh	
+	unsigned int thr_history[14][DAPT_SETED_PHY_THRESH_COUNT];
+	int cur_thr_offset[14];
+	int last_thresh;
+	int both_zero_count;
+};
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+extern void dapt_timer_expiry(struct timer_list *t);
+#else
+extern void dapt_timer_expiry(unsigned long data);
+#endif
+#endif
+
+struct vif_info_s {
+	unsigned char vif_addr[MAX_VIFS][ETH_ALEN];
+	unsigned char bssid[MAX_VIFS][ETH_ALEN];
+	int conn_state[MAX_VIFS];
+};
+
+struct img_priv {
+	struct proc_dir_entry *umac_proc_dir_entry;
+	struct device *dev;
+	struct mac_address if_mac_addresses[MAX_VIFS];
+	unsigned int current_vif_count;
+	unsigned int active_vifs;
+	struct mutex mutex;
+	struct mutex scan_mutex;
+	int state;
+	int txpower;
+	unsigned char mc_filters[MCST_ADDR_LIMIT][6];
+	int mc_filter_count;
+	void *net_dev;
+	void *sdata;
+	int sniffer;
+
+	struct tasklet_struct proc_tx_tasklet;
+	/*ROC Work*/
+	struct delayed_work roc_complete_work;
+	struct roc_params roc_params;
+	struct current_channel cur_chan;
+	struct tx_config tx;
+	struct sk_buff_head pending_pkt[NUM_ACS];
+
+	/* Regulatory stuff */
+	char alpha2[2]; /* alpha2 country code */
+#ifdef CONFIG_PM
+	struct econ_ps_cfg_status econ_ps_cfg_stats;
+#endif
+	struct wifi_params *params;
+	struct wifi_stats  *stats;
+	struct fw_info_dump *fw_info;
+	char name[20];
+	char scan_abort_done;
+	char cancel_hw_roc_done;
+	char cancel_roc;
+	char chan_prog_done;
+	char reset_complete;
+	char tx_deinit_complete;
+	int power_save; /* Will be set only when a single VIF in
+			 * STA mode is active
+			 */
+	struct ieee80211_vif *vifs[MAX_VIFS];
+	struct ieee80211_sta *peers[MAX_PEERS];
+	struct ieee80211_hw *hw;
+	struct sta_tid_info  tid_info[32];
+	spinlock_t bcast_lock; /* Used to ensure more_frames bit is set properly
+				* when transmitting bcast frames in AP in IBSS
+				* modes
+				*/
+	spinlock_t roc_lock;
+	unsigned char tx_antenna;
+	unsigned char tx_last_beacon;
+	unsigned int rts_threshold;
+#ifdef RPU_SLEEP_ENABLE
+	struct timer_list init_sleep_timer;
+#endif
+#ifdef ENABLE_DAPT
+	spinlock_t dapt_lock;
+	struct dapt_params dapt_params;
+#endif
+#ifdef ENABLE_SPLIT_MULT_SSID_SCAN
+	struct scan_req remain_scan_req;
+	int scan_req_vif_iface;
+#endif
+#ifdef HW_SCAN_TIMEOUT_ABORT
+	struct timer_list scan_timer;
+#endif
+	struct timer_list roc_timer;
+	struct mutex scan_cancel_mutex;
+	spinlock_t scan_cancel_lock;
+	int in_scan_timeout;
+	int cmd_reset_count;
+	int iftype;
+	int p2p_scan;
+#ifdef ENABLE_KEEP_ALIVE
+	struct timer_list keep_alive_timer;
+#endif
+	struct vif_info_s vif_info;
+	int pri_chnl_num;
+
+	/* null frame info */
+	unsigned short null_frame_seq_no;
+	int null_frame_desc_id;
+	int null_frame_sending;
+	int null_frame_send_count;
+	struct sk_buff *null_frame_skb;
+
+	int tx_retry_frm_cnt;
+
+	char read_csr_complete;
+	unsigned int read_csr_value;
+};
+
+struct fw_info_dump {
+#define MAX_FW_INFO_SIZE (32*1024)
+	unsigned char *info;
+	unsigned int len;
+	unsigned int offset;
+	unsigned int finish;
+	unsigned int type;
+	unsigned int reg;
+	/* following variable must be at end */
+	unsigned long long last_total_tick;
+	unsigned long long last_total_isr_tick;
+};
+
+extern struct wifi_dev *wifi;
+struct wifi_dev {
+	struct proc_dir_entry *umac_proc_dir_entry;
+	struct wifi_params params;
+	struct wifi_stats stats;
+	struct ieee80211_hw *hw;
+	struct fw_info_dump fw_info;
+};
+
+struct edca_params {
+	unsigned short txop; /* units of 32us */
+	unsigned short cwmin;/* units of 2^n-1 */
+	unsigned short cwmax;/* units of 2^n-1 */
+	unsigned char aifs;
+	unsigned char uapsd;
+};
+
+struct umac_vif {
+	struct timer_list bcn_timer;
+	struct uvif_config {
+		unsigned int atim_window;
+		unsigned int aid;
+		unsigned int bcn_lost_cnt;
+		struct edca_params edca_params[NUM_ACS];
+	} config;
+
+	unsigned int noa_active;
+	struct sk_buff_head noa_que;
+	unsigned int noa_tx_allowed;
+
+	int vif_index;
+	struct ieee80211_vif *vif;
+	struct img_priv *priv;
+	unsigned char bssid[ETH_ALEN];
+	unsigned int peer_ampdu_factor;
+
+	/*Global Sequence no for non-qos and mgmt frames/vif*/
+	__u16 seq_no;
+
+};
+
+struct umac_sta {
+	int index;
+	int vif_index;
+};
+
+
+struct curr_peer_info {
+	int id;
+	int op_chan_idx;
+};
+
+#ifdef ENABLE_DAPT
+extern void dapt_param_init(struct img_priv *priv);
+extern void dapt_param_late_init(struct img_priv *priv);
+extern void dapt_param_deinit(struct img_priv *priv);
+extern void dapt_notify_bssid_change(struct img_priv *priv,
+					int index,
+					unsigned char *vif_addr,
+					unsigned char *bssid);
+extern void dapt_notify_conn_state(struct img_priv *priv,
+					int index,
+					unsigned char *vif_addr,					
+					unsigned int connect_state);
+extern void dapt_timer_handler(struct img_priv *priv);
+extern void dapt_disable(struct img_priv *priv, int disable);
+extern int dapt_set_phy_thresh(struct img_priv *priv, int thresh, int ch, int set);
+extern void dapt_scan(struct img_priv *priv);
+extern void dapt_scan_complete(struct img_priv *priv);
+extern void dapt_beacon(struct img_priv *priv, s8 rssi, int index);
+#endif
+extern void init_vif_info(struct img_priv *priv);
+extern bool is_wlan_connected(struct img_priv *priv);
+extern bool is_p2p_connected(struct img_priv *priv);
+extern int  rpu_core_init(struct img_priv *priv, unsigned int ftm);
+extern void rpu_core_deinit(struct img_priv *priv, unsigned int ftm);
+extern void rpu_vif_add(struct umac_vif  *uvif);
+extern void rpu_vif_remove(struct umac_vif *uvif);
+extern void rpu_vif_set_edca_params(unsigned short queue,
+					    struct umac_vif *uvif,
+					    struct edca_params *params,
+					    unsigned int vif_active);
+extern void rpu_vif_bss_info_changed(struct umac_vif *uvif,
+					     struct ieee80211_bss_conf
+					     *bss_conf, unsigned int changed);
+extern int  rpu_tx_frame(struct sk_buff *skb,
+				 struct ieee80211_sta *sta,
+				 struct img_priv *priv,
+				 bool bcast);
+extern int __rpu_tx_frame(struct img_priv *priv,
+				  unsigned int queue,
+				  unsigned int token_id,
+				  unsigned int more_frames,
+				  bool retry);
+extern void rpu_tx_init(struct img_priv *priv);
+extern void rpu_tx_deinit(struct img_priv *priv);
+void rpu_tx_proc_send_pend_frms_all(struct img_priv *priv,
+					   int chan_id);
+extern void proc_bss_info_changed(unsigned char *mac_addr, int value);
+extern void packet_generation(unsigned long data);
+extern int wait_for_reset_complete(struct img_priv *priv, int enable);
+extern int wait_for_read_csr_cmp(struct img_priv *priv);
+
+extern int rpu_tx_proc_pend_frms(struct img_priv *priv,
+				   int queue,
+				   int token_id);
+int get_token(struct img_priv *priv,
+		     int queue);
+void free_token(struct img_priv *priv,
+		int token_id,
+		int queue);
+
+struct curr_peer_info get_curr_peer_opp(struct img_priv *priv,
+		      int queue);
+
+int rpu_flush_vif_queues(struct img_priv *priv,
+			     struct umac_vif *uvif,
+			     int chanctx_idx,
+			     unsigned int hw_queue_map,
+			     enum UMAC_VIF_CHANCTX_TYPE vif_chanctx_type,
+			     bool drop);
+
+int rpu_discard_sta_pend_q(struct img_priv *priv,
+				   struct umac_vif *uvif,
+				   int peer_id,
+				   unsigned int hw_queue_map);
+
+int rpu_discard_sta_tx_q(struct img_priv *priv,
+				   struct umac_vif *uvif,
+				   int peer_id,
+				   unsigned int hw_queue_map,
+				   int chanctx_idx);
+/* Beacon TimeStamp */
+__s32 __attribute__((weak)) frc_to_atu(__u32 frccnt, __u64 *patu, s32 dir);
+int __attribute__((weak)) get_evt_timer_freq(unsigned int *mask,
+						unsigned int *num,
+						unsigned int *denom);
+
+int tx_queue_map(int queue);
+int tx_queue_unmap(int queue);
+
+extern unsigned char *rf_params_vpd;
+extern int num_streams_vpd;
+
+static __always_inline long param_get_val(unsigned char *buf,
+			  unsigned char *str,
+			  unsigned long *val)
+{
+	unsigned char *temp;
+
+	if (strstr(buf, str)) {
+		temp = strstr(buf, "=") + 1;
+		/*To handle the fixed rate 5.5Mbps case*/
+		if (!strncmp(temp, "5.5", 3)) {
+			*val = 55;
+			return 1;
+		} else if (!kstrtoul(temp, 0, val)) {
+			return 1;
+		} else {
+			return 0;
+		}
+	} else {
+		return 0;
+	}
+}
+
+/*parse like: read_fw_reg=0x42000000,0x4 */
+static __always_inline long param_get_val2(unsigned char *buf,
+			  unsigned char *str,
+			  unsigned long *val, unsigned long *val2)
+{
+	unsigned char *temp, *temp2;
+
+	if (strstr(buf, str)) {
+		temp = strstr(buf, "=") + 1;
+		temp2 = strstr(buf, ",");
+		if (temp2)
+			*temp2 = 0;
+		if (!kstrtoul(temp, 16, val)) {
+			if (temp2 && !kstrtoul(temp2+1, 16, val2)) {
+				return 1;
+			}
+			return 1;
+		} else {
+			return 0;
+		}
+	} else {
+		return 0;
+	}
+}
+
+static __always_inline long param_get_sval(unsigned char *buf,
+			   unsigned char *str,
+			   long *val)
+{
+
+	unsigned char *temp;
+
+	if (strstr(buf, str)) {
+		temp = strstr(buf, "=") + 1;
+		/*To handle the fixed rate 5.5Mbps case*/
+		if (!strncmp(temp, "5.5", 3)) {
+			*val = 55;
+			return 1;
+		} else if (!kstrtol(temp, 0, val)) {
+			return 1;
+		} else {
+			return 0;
+		}
+	} else {
+		return 0;
+	}
+
+}
+
+static __always_inline long param_get_match(unsigned char *buf,
+				unsigned char *str)
+{
+
+	if (strstr(buf, str))
+		return 1;
+	else
+		return 0;
+}
+
+static __always_inline char *get_string_from_rate(int rate,
+						   unsigned int flags)
+{
+	if (rate == -1)
+		return "Disabled";
+
+
+	if (flags & ENABLE_11N_FORMAT)
+		return "HT";
+
+	return "Legacy";
+}
+
+static __always_inline bool check_valid_rate_flags(struct img_priv *priv,
+						   unsigned long val)
+{
+	bool ret = false;
+
+	do {
+		if (val != 8 && val != 0)
+			break;
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+static __always_inline bool check_valid_data_rate(struct img_priv *priv,
+						  int dr,
+						  enum ptype type)
+{
+	bool is_mcs = dr & 0x80;
+	bool ret = false;
+	unsigned int rate;
+	unsigned int nss;
+
+	if (type == UCAST) {
+		rate = priv->params->prod_mode_rate_flag;
+		nss  = priv->params->num_spatial_streams;
+	} else {
+		rate = priv->params->mgd_mode_mcast_fixed_rate_flags;
+		nss  = priv->params->mgd_mode_mcast_fixed_nss;
+	}
+
+	if (dr == -1)
+		return true;
+
+	if (is_mcs) {
+		dr = dr & 0x7F;
+		if (rate & ENABLE_11N_FORMAT) {
+			if (nss == 1) {
+				if ((dr >= 0) && (dr <= 7))
+					ret = true;
+				else
+					RPU_ERROR_MAIN("Invalid SISO HT MCS: %d\n",
+					       dr);
+			}
+		}
+
+	} else {
+		if (priv->params->dot11g_support == 1 &&
+		    ((dr == 1) ||
+		     (dr == 2) ||
+		     (dr == 55) ||
+		     (dr == 11))) {
+			ret = true;
+		} else if ((dr == 6) ||
+			   (dr == 9) ||
+			   (dr == 12) ||
+			   (dr == 18) ||
+			   (dr == 24) ||
+			   (dr == 36) ||
+			   (dr == 48) ||
+			   (dr == 54) ||
+			   (dr == -1)) {
+			ret = true;
+		} else
+			RPU_ERROR_MAIN("Invalid Legacy Rate value: %d\n", dr);
+		if ((rate & ENABLE_11N_FORMAT)
+		    ) {
+			ret = false;
+			RPU_ERROR_MAIN("Invalid rate_flags for legacy: %d\n", dr);
+		}
+	}
+	return ret;
+}
+
+static inline int vif_addr_to_index(unsigned char *addr,
+				    struct img_priv *priv)
+{
+	int i;
+	struct ieee80211_vif *vif = NULL;
+
+	for (i = 0; i < MAX_VIFS; i++) {
+		if (!((i < MAX_VIFS) && (priv->active_vifs & (1 << i))))
+			continue;
+
+		rcu_read_lock();
+		vif = rcu_dereference(priv->vifs[i]);
+		rcu_read_unlock();
+
+		if (ether_addr_equal(addr, vif->addr))
+			break;
+	}
+
+	if (i < priv->params->num_vifs)
+		return i;
+	else
+		return -1;
+}
+
+static inline int ieee80211_is_unicast_robust_mgmt_frame(struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+
+	if (skb->len < 24 || is_multicast_ether_addr(hdr->addr1))
+		return 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	return ieee80211_is_robust_mgmt_frame(skb);
+#else
+	return ieee80211_is_robust_mgmt_frame(hdr);
+#endif
+}
+static inline bool is_bufferable_mgmt_frame(struct ieee80211_hdr *hdr)
+{
+	__u16 fc = hdr->frame_control;
+	/*TODO: Handle Individual Probe Response frame in IBSS*/
+	if (ieee80211_is_action(fc) ||
+		ieee80211_is_disassoc(fc) ||
+		ieee80211_is_deauth(fc))
+		return	true;
+
+	return false;
+}
+
+
+static inline void img_ether_addr_copy(char *dst, const char *src)
+{
+	memcpy(dst, src, ETH_ALEN);
+}
+
+void set_rf_params(unsigned char *rf_params);
+int proc_init(struct proc_dir_entry ***main_dir_entry);
+int rpu_init(void);
+void rpu_exit(void);
+void proc_exit(void);
+void update_mcs_packet_stat(int mcs_rate_num,
+				   int rate_flags,
+				   struct img_priv *priv);
+int rpu_proc_tx(struct img_priv *priv, int descriptor_id, int queue);
+void rpu_unblock_all_frames(struct img_priv *priv,
+					    int ch_id);
+int load_rompatch(struct ieee80211_hw *hw);
+void stop(struct ieee80211_hw *hw);
+int start_prod_mode(struct img_priv *priv, unsigned int val);
+int stop_prod_mode(struct img_priv *priv, unsigned int val);
+int start_prod_rx_mode(struct img_priv *priv, unsigned int val,
+					unsigned char *bssid, unsigned char *mac_addr);
+int start_prod_echo_mode(struct img_priv *priv, unsigned int val);
+int start_packet_gen(struct img_priv *priv, int sval);
+int stop_packet_gen(struct img_priv *priv, int sval);
+int get_rate_prod(struct cmd_tx_ctrl *txcmd,
+		     struct img_priv *priv);
+int img_resume(struct ieee80211_hw *hw);
+int img_suspend(struct ieee80211_hw *hw,
+		       struct cfg80211_wowlan *wowlan);
+void init_beacon (struct umac_vif *uvif);
+void deinit_beacon (struct umac_vif *uvif);
+void modify_beacon_params (struct umac_vif *uvif,
+				  struct ieee80211_bss_conf *bss_conf);
+void trigger_wifi_power_save(int val);
+void trigger_wifi_scan_abort(int if_idx);
+
+extern void read_mem_region(unsigned int,int);
+#define RPU_READY_TIMEOUT 200
+#define RPU_READY_TIMEOUT_TICKS msecs_to_jiffies(RPU_READY_TIMEOUT)
+#define RPU_EVENT_RPU_READY 0xDEAD
+
+#ifdef RPU_SLEEP_ENABLE
+#define OUTSTANDING_CMDS_COMPLETE_TIMEOUT 100
+#define OUTSTANDING_CMDS_COMPLETE_TIMEOUT_TICKS msecs_to_jiffies(OUTSTANDING_CMDS_COMPLETE_TIMEOUT)
+
+#define RPU_INIT_SLEEP_TIMEOUT 2000
+#endif
+
+extern bool rpu_is_cmd_has_data(unsigned char *data);
+extern int rpu_send_cmd_datas(unsigned char *data, struct hal_priv *priv);
+extern void dump_ieee80211_hdr_info(unsigned char *data, int len, int tx);
+extern int rockchip_wifi_mac_addr(unsigned char *buf);
+extern int iw_send_hang_event(struct img_priv *priv);
+
+extern void init_roc_timeout_timer (struct img_priv *priv);
+extern void start_roc_timeout_timer(struct img_priv *priv, int timeout);
+extern void deinit_roc_timeout_timer (struct img_priv *priv);
+
+#endif /* _CORE_H_ */
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/debug.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/debug.h
new file mode 100755
index 000000000..28ed9f869
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/debug.h
@@ -0,0 +1,470 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _DEBUG_H_
+#define _DEBUG_H_
+
+#include <linux/time.h>
+
+extern int rpu_debug;
+extern int rpu_debug_level;
+
+#define MODULE_TAG "RK915: "
+#define DEBUG_TAG "DEBUG: "
+#define INFO_TAG "INFO: "
+#define ERROR_TAG "ERROR: "
+
+#define RPU_DEBUG_MAIN(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_MAIN &&	\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)      \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_INFO_MAIN(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_MAIN &&	\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)      \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_ERROR_MAIN(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_MAIN &&	\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)      \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_DEBUG_UMACIF(fmt, ...)        \
+do {                                         \
+	if (rpu_debug & RPU_DEBUG_UMACIF &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)  \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);  \
+} while (0)
+
+#define RPU_INFO_UMACIF(fmt, ...)        \
+do {                                         \
+	if (rpu_debug & RPU_DEBUG_UMACIF &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)  \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);  \
+} while (0)
+
+#define RPU_ERROR_UMACIF(fmt, ...)        \
+do {                                         \
+	if (rpu_debug & RPU_DEBUG_UMACIF &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)  \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);  \
+} while (0)
+
+#define RPU_DEBUG_CRYPTO(fmt, ...)           \
+do {                                           \
+	if (rpu_debug & RPU_DEBUG_CRYPTO &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)     \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);    \
+} while (0)
+
+#define RPU_INFO_CRYPTO(fmt, ...)           \
+do {                                           \
+	if (rpu_debug & RPU_DEBUG_CRYPTO &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)     \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);    \
+} while (0)
+
+#define RPU_ERROR_CRYPTO(fmt, ...)           \
+do {                                           \
+	if (rpu_debug & RPU_DEBUG_CRYPTO &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)     \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);    \
+} while (0)
+
+#define RPU_DEBUG_VIF(fmt, ...)			\
+do {                                             \
+	if (rpu_debug & RPU_DEBUG_VIF &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)		  \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);      \
+} while (0)
+
+#define RPU_INFO_VIF(fmt, ...)			\
+do {                                             \
+	if (rpu_debug & RPU_DEBUG_VIF &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)		  \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);      \
+} while (0)
+
+#define RPU_ERROR_VIF(fmt, ...)			\
+do {                                             \
+	if (rpu_debug & RPU_DEBUG_VIF &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)		  \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);      \
+} while (0)
+
+#define RPU_DEBUG_TX(fmt, ...)			\
+do {                                             \
+	if (rpu_debug & RPU_DEBUG_TX &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)		  \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);      \
+} while (0)
+
+#define RPU_INFO_TX(fmt, ...)			\
+do {                                             \
+	if (rpu_debug & RPU_DEBUG_TX &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)		  \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);      \
+} while (0)
+
+#define RPU_ERROR_TX(fmt, ...)			\
+do {                                             \
+	if (rpu_debug & RPU_DEBUG_TX &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)		  \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);      \
+} while (0)
+
+#define RPU_DEBUG_SCAN(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_SCAN &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)      \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_INFO_SCAN(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_SCAN &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)      \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_ERROR_SCAN(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_SCAN &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)      \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_DEBUG_ROC(fmt, ...)            \
+do {                                         \
+	if (rpu_debug & RPU_DEBUG_ROC &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)      \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);  \
+} while (0)
+
+#define RPU_INFO_ROC(fmt, ...)            \
+do {                                         \
+	if (rpu_debug & RPU_DEBUG_ROC &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)      \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);  \
+} while (0)
+
+#define RPU_ERROR_ROC(fmt, ...)            \
+do {                                         \
+	if (rpu_debug & RPU_DEBUG_ROC &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)      \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);  \
+} while (0)
+
+#define RPU_DEBUG_TSMC(fmt, ...)             \
+do {                                           \
+	if (rpu_debug & RPU_DEBUG_TSMC &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)       \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);    \
+} while (0)
+
+#define RPU_INFO_TSMC(fmt, ...)             \
+do {                                           \
+	if (rpu_debug & RPU_DEBUG_TSMC &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)       \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);    \
+} while (0)
+
+#define RPU_ERROR_TSMC(fmt, ...)             \
+do {                                           \
+	if (rpu_debug & RPU_DEBUG_TSMC &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)       \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);    \
+} while (0)
+
+#define RPU_DEBUG_IF(fmt, ...)              \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_IF &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)        \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_INFO_IF(fmt, ...)              \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_IF &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)        \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_ERROR_IF(fmt, ...)              \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_IF &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)        \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_DEBUG_HAL(fmt, ...)                           \
+do {							\
+	if ((rpu_debug & RPU_DEBUG_HAL) /*&& net_ratelimit()*/	&&	\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG) \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);	 \
+} while (0)
+
+#define RPU_INFO_HAL(fmt, ...)                           \
+do {							\
+	if ((rpu_debug & RPU_DEBUG_HAL)	&&	\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO) \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);	 \
+} while (0)
+
+#define RPU_ERROR_HAL(fmt, ...)                           \
+do {							\
+	if ((rpu_debug & RPU_DEBUG_HAL)	&&	\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR) \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);	 \
+} while (0)
+
+#define RPU_DEBUG_DUMP_HAL(fmt, ...)                           \
+do {							\
+	if (rpu_debug & RPU_DEBUG_DUMP_HAL)			\
+		print_hex_dump(KERN_DEBUG, fmt, ##__VA_ARGS__);	 \
+} while (0)
+
+#define DUMP_HAL (rpu_debug & RPU_DEBUG_DUMP_HAL)
+
+#define RPU_DEBUG_DUMP_TX(fmt, ...)                           \
+do {							\
+	if (rpu_debug & RPU_DEBUG_DUMP_TX)			\
+		print_hex_dump(KERN_DEBUG, "DUMP_TX", fmt, ##__VA_ARGS__);	 \
+} while (0)
+
+#define DUMP_TX (rpu_debug & RPU_DEBUG_DUMP_TX)
+
+#define RPU_DEBUG_SDIO(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_SDIO &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)      \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_INFO_SDIO(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_SDIO &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)      \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_ERROR_SDIO(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_SDIO &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)      \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_DEBUG_P2P(fmt, ...)        \
+do {                                         \
+	if (rpu_debug & RPU_DEBUG_P2P &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)  \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);  \
+} while (0)
+
+#define RPU_INFO_P2P(fmt, ...)        \
+do {                                         \
+	if (rpu_debug & RPU_DEBUG_P2P &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)  \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);  \
+} while (0)
+
+#define RPU_ERROR_P2P(fmt, ...)        \
+do {                                         \
+	if (rpu_debug & RPU_DEBUG_P2P &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)  \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);  \
+} while (0)
+
+#define RPU_DEBUG_RX(fmt, ...)                            \
+do {                                                        \
+	if ((rpu_debug & RPU_DEBUG_RX) /*&& net_ratelimit()*/ &&	\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG) \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);                 \
+} while (0)
+
+#define RPU_INFO_RX(fmt, ...)                            \
+do {                                                        \
+	if ((rpu_debug & RPU_DEBUG_RX) &&	\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO) \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);                 \
+} while (0)
+
+#define RPU_ERROR_RX(fmt, ...)                            \
+do {                                                        \
+	if ((rpu_debug & RPU_DEBUG_RX) &&	\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR) \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);                 \
+} while (0)
+
+#define RPU_DEBUG_DUMP_RX(fmt, ...)                           \
+do {                                                            \
+	if (rpu_debug & RPU_DEBUG_DUMP_RX)                     \
+		print_hex_dump(KERN_DEBUG, fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_INFO_FIRMWARE(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_FIRMWARE &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)      \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_ERROR_FIRMWARE(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_FIRMWARE &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)      \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_DEBUG_FIRMWARE(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_FIRMWARE &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)      \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+
+#define RPU_INFO_HALIO(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_HALIO &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)      \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_ERROR_HALIO(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_HALIO &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)      \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_DEBUG_HALIO(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_HALIO &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)      \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+
+#define DUMP_RX (rpu_debug & RPU_DEBUG_DUMP_RX)
+
+#define RPU_INFO_DAPT(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_DAPT &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)      \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_ERROR_DAPT(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_DAPT &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)      \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_DEBUG_DAPT(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_DAPT &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)      \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_INFO_ROCOVERY(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_ROCOVERY &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_INFO)      \
+		pr_info(MODULE_TAG INFO_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_ERROR_ROCOVERY(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_ROCOVERY &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_ERROR)      \
+		pr_err(MODULE_TAG ERROR_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+#define RPU_DEBUG_ROCOVERY(fmt, ...)            \
+do {                                          \
+	if (rpu_debug & RPU_DEBUG_ROCOVERY &&		\
+		rpu_debug_level & RPU_DEBUG_LEVEL_DEBUG)      \
+		pr_info(MODULE_TAG DEBUG_TAG fmt, ##__VA_ARGS__);   \
+} while (0)
+
+enum rpu_debug {
+	RPU_DEBUG_SCAN			= BIT(1),
+	RPU_DEBUG_ROC			= BIT(2),
+	RPU_DEBUG_TX			= BIT(3),
+	RPU_DEBUG_MAIN			= BIT(4),
+	RPU_DEBUG_IF			= BIT(5),
+	RPU_DEBUG_UMACIF		= BIT(6),
+	RPU_DEBUG_RX			= BIT(7),
+	RPU_DEBUG_HAL			= BIT(8),
+	RPU_DEBUG_CRYPTO		= BIT(9),
+	RPU_DEBUG_DUMP_RX		= BIT(10),
+	RPU_DEBUG_DUMP_HAL		= BIT(11),
+	RPU_DEBUG_TSMC			= BIT(12),
+	RPU_DEBUG_P2P			= BIT(13),
+	RPU_DEBUG_VIF			= BIT(14),
+	RPU_DEBUG_DUMP_TX		= BIT(15),
+	RPU_DEBUG_SDIO			= BIT(16),
+	RPU_DEBUG_FIRMWARE		= BIT(17),
+	RPU_DEBUG_HALIO			= BIT(18),
+	RPU_DEBUG_DAPT			= BIT(19),
+	RPU_DEBUG_ROCOVERY		= BIT(20),
+};
+
+enum rpu_debug_level {
+	RPU_DEBUG_LEVEL_ERROR			= BIT(1),
+	RPU_DEBUG_LEVEL_INFO			= BIT(2),
+	RPU_DEBUG_LEVEL_DEBUG			= BIT(3),
+};
+
+#define VIF_INDEX_TO_INTERFACE_NAME(x)					\
+	((x==0) ? "p2p0":"wlan0")
+
+#define START_PROFILE_LOCAL								\
+	struct timeval start_time, end_time;				\
+	do_gettimeofday(&start_time);
+
+#define END_PROFILE_LOCAL								\
+	do_gettimeofday(&end_time);							\
+	pr_info("%s: use %ld (us)\n", __func__, 				\
+		((end_time.tv_sec & 0xFFF) * 1000000 + end_time.tv_usec) -	\
+		((start_time.tv_sec & 0xFFF) * 1000000 + start_time.tv_usec));
+
+#define INIT_GET_SPEND_TIME(start_time, end_time)		\
+	struct timeval start_time, end_time;
+
+#define START_GET_SPEND_TIME(start_time, end_time)		\
+	do_gettimeofday(&start_time);
+
+#define END_GET_SPEND_TIME(start_time, end_time)		\
+	do_gettimeofday(&end_time);
+
+#define GET_SPEND_TIME_US(start_time, end_time)			\
+	(((end_time.tv_sec & 0xFFF) * 1000000 + end_time.tv_usec) -	\
+	((start_time.tv_sec & 0xFFF) * 1000000 + start_time.tv_usec))
+
+void convert_cmd_to_str(int id, char *str);
+void convert_event_to_str(int id, char *str);
+
+/* enable tx rx stability test */
+//#define SDIO_TXRX_STABILITY_TEST
+
+//#define DUMP_MORE_DEBUG_INFO
+//#define DUMP_TX_RX_FRAME_INFO
+
+#endif /* _DEBUG_H_ */
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/firmware.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/firmware.h
new file mode 100755
index 000000000..98d2a8bef
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/firmware.h
@@ -0,0 +1,51 @@
+#ifndef _RK915_FIRMWARE_H_
+#define _RK915_FIRMWARE_H_
+
+#define FW_LOADER_FROM_USER
+
+// 1: use flip_open to get firmware; 0 use request_firmware
+#define FW_LOADER_FROM_USER_OPEN	1
+#define MAX_FW_BUF_SIZE (64*1024)
+#define MAX_PATCH_BUF_SIZE (17*1024)
+#define MAX_BLOCK_DATA_SIZE 4096
+
+struct firmware_info {
+	int fw_saved;
+	int fw_size;
+	unsigned char *block_data;
+	unsigned char *fw_data;
+	int patch_size;
+	unsigned char *patch_data;
+	int patch2_size;
+	unsigned char *patch2_data;
+	int cal_size;
+	unsigned char *cal_data;
+	int rf_para_size;
+	unsigned char *rf_para_data;	
+	unsigned char *fw_data_check;
+	unsigned char *fw_start_data;
+	const struct firmware *fw_fw;
+	const struct firmware *patch_fw;
+	const struct firmware *patch2_fw;
+	const struct firmware *cal_fw;
+};
+
+#define RF_CAL_DATA_SIZE 156
+#define RF_CAL_TAG "RFCD"
+#define RF_PARA_DATA_SIZE (94 * 2)
+
+struct rf_cal_hdr {
+	unsigned char tag[4];
+	unsigned int size;	// total size, include header
+	unsigned int cal_enable;
+	unsigned char cal_data[RF_CAL_DATA_SIZE];
+};
+
+#define RF_CAL_DATA_FILE	"rk915_cal.bin"
+#define RF_PARA_DATA_FILE	"rk915_rf_para.txt"
+
+int rk915_download_firmware(struct hal_priv *priv);
+int rk915_alloc_firmware_buf(struct firmware_info *fw_info);
+void rk915_free_firmware_buf(struct firmware_info *fw_info);
+void rk915_mem_check2(struct hal_priv *priv, unsigned int addr, unsigned int len);
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/fw_data.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/fw_data.h
new file mode 100755
index 000000000..babce3150
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/fw_data.h
@@ -0,0 +1,777 @@
+#ifndef _FW_DATA_H_
+#define _FW_DATA_H_
+
+unsigned char fwdata[] = {
+0x00, 0xC8, 0x00, 0x10, 0xED, 0x08, 0x00, 0x10, 0x29, 0x08, 0x00, 0x10, 0xC9, 0x07, 0x00, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x09, 0x00, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC1, 0x08, 0x00, 0x10, 0x25, 0x08, 0x00, 0x10,
+0x25, 0x08, 0x00, 0x10, 0x39, 0x09, 0x00, 0x10, 0x41, 0x09, 0x00, 0x10, 0x25, 0x08, 0x00, 0x10,
+0xC5, 0x07, 0x00, 0x10, 0x25, 0x08, 0x00, 0x10, 0x45, 0x09, 0x00, 0x10, 0x05, 0x09, 0x00, 0x10,
+0xB5, 0x07, 0x00, 0x10, 0xBD, 0x07, 0x00, 0x10, 0x25, 0x08, 0x00, 0x10, 0x00, 0xF0, 0x02, 0xF8,
+0x00, 0xF0, 0x42, 0xF8, 0x0C, 0xA0, 0x30, 0xC8, 0x08, 0x38, 0x24, 0x18, 0x2D, 0x18, 0xA2, 0x46,
+0x67, 0x1E, 0xAB, 0x46, 0x54, 0x46, 0x5D, 0x46, 0xAC, 0x42, 0x01, 0xD1, 0x00, 0xF0, 0x34, 0xF8,
+0x7E, 0x46, 0x0F, 0x3E, 0x0F, 0xCC, 0xB6, 0x46, 0x01, 0x26, 0x33, 0x42, 0x00, 0xD0, 0xFB, 0x1A,
+0xA2, 0x46, 0xAB, 0x46, 0x33, 0x43, 0x18, 0x47, 0x38, 0x2D, 0x00, 0x00, 0x58, 0x2D, 0x00, 0x00,
+0x00, 0x23, 0x00, 0x24, 0x00, 0x25, 0x00, 0x26, 0x10, 0x3A, 0x01, 0xD3, 0x78, 0xC1, 0xFB, 0xD8,
+0x52, 0x07, 0x00, 0xD3, 0x30, 0xC1, 0x00, 0xD5, 0x0B, 0x60, 0x70, 0x47, 0x10, 0xB5, 0x64, 0x29,
+0x02, 0xD1, 0x00, 0xF0, 0x7F, 0xF8, 0x10, 0xBD, 0x78, 0x29, 0x02, 0xD1, 0x00, 0xF0, 0xB0, 0xF8,
+0x10, 0xBD, 0x73, 0x29, 0x02, 0xD1, 0x00, 0xF0, 0xEA, 0xFA, 0x10, 0xBD, 0x00, 0x20, 0x10, 0xBD,
+0x1F, 0xB5, 0x1F, 0xBD, 0x10, 0xB5, 0x10, 0xBD, 0x03, 0x48, 0x85, 0x46, 0xFF, 0xF7, 0xF8, 0xFF,
+0x01, 0xF0, 0x3C, 0xF9, 0x00, 0xF0, 0x20, 0xFB, 0x00, 0xC8, 0x00, 0x10, 0x03, 0xB4, 0xFF, 0xF7,
+0xF1, 0xFF, 0x03, 0xBC, 0x00, 0xF0, 0x21, 0xFC, 0x0F, 0xB4, 0x05, 0x49, 0x10, 0xB5, 0x03, 0xAA,
+0x02, 0x98, 0x00, 0xF0, 0xD1, 0xFA, 0x10, 0xBC, 0x08, 0xBC, 0x04, 0xB0, 0x18, 0x47, 0x00, 0x00,
+0x70, 0x90, 0x00, 0x00, 0x70, 0xB5, 0x04, 0x46, 0x85, 0x69, 0x00, 0x68, 0xC1, 0x06, 0x01, 0xD5,
+0x30, 0x26, 0x00, 0xE0, 0x20, 0x26, 0xC0, 0x07, 0x07, 0xD0, 0x70, 0xBD, 0x62, 0x68, 0x30, 0x46,
+0xA1, 0x68, 0x90, 0x47, 0x20, 0x6A, 0x40, 0x1C, 0x20, 0x62, 0x6D, 0x1E, 0xF6, 0xD5, 0x70, 0xBD,
+0x70, 0xB5, 0x04, 0x46, 0x85, 0x69, 0x00, 0x78, 0xC0, 0x07, 0x07, 0xD1, 0x70, 0xBD, 0x62, 0x68,
+0xA1, 0x68, 0x20, 0x20, 0x90, 0x47, 0x20, 0x6A, 0x40, 0x1C, 0x20, 0x62, 0x6D, 0x1E, 0xF6, 0xD5,
+0x70, 0xBD, 0x70, 0xB5, 0x0C, 0x46, 0x05, 0x46, 0x01, 0x2A, 0x05, 0xD0, 0x28, 0x78, 0x80, 0x06,
+0x00, 0xD5, 0xEA, 0x69, 0x00, 0x23, 0x02, 0xE0, 0x01, 0x23, 0x05, 0xE0, 0x5B, 0x1C, 0x93, 0x42,
+0x02, 0xD2, 0xE0, 0x5C, 0x00, 0x28, 0xF9, 0xD1, 0xA8, 0x69, 0xE6, 0x18, 0xC0, 0x1A, 0xA8, 0x61,
+0x28, 0x6A, 0xC0, 0x18, 0x28, 0x62, 0x28, 0x46, 0xFF, 0xF7, 0xBC, 0xFF, 0x04, 0xE0, 0x6A, 0x68,
+0x20, 0x78, 0xA9, 0x68, 0x64, 0x1C, 0x90, 0x47, 0xB4, 0x42, 0xF8, 0xD3, 0x28, 0x46, 0xFF, 0xF7,
+0xC7, 0xFF, 0x70, 0xBD, 0xF7, 0xB5, 0x00, 0x25, 0x75, 0x29, 0x10, 0x68, 0x00, 0x99, 0x14, 0xA6,
+0x11, 0xD0, 0xC0, 0x46, 0xC0, 0x46, 0x00, 0x28, 0x02, 0xDA, 0x40, 0x42, 0x11, 0xA6, 0x08, 0xE0,
+0x00, 0x99, 0x09, 0x68, 0x8A, 0x07, 0x01, 0xD5, 0x0F, 0xA6, 0x02, 0xE0, 0x49, 0x07, 0x04, 0xD5,
+0x0E, 0xA6, 0x01, 0x25, 0x01, 0xE0, 0xC0, 0x46, 0xC0, 0x46, 0x00, 0x9F, 0x00, 0x24, 0x24, 0x37,
+0x04, 0xE0, 0x00, 0xF0, 0x6D, 0xFA, 0x30, 0x31, 0x39, 0x55, 0x64, 0x1C, 0x00, 0x28, 0xF8, 0xD1,
+0x2B, 0x46, 0x32, 0x46, 0x21, 0x46, 0x00, 0x98, 0x00, 0xF0, 0xDE, 0xF9, 0xFE, 0xBD, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
+0x70, 0xB5, 0x04, 0x46, 0x0D, 0x46, 0x21, 0x46, 0x10, 0x68, 0xC0, 0x46, 0xC0, 0x46, 0x21, 0x88,
+0x09, 0x05, 0x02, 0xD5, 0x0F, 0x4A, 0x7A, 0x44, 0x02, 0xE0, 0x0E, 0x4A, 0x7A, 0x44, 0x0E, 0x32,
+0x23, 0x46, 0x00, 0x21, 0x24, 0x33, 0x05, 0xE0, 0x06, 0x07, 0x00, 0x09, 0x36, 0x0F, 0x96, 0x5D,
+0x5E, 0x54, 0x49, 0x1C, 0x00, 0x28, 0xF7, 0xD1, 0x20, 0x78, 0x00, 0x23, 0x00, 0x07, 0x05, 0xD5,
+0x70, 0x2D, 0x03, 0xD0, 0x00, 0x29, 0x01, 0xD0, 0x02, 0x23, 0x11, 0x32, 0x20, 0x46, 0x00, 0xF0,
+0xAB, 0xF9, 0x70, 0xBD, 0x6D, 0x28, 0x00, 0x00, 0xF3, 0xB5, 0x04, 0x46, 0x00, 0x20, 0x81, 0xB0,
+0x20, 0x62, 0x20, 0x46, 0xE1, 0x68, 0x88, 0x47, 0x00, 0x28, 0x7D, 0xD0, 0x25, 0x28, 0x02, 0xD0,
+0x62, 0x68, 0xA1, 0x68, 0x83, 0xE0, 0x45, 0x4F, 0x00, 0x25, 0x7F, 0x44, 0x20, 0x46, 0xE1, 0x68,
+0x88, 0x47, 0x20, 0x28, 0x06, 0x46, 0x08, 0xDB, 0x31, 0x2E, 0x06, 0xD2, 0xB8, 0x19, 0x20, 0x38,
+0x00, 0x78, 0x00, 0x28, 0x01, 0xD0, 0x05, 0x43, 0xF0, 0xE7, 0xA8, 0x07, 0x01, 0xD5, 0x04, 0x20,
+0x85, 0x43, 0x00, 0x20, 0xE0, 0x61, 0x07, 0x46, 0xA0, 0x61, 0x2A, 0x2E, 0x0A, 0xD0, 0x30, 0x46,
+0x00, 0xF0, 0x2C, 0xFB, 0x00, 0x28, 0x27, 0xD0, 0xB8, 0x00, 0x00, 0x19, 0x30, 0x3E, 0x00, 0x90,
+0x86, 0x61, 0x19, 0xE0, 0x02, 0x98, 0xBA, 0x00, 0x12, 0x19, 0x02, 0xC8, 0x91, 0x61, 0x02, 0x90,
+0x20, 0x46, 0xE1, 0x68, 0x88, 0x47, 0x01, 0x2F, 0x06, 0x46, 0x17, 0xD1, 0xE0, 0x69, 0x00, 0x28,
+0x1F, 0xDA, 0x20, 0x20, 0x85, 0x43, 0x1C, 0xE0, 0x00, 0x98, 0x0A, 0x21, 0x80, 0x69, 0x48, 0x43,
+0x00, 0x99, 0x80, 0x19, 0x30, 0x38, 0x88, 0x61, 0x20, 0x46, 0xE1, 0x68, 0x88, 0x47, 0x06, 0x46,
+0x00, 0xF0, 0x04, 0xFB, 0x00, 0x28, 0xEF, 0xD1, 0x01, 0x2F, 0x0A, 0xD0, 0x2E, 0x2E, 0x08, 0xD1,
+0x20, 0x46, 0xE1, 0x68, 0x88, 0x47, 0x06, 0x46, 0x20, 0x20, 0x05, 0x43, 0x7F, 0x1C, 0x02, 0x2F,
+0xC3, 0xDB, 0xA0, 0x69, 0x00, 0x28, 0x03, 0xDA, 0x40, 0x42, 0xA0, 0x61, 0x01, 0x20, 0x05, 0x43,
+0xE8, 0x07, 0x01, 0xD0, 0x10, 0x20, 0x85, 0x43, 0x00, 0x2E, 0x24, 0xD0, 0x30, 0x46, 0x41, 0x38,
+0x19, 0x28, 0x03, 0xD8, 0x01, 0x20, 0xC0, 0x02, 0x05, 0x43, 0x20, 0x36, 0x20, 0x46, 0x25, 0x60,
+0x31, 0x46, 0x02, 0x9A, 0x15, 0x46, 0xFF, 0xF7, 0x99, 0xFE, 0x00, 0x28, 0x0C, 0xD0, 0x01, 0x28,
+0x07, 0xD0, 0xED, 0x1D, 0xE8, 0x08, 0x00, 0xE0, 0x0D, 0xE0, 0xC0, 0x00, 0x08, 0x30, 0x02, 0x90,
+0x77, 0xE7, 0x2D, 0x1D, 0x02, 0x95, 0x74, 0xE7, 0x62, 0x68, 0x30, 0x46, 0xA1, 0x68, 0x90, 0x47,
+0x20, 0x6A, 0x40, 0x1C, 0x6C, 0xE7, 0x20, 0x6A, 0xFE, 0xBD, 0x00, 0x00, 0x31, 0x28, 0x00, 0x00,
+0x03, 0x46, 0x70, 0xB5, 0x02, 0x46, 0x0B, 0x43, 0x9B, 0x07, 0x0F, 0xD1, 0x0E, 0x4C, 0xE6, 0x01,
+0x00, 0xE0, 0x08, 0xC2, 0x08, 0xC9, 0x1D, 0x1B, 0x9D, 0x43, 0x35, 0x42, 0xF9, 0xD0, 0xD9, 0xB2,
+0x11, 0x70, 0x52, 0x1C, 0x00, 0x29, 0x0D, 0xD0, 0x1B, 0x0A, 0xF8, 0xE7, 0x0B, 0x78, 0x49, 0x1C,
+0x13, 0x70, 0x52, 0x1C, 0x00, 0x2B, 0x05, 0xD0, 0x0B, 0x78, 0x49, 0x1C, 0x13, 0x70, 0x52, 0x1C,
+0x00, 0x2B, 0xF3, 0xD1, 0x70, 0xBD, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0xE0, 0x04, 0xC0,
+0x09, 0x1F, 0x04, 0x29, 0xFB, 0xD2, 0x8B, 0x07, 0x01, 0xD5, 0x02, 0x80, 0x80, 0x1C, 0xC9, 0x07,
+0x00, 0xD0, 0x02, 0x70, 0x70, 0x47, 0x00, 0x29, 0x0B, 0xD0, 0xC3, 0x07, 0x02, 0xD0, 0x02, 0x70,
+0x40, 0x1C, 0x49, 0x1E, 0x02, 0x29, 0x04, 0xD3, 0x83, 0x07, 0x02, 0xD5, 0x02, 0x80, 0x80, 0x1C,
+0x89, 0x1E, 0xE3, 0xE7, 0x00, 0x22, 0xEE, 0xE7, 0x00, 0x22, 0xDF, 0xE7, 0x03, 0x78, 0xC2, 0x78,
+0x19, 0x46, 0x43, 0x78, 0x12, 0x06, 0x1B, 0x02, 0x19, 0x43, 0x83, 0x78, 0xC0, 0x78, 0x1B, 0x04,
+0x19, 0x43, 0x11, 0x43, 0x09, 0x02, 0x09, 0x0A, 0x00, 0x06, 0x08, 0x43, 0x70, 0x47, 0x02, 0x0A,
+0x08, 0x70, 0x4A, 0x70, 0x02, 0x0C, 0x8A, 0x70, 0x02, 0x0E, 0xCA, 0x70, 0x70, 0x47, 0x00, 0x22,
+0x03, 0x09, 0x8B, 0x42, 0x2C, 0xD3, 0x03, 0x0A, 0x8B, 0x42, 0x11, 0xD3, 0x00, 0x23, 0x9C, 0x46,
+0x4E, 0xE0, 0x03, 0x46, 0x0B, 0x43, 0x3C, 0xD4, 0x00, 0x22, 0x43, 0x08, 0x8B, 0x42, 0x31, 0xD3,
+0x03, 0x09, 0x8B, 0x42, 0x1C, 0xD3, 0x03, 0x0A, 0x8B, 0x42, 0x01, 0xD3, 0x94, 0x46, 0x3F, 0xE0,
+0xC3, 0x09, 0x8B, 0x42, 0x01, 0xD3, 0xCB, 0x01, 0xC0, 0x1A, 0x52, 0x41, 0x83, 0x09, 0x8B, 0x42,
+0x01, 0xD3, 0x8B, 0x01, 0xC0, 0x1A, 0x52, 0x41, 0x43, 0x09, 0x8B, 0x42, 0x01, 0xD3, 0x4B, 0x01,
+0xC0, 0x1A, 0x52, 0x41, 0x03, 0x09, 0x8B, 0x42, 0x01, 0xD3, 0x0B, 0x01, 0xC0, 0x1A, 0x52, 0x41,
+0xC3, 0x08, 0x8B, 0x42, 0x01, 0xD3, 0xCB, 0x00, 0xC0, 0x1A, 0x52, 0x41, 0x83, 0x08, 0x8B, 0x42,
+0x01, 0xD3, 0x8B, 0x00, 0xC0, 0x1A, 0x52, 0x41, 0x43, 0x08, 0x8B, 0x42, 0x01, 0xD3, 0x4B, 0x00,
+0xC0, 0x1A, 0x52, 0x41, 0x41, 0x1A, 0x00, 0xD2, 0x01, 0x46, 0x52, 0x41, 0x10, 0x46, 0x70, 0x47,
+0x5D, 0xE0, 0xCA, 0x0F, 0x00, 0xD0, 0x49, 0x42, 0x03, 0x10, 0x00, 0xD3, 0x40, 0x42, 0x53, 0x40,
+0x00, 0x22, 0x9C, 0x46, 0x03, 0x09, 0x8B, 0x42, 0x2D, 0xD3, 0x03, 0x0A, 0x8B, 0x42, 0x12, 0xD3,
+0xFC, 0x22, 0x89, 0x01, 0x12, 0xBA, 0x03, 0x0A, 0x8B, 0x42, 0x0C, 0xD3, 0x89, 0x01, 0x92, 0x11,
+0x8B, 0x42, 0x08, 0xD3, 0x89, 0x01, 0x92, 0x11, 0x8B, 0x42, 0x04, 0xD3, 0x89, 0x01, 0x3A, 0xD0,
+0x92, 0x11, 0x00, 0xE0, 0x89, 0x09, 0xC3, 0x09, 0x8B, 0x42, 0x01, 0xD3, 0xCB, 0x01, 0xC0, 0x1A,
+0x52, 0x41, 0x83, 0x09, 0x8B, 0x42, 0x01, 0xD3, 0x8B, 0x01, 0xC0, 0x1A, 0x52, 0x41, 0x43, 0x09,
+0x8B, 0x42, 0x01, 0xD3, 0x4B, 0x01, 0xC0, 0x1A, 0x52, 0x41, 0x03, 0x09, 0x8B, 0x42, 0x01, 0xD3,
+0x0B, 0x01, 0xC0, 0x1A, 0x52, 0x41, 0xC3, 0x08, 0x8B, 0x42, 0x01, 0xD3, 0xCB, 0x00, 0xC0, 0x1A,
+0x52, 0x41, 0x83, 0x08, 0x8B, 0x42, 0x01, 0xD3, 0x8B, 0x00, 0xC0, 0x1A, 0x52, 0x41, 0xD9, 0xD2,
+0x43, 0x08, 0x8B, 0x42, 0x01, 0xD3, 0x4B, 0x00, 0xC0, 0x1A, 0x52, 0x41, 0x41, 0x1A, 0x00, 0xD2,
+0x01, 0x46, 0x63, 0x46, 0x52, 0x41, 0x5B, 0x10, 0x10, 0x46, 0x01, 0xD3, 0x40, 0x42, 0x00, 0x2B,
+0x00, 0xD5, 0x49, 0x42, 0x70, 0x47, 0x63, 0x46, 0x5B, 0x10, 0x00, 0xD3, 0x40, 0x42, 0x01, 0xB5,
+0x00, 0x20, 0xC0, 0x46, 0xC0, 0x46, 0x02, 0xBD, 0xFF, 0xB5, 0x04, 0x46, 0x0D, 0x46, 0x81, 0xB0,
+0x24, 0x30, 0x00, 0x90, 0x21, 0x68, 0x88, 0x06, 0x04, 0xD5, 0x10, 0x22, 0xE0, 0x69, 0x91, 0x43,
+0x21, 0x60, 0x00, 0xE0, 0x01, 0x20, 0xA8, 0x42, 0x01, 0xDD, 0x47, 0x1B, 0x00, 0xE0, 0x00, 0x27,
+0x04, 0x98, 0xA1, 0x69, 0x7A, 0x19, 0x10, 0x18, 0x08, 0x1A, 0xA0, 0x61, 0x20, 0x78, 0xC0, 0x06,
+0x02, 0xD4, 0x20, 0x46, 0xFF, 0xF7, 0x86, 0xFD, 0x00, 0x26, 0x08, 0xE0, 0x03, 0x98, 0x62, 0x68,
+0xA1, 0x68, 0x80, 0x5D, 0x90, 0x47, 0x20, 0x6A, 0x40, 0x1C, 0x76, 0x1C, 0x20, 0x62, 0x04, 0x98,
+0x86, 0x42, 0xF3, 0xDB, 0x20, 0x78, 0xC0, 0x06, 0x0A, 0xD5, 0x20, 0x46, 0xFF, 0xF7, 0x72, 0xFD,
+0x06, 0xE0, 0x62, 0x68, 0xA1, 0x68, 0x30, 0x20, 0x90, 0x47, 0x20, 0x6A, 0x40, 0x1C, 0x20, 0x62,
+0x38, 0x46, 0x7F, 0x1E, 0x00, 0x28, 0xF4, 0xDC, 0x07, 0xE0, 0x00, 0x98, 0x62, 0x68, 0xA1, 0x68,
+0x40, 0x5D, 0x90, 0x47, 0x20, 0x6A, 0x40, 0x1C, 0x20, 0x62, 0x28, 0x46, 0x6D, 0x1E, 0x00, 0x28,
+0xF3, 0xDC, 0x20, 0x46, 0xFF, 0xF7, 0x6C, 0xFD, 0x20, 0x78, 0x00, 0x06, 0x02, 0xD5, 0x02, 0x20,
+0x05, 0xB0, 0xF0, 0xBD, 0x01, 0x20, 0xFB, 0xE7, 0x10, 0xB5, 0x43, 0x69, 0x00, 0x2B, 0x02, 0xD0,
+0xC0, 0x46, 0xC0, 0x46, 0x01, 0xE0, 0xFF, 0xF7, 0x6C, 0xFD, 0x01, 0x20, 0x10, 0xBD, 0x12, 0x78,
+0x01, 0x46, 0x24, 0x31, 0x0A, 0x70, 0x00, 0x22, 0x4A, 0x70, 0x01, 0x22, 0xEC, 0xE7, 0x11, 0x68,
+0x00, 0x22, 0xD2, 0x43, 0xE8, 0xE7, 0x00, 0x00, 0x08, 0x4B, 0x70, 0xB5, 0x0D, 0x46, 0x7B, 0x44,
+0x00, 0xF0, 0x27, 0xF8, 0x04, 0x46, 0x28, 0x46, 0x00, 0xF0, 0x08, 0xFC, 0x00, 0x28, 0x02, 0xD0,
+0x00, 0x20, 0xC0, 0x43, 0x70, 0xBD, 0x20, 0x46, 0x70, 0xBD, 0x00, 0x00, 0x23, 0x08, 0x00, 0x00,
+0x01, 0x46, 0x80, 0x08, 0x08, 0x1A, 0x02, 0x09, 0x10, 0x18, 0x02, 0x0A, 0x10, 0x18, 0x02, 0x0C,
+0x10, 0x18, 0xC0, 0x08, 0x82, 0x00, 0x12, 0x18, 0x52, 0x00, 0x89, 0x1A, 0x01, 0xE0, 0x40, 0x1C,
+0x0A, 0x39, 0x0A, 0x29, 0xFB, 0xD2, 0x70, 0x47, 0x01, 0x69, 0x4A, 0x1C, 0x02, 0x61, 0x08, 0x78,
+0x70, 0x47, 0x00, 0xB5, 0x8F, 0xB0, 0x02, 0x91, 0x00, 0x21, 0x05, 0x91, 0x05, 0x49, 0x01, 0x93,
+0x79, 0x44, 0x03, 0x91, 0x11, 0x46, 0x04, 0x90, 0x68, 0x46, 0xFF, 0xF7, 0xAD, 0xFD, 0x0F, 0xB0,
+0x00, 0xBD, 0x00, 0x00, 0xE5, 0xFF, 0xFF, 0xFF, 0x04, 0x46, 0xC0, 0x46, 0xC0, 0x46, 0x20, 0x46,
+0xFF, 0xF7, 0xDC, 0xFC, 0x70, 0xB5, 0x8D, 0x18, 0x04, 0x78, 0x40, 0x1C, 0xA2, 0x07, 0x92, 0x0F,
+0x01, 0xD1, 0x02, 0x78, 0x40, 0x1C, 0x23, 0x11, 0x06, 0xD1, 0x03, 0x78, 0x40, 0x1C, 0x03, 0xE0,
+0x06, 0x78, 0x40, 0x1C, 0x0E, 0x70, 0x49, 0x1C, 0x52, 0x1E, 0xF9, 0xD1, 0x00, 0x2B, 0x15, 0xD0,
+0x02, 0x78, 0x0C, 0x26, 0x34, 0x40, 0x8A, 0x1A, 0x40, 0x1C, 0x0C, 0x2C, 0x03, 0xD0, 0xA4, 0x01,
+0x12, 0x1B, 0x9B, 0x1C, 0x08, 0xE0, 0x04, 0x78, 0x24, 0x02, 0x12, 0x1B, 0x40, 0x1C, 0xF8, 0xE7,
+0x14, 0x78, 0x0C, 0x70, 0x49, 0x1C, 0x52, 0x1C, 0x5B, 0x1E, 0xF9, 0xD5, 0xA9, 0x42, 0xD3, 0xD3,
+0x00, 0x20, 0x70, 0xBD, 0x10, 0xB5, 0x01, 0xF0, 0xC7, 0xFC, 0x10, 0xBD, 0x10, 0xB5, 0x01, 0xF0,
+0x5D, 0xFD, 0x10, 0xBD, 0x00, 0xBF, 0xFE, 0xE7, 0x00, 0x24, 0x0A, 0x25, 0x00, 0xBF, 0x0C, 0x49,
+0x0C, 0xA0, 0xFF, 0xF7, 0xA1, 0xFC, 0x00, 0xBF, 0x6C, 0x46, 0x00, 0xBF, 0x00, 0xBF, 0x04, 0xE0,
+0x21, 0x68, 0x0E, 0xA0, 0xFF, 0xF7, 0x98, 0xFC, 0x24, 0x1D, 0x28, 0x46, 0x69, 0x1E, 0xCD, 0xB2,
+0x00, 0x28, 0xF5, 0xD1, 0x08, 0xA0, 0xFF, 0xF7, 0x8F, 0xFC, 0x00, 0xBF, 0xFE, 0xE7, 0x00, 0x00,
+0x89, 0x29, 0x00, 0x10, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x20,
+0x45, 0x6E, 0x74, 0x65, 0x72, 0x2E, 0x2E, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x30, 0x78, 0x25, 0x30,
+0x38, 0x78, 0x20, 0x00, 0x00, 0xBF, 0xFE, 0xE7, 0x00, 0xBF, 0x03, 0x49, 0x03, 0xA0, 0xFF, 0xF7,
+0x73, 0xFC, 0x00, 0xBF, 0x00, 0xBF, 0xFE, 0xE7, 0x7C, 0x29, 0x00, 0x10, 0x5B, 0x65, 0x72, 0x72,
+0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x20, 0x45, 0x6E, 0x74, 0x65, 0x72, 0x2E, 0x2E, 0x2E,
+0x0A, 0x00, 0x00, 0x00, 0xC1, 0x06, 0xC9, 0x0E, 0x01, 0x22, 0x8A, 0x40, 0x41, 0x09, 0x8B, 0x00,
+0x01, 0x49, 0xCA, 0x50, 0x70, 0x47, 0x00, 0x00, 0x80, 0xE2, 0x00, 0xE0, 0xC1, 0x06, 0xC9, 0x0E,
+0x01, 0x22, 0x8A, 0x40, 0x41, 0x09, 0x8B, 0x00, 0x01, 0x49, 0xCA, 0x50, 0x70, 0x47, 0x00, 0x00,
+0x80, 0xE1, 0x00, 0xE0, 0xC2, 0x06, 0xD2, 0x0E, 0x01, 0x21, 0x91, 0x40, 0x42, 0x09, 0x93, 0x00,
+0x01, 0x4A, 0xD1, 0x50, 0x70, 0x47, 0x00, 0x00, 0x00, 0xE1, 0x00, 0xE0, 0x01, 0x46, 0x48, 0x09,
+0x82, 0x00, 0x06, 0x48, 0x80, 0x58, 0xCB, 0x06, 0xDB, 0x0E, 0x01, 0x22, 0x9A, 0x40, 0x10, 0x40,
+0x00, 0x28, 0x01, 0xD0, 0x01, 0x20, 0x70, 0x47, 0x00, 0x20, 0xFC, 0xE7, 0x00, 0xE2, 0x00, 0xE0,
+0x00, 0xBF, 0x03, 0x49, 0x03, 0xA0, 0xFF, 0xF7, 0x27, 0xFC, 0x00, 0xBF, 0x00, 0xBF, 0xFE, 0xE7,
+0xA7, 0x29, 0x00, 0x10, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x20,
+0x45, 0x6E, 0x74, 0x65, 0x72, 0x2E, 0x2E, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x10, 0xB5, 0x03, 0x48,
+0x03, 0x49, 0x08, 0x60, 0xFF, 0xF7, 0xBA, 0xFB, 0x00, 0x20, 0x10, 0xBD, 0x08, 0x00, 0x08, 0x00,
+0x00, 0x01, 0x08, 0x40, 0x10, 0xB5, 0x00, 0xF0, 0x73, 0xFF, 0x10, 0xBD, 0x00, 0xBF, 0x03, 0x49,
+0x03, 0xA0, 0xFF, 0xF7, 0x01, 0xFC, 0x00, 0xBF, 0x00, 0xBF, 0xFE, 0xE7, 0x9C, 0x29, 0x00, 0x10,
+0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x20, 0x45, 0x6E, 0x74, 0x65,
+0x72, 0x2E, 0x2E, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x10, 0xB5, 0x01, 0xF0, 0x21, 0xFC, 0x10, 0xBD,
+0x00, 0xBF, 0xFE, 0xE7, 0x10, 0xB5, 0x01, 0xF0, 0xB5, 0xFC, 0x10, 0xBD, 0x30, 0x38, 0x0A, 0x28,
+0x01, 0xD2, 0x01, 0x20, 0x70, 0x47, 0x00, 0x20, 0x70, 0x47, 0x00, 0xBF, 0xFE, 0xE7, 0x00, 0x00,
+0x70, 0xB5, 0x05, 0x46, 0x00, 0x24, 0x00, 0x2D, 0x04, 0xD0, 0x01, 0x2D, 0x17, 0xD0, 0x02, 0x2D,
+0x42, 0xD1, 0x2B, 0xE0, 0x29, 0x48, 0x40, 0x68, 0x00, 0x28, 0x0F, 0xD0, 0x27, 0x48, 0x40, 0x38,
+0x04, 0x6C, 0x40, 0x30, 0x40, 0x68, 0x40, 0x1E, 0x24, 0x49, 0x48, 0x60, 0x21, 0x68, 0x23, 0x48,
+0x40, 0x38, 0x01, 0x64, 0x00, 0x20, 0x20, 0x60, 0x01, 0x20, 0x20, 0x73, 0x33, 0xE0, 0x1F, 0x48,
+0x08, 0x30, 0x40, 0x68, 0x00, 0x28, 0x10, 0xD0, 0x1C, 0x48, 0x40, 0x38, 0x84, 0x6C, 0x48, 0x30,
+0x40, 0x68, 0x40, 0x1E, 0x19, 0x49, 0x08, 0x31, 0x48, 0x60, 0x21, 0x68, 0x17, 0x48, 0x40, 0x38,
+0x81, 0x64, 0x00, 0x20, 0x20, 0x60, 0x01, 0x20, 0x20, 0x73, 0x1C, 0xE0, 0x13, 0x48, 0x10, 0x30,
+0x40, 0x68, 0x00, 0x28, 0x0F, 0xD0, 0x11, 0x48, 0x40, 0x38, 0x04, 0x6D, 0x50, 0x30, 0x40, 0x68,
+0x40, 0x1E, 0x0E, 0x49, 0x10, 0x31, 0x48, 0x60, 0x20, 0x68, 0x50, 0x39, 0x08, 0x65, 0x00, 0x20,
+0x20, 0x60, 0x01, 0x20, 0x20, 0x73, 0x06, 0xE0, 0x00, 0xBF, 0x09, 0x49, 0x09, 0xA0, 0xFF, 0xF7,
+0x8B, 0xFB, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x2C, 0x05, 0xD1, 0x00, 0xBF, 0x29, 0x46,
+0x0E, 0xA0, 0xFF, 0xF7, 0x81, 0xFB, 0x00, 0xBF, 0x20, 0x46, 0x70, 0xBD, 0xF0, 0x9C, 0x00, 0x00,
+0x76, 0x2A, 0x00, 0x10, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x3A,
+0x20, 0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2C, 0x20, 0x69,
+0x67, 0x6E, 0x6F, 0x72, 0x65, 0x2E, 0x2E, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72,
+0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x20, 0x42, 0x75, 0x66, 0x66, 0x65,
+0x72, 0x20, 0x45, 0x72, 0x72, 0x6F, 0x72, 0x2C, 0x20, 0x54, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x25,
+0x64, 0x20, 0x0A, 0x00, 0x70, 0xB5, 0x00, 0x24, 0x10, 0x4D, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF,
+0x12, 0xE0, 0x00, 0xBF, 0x00, 0xBF, 0x28, 0x20, 0x60, 0x43, 0x40, 0x19, 0x00, 0x79, 0x00, 0x28,
+0x08, 0xD1, 0x01, 0x21, 0x28, 0x20, 0x60, 0x43, 0x40, 0x19, 0x01, 0x71, 0x28, 0x20, 0x60, 0x43,
+0x40, 0x19, 0x70, 0xBD, 0x60, 0x1C, 0xC4, 0xB2, 0x0C, 0x2C, 0xEA, 0xDB, 0x00, 0xBF, 0x04, 0xA0,
+0xFF, 0xF7, 0x32, 0xFB, 0x00, 0xBF, 0x00, 0x20, 0xF3, 0xE7, 0x00, 0x00, 0x44, 0x93, 0x00, 0x00,
+0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x5F, 0x74,
+0x78, 0x5F, 0x73, 0x65, 0x6E, 0x64, 0x5F, 0x6E, 0x6F, 0x64, 0x65, 0x2C, 0x20, 0x65, 0x72, 0x72,
+0x6F, 0x72, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x20,
+0x65, 0x6D, 0x70, 0x74, 0x79, 0x20, 0x6E, 0x6F, 0x64, 0x65, 0x0A, 0x00, 0xF0, 0xB5, 0xA7, 0xB0,
+0x39, 0x4F, 0x3E, 0x46, 0x08, 0x36, 0x00, 0x20, 0x23, 0x90, 0x70, 0x68, 0x02, 0x28, 0x02, 0xD2,
+0x78, 0x68, 0x08, 0x28, 0x65, 0xD3, 0x01, 0x20, 0x00, 0xF0, 0x08, 0xFC, 0x33, 0x48, 0x00, 0x6B,
+0xC0, 0x0F, 0xC0, 0x07, 0x00, 0x28, 0x53, 0xD1, 0x8C, 0x21, 0x68, 0x46, 0xFF, 0xF7, 0x94, 0xFC,
+0x00, 0x20, 0xC0, 0x43, 0x00, 0x90, 0x00, 0x20, 0x01, 0x90, 0x70, 0x68, 0x79, 0x68, 0x40, 0x18,
+0x10, 0x28, 0x06, 0xD3, 0x10, 0x20, 0x26, 0x90, 0x71, 0x68, 0x26, 0x98, 0x40, 0x1A, 0x25, 0x90,
+0x05, 0xE0, 0x70, 0x68, 0x79, 0x68, 0x40, 0x18, 0x26, 0x90, 0x78, 0x68, 0x25, 0x90, 0x26, 0x98,
+0x02, 0x90, 0x00, 0x24, 0x12, 0xE0, 0x02, 0x20, 0xFF, 0xF7, 0xFA, 0xFE, 0x05, 0x46, 0x68, 0x68,
+0x24, 0x90, 0xE2, 0x00, 0x03, 0xA9, 0x24, 0x98, 0x88, 0x50, 0xE2, 0x00, 0x03, 0xA8, 0x10, 0x18,
+0xA9, 0x68, 0x41, 0x60, 0x23, 0x98, 0x40, 0x1C, 0x23, 0x90, 0x64, 0x1C, 0x70, 0x68, 0xA0, 0x42,
+0xE9, 0xD8, 0x00, 0x24, 0x14, 0xE0, 0x01, 0x20, 0xFF, 0xF7, 0xE2, 0xFE, 0x05, 0x46, 0x68, 0x68,
+0x24, 0x90, 0x23, 0x98, 0xC2, 0x00, 0x03, 0xA8, 0x24, 0x99, 0x81, 0x50, 0xA9, 0x68, 0x23, 0x98,
+0xC2, 0x00, 0x03, 0xA8, 0x10, 0x18, 0x41, 0x60, 0x23, 0x98, 0x40, 0x1C, 0x23, 0x90, 0x64, 0x1C,
+0x25, 0x98, 0x84, 0x42, 0xE7, 0xD3, 0x8C, 0x21, 0x68, 0x46, 0x00, 0xF0, 0x27, 0xF8, 0x05, 0xE0,
+0x00, 0xBF, 0x07, 0x49, 0x07, 0xA0, 0xFF, 0xF7, 0x9F, 0xFA, 0x00, 0xBF, 0x00, 0x20, 0x00, 0xF0,
+0xA5, 0xFB, 0x27, 0xB0, 0xF0, 0xBD, 0x00, 0x00, 0xF8, 0x9C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x42,
+0x4A, 0x2A, 0x00, 0x10, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x3A,
+0x20, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x76, 0x61,
+0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x21, 0x0A, 0x00, 0x00, 0x00, 0x00, 0xF3, 0xB5, 0x81, 0xB0,
+0x06, 0x46, 0x11, 0x4D, 0x01, 0x20, 0x00, 0xF0, 0x81, 0xFB, 0x06, 0x20, 0x00, 0xF0, 0x48, 0xF8,
+0x00, 0xBF, 0x2C, 0x68, 0xE0, 0x0F, 0xC0, 0x07, 0x00, 0x28, 0xFA, 0xD1, 0x0B, 0x48, 0xC7, 0x6B,
+0x32, 0x46, 0x38, 0x46, 0x02, 0x99, 0x01, 0xF0, 0x8F, 0xFE, 0x09, 0x48, 0x28, 0x60, 0x00, 0xBF,
+0x2C, 0x68, 0xE0, 0x0F, 0xC0, 0x07, 0x00, 0x28, 0xFA, 0xD1, 0x06, 0x20, 0x01, 0xF0, 0xF0, 0xF9,
+0x00, 0x20, 0x00, 0xF0, 0x63, 0xFB, 0xFE, 0xBD, 0x30, 0x04, 0x00, 0x42, 0xC0, 0x0F, 0x00, 0xB7,
+0xAD, 0xDE, 0xFF, 0x7F, 0x70, 0xB5, 0x04, 0x46, 0x0D, 0x46, 0x00, 0x2C, 0x01, 0xDB, 0x1B, 0x2C,
+0x04, 0xDB, 0x06, 0xA1, 0x28, 0x46, 0xFF, 0xF7, 0xA3, 0xFB, 0x05, 0xE0, 0x60, 0x01, 0x08, 0x4A,
+0x81, 0x18, 0x28, 0x46, 0xFF, 0xF7, 0x9C, 0xFB, 0x70, 0xBD, 0x00, 0x00, 0x49, 0x4C, 0x4C, 0x45,
+0x47, 0x41, 0x4C, 0x5F, 0x45, 0x56, 0x45, 0x4E, 0x54, 0x5F, 0x49, 0x44, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x8D, 0x00, 0x00, 0x00, 0x21, 0x00, 0xE0, 0x49, 0x1C, 0x81, 0x42, 0xFC, 0xD3, 0x70, 0x47,
+0x10, 0xB5, 0x04, 0x46, 0x20, 0x46, 0xFF, 0xF7, 0xD1, 0xFD, 0x20, 0x46, 0xFF, 0xF7, 0xE6, 0xFD,
+0x20, 0x46, 0xFF, 0xF7, 0xBF, 0xFD, 0x10, 0xBD, 0xF8, 0xB5, 0x04, 0x46, 0x0D, 0x46, 0x00, 0x20,
+0x00, 0x90, 0x27, 0x46, 0x2A, 0x46, 0x21, 0x46, 0x0D, 0xA0, 0xFF, 0xF7, 0x15, 0xFA, 0x00, 0x26,
+0x10, 0xE0, 0x70, 0x07, 0x40, 0x0F, 0x00, 0x28, 0x06, 0xD1, 0x00, 0x98, 0x40, 0x1C, 0x00, 0x90,
+0x0E, 0xA0, 0x00, 0x99, 0xFF, 0xF7, 0x08, 0xFA, 0x39, 0x78, 0x0E, 0xA0, 0xFF, 0xF7, 0x04, 0xFA,
+0x7F, 0x1C, 0x76, 0x1C, 0xAE, 0x42, 0xEC, 0xD3, 0x0D, 0xA0, 0xFF, 0xF7, 0xFD, 0xF9, 0xF8, 0xBD,
+0x0A, 0x44, 0x55, 0x4D, 0x50, 0x20, 0x4D, 0x45, 0x4D, 0x4F, 0x52, 0x59, 0x20, 0x44, 0x41, 0x54,
+0x41, 0x3A, 0x30, 0x78, 0x25, 0x78, 0x2C, 0x20, 0x25, 0x64, 0x00, 0x00, 0x0A, 0x25, 0x33, 0x64,
+0x20, 0x20, 0x00, 0x00, 0x30, 0x78, 0x25, 0x30, 0x32, 0x78, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00,
+0x0A, 0x00, 0x00, 0x00, 0x10, 0xB5, 0x00, 0xBF, 0x13, 0xA0, 0xFF, 0xF7, 0xDD, 0xF9, 0x00, 0xBF,
+0x00, 0xBF, 0x1A, 0x48, 0x01, 0x68, 0x1A, 0xA0, 0xFF, 0xF7, 0xD6, 0xF9, 0x00, 0xBF, 0x00, 0xBF,
+0x16, 0x48, 0x41, 0x68, 0x20, 0xA0, 0xFF, 0xF7, 0xCF, 0xF9, 0x00, 0xBF, 0x00, 0xBF, 0x13, 0x48,
+0x81, 0x68, 0x27, 0xA0, 0xFF, 0xF7, 0xC8, 0xF9, 0x00, 0xBF, 0x00, 0xBF, 0x0F, 0x48, 0xC1, 0x68,
+0x2D, 0xA0, 0xFF, 0xF7, 0xC1, 0xF9, 0x00, 0xBF, 0x00, 0xBF, 0x0C, 0x48, 0x01, 0x69, 0x34, 0xA0,
+0xFF, 0xF7, 0xBA, 0xF9, 0x00, 0xBF, 0x10, 0xBD, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x64, 0x75, 0x6D, 0x70, 0x5F, 0x74, 0x78, 0x5F, 0x72, 0x78, 0x5F, 0x63, 0x6F, 0x75, 0x6E,
+0x74, 0x5F, 0x69, 0x6E, 0x66, 0x6F, 0x3A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x98, 0x90, 0x00, 0x00,
+0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x6D, 0x64,
+0x5F, 0x74, 0x78, 0x5F, 0x73, 0x65, 0x6E, 0x64, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+0x3D, 0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x6D, 0x64, 0x5F, 0x73, 0x65, 0x6E, 0x64, 0x20, 0x20, 0x20,
+0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3D, 0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00,
+0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x76, 0x65,
+0x6E, 0x74, 0x5F, 0x72, 0x65, 0x63, 0x76, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+0x3D, 0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x74, 0x5F, 0x72, 0x78, 0x5F, 0x72, 0x65,
+0x63, 0x76, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3D, 0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00,
+0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x76, 0x65,
+0x6E, 0x74, 0x5F, 0x74, 0x78, 0x5F, 0x64, 0x6F, 0x6E, 0x65, 0x5F, 0x72, 0x65, 0x63, 0x76, 0x20,
+0x3D, 0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x03, 0x48, 0x04, 0x49, 0x88, 0x60, 0x00, 0x11,
+0x48, 0x60, 0x03, 0x48, 0x08, 0x60, 0x70, 0x47, 0x30, 0x03, 0xF0, 0x0F, 0x00, 0x00, 0x08, 0x40,
+0x00, 0x30, 0x00, 0x70, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x28, 0x06, 0xD1, 0xFF, 0x21, 0x0A, 0x4A,
+0x11, 0x60, 0x51, 0x60, 0x12, 0x06, 0xD1, 0x63, 0x0C, 0xE0, 0x07, 0x49, 0x09, 0x68, 0x01, 0x43,
+0x05, 0x4A, 0x11, 0x60, 0x11, 0x46, 0x49, 0x68, 0x01, 0x43, 0x51, 0x60, 0x11, 0x06, 0xC9, 0x6B,
+0x12, 0x06, 0xD1, 0x63, 0x70, 0x47, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x01, 0x46, 0x00, 0x20,
+0xC0, 0x43, 0x70, 0x47, 0x70, 0xB5, 0x04, 0x46, 0x0E, 0x46, 0xE5, 0xB2, 0x0A, 0x2D, 0x02, 0xD1,
+0x0D, 0x20, 0x01, 0xF0, 0xA5, 0xF9, 0x28, 0x46, 0x01, 0xF0, 0xA2, 0xF9, 0x20, 0x46, 0x70, 0xBD,
+0x70, 0xB5, 0x05, 0x46, 0x0C, 0x46, 0x00, 0x26, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF,
+0x00, 0x2D, 0x04, 0xD0, 0x01, 0x2D, 0x10, 0xD0, 0x02, 0x2D, 0x2A, 0xD1, 0x1B, 0xE0, 0x1A, 0x48,
+0x00, 0x6C, 0x20, 0x60, 0x00, 0x20, 0x20, 0x73, 0x17, 0x48, 0x04, 0x64, 0x40, 0x30, 0x40, 0x68,
+0x40, 0x1C, 0x15, 0x49, 0x40, 0x31, 0x48, 0x60, 0x23, 0xE0, 0x13, 0x48, 0x80, 0x6C, 0x20, 0x60,
+0x00, 0x20, 0x20, 0x73, 0x10, 0x48, 0x84, 0x64, 0x48, 0x30, 0x40, 0x68, 0x40, 0x1C, 0x0E, 0x49,
+0x48, 0x31, 0x48, 0x60, 0x15, 0xE0, 0x0C, 0x48, 0x00, 0x6D, 0x20, 0x60, 0x00, 0x20, 0x20, 0x73,
+0x09, 0x48, 0x04, 0x65, 0x50, 0x30, 0x40, 0x68, 0x40, 0x1C, 0x07, 0x49, 0x50, 0x31, 0x48, 0x60,
+0x07, 0xE0, 0x00, 0xBF, 0x05, 0xA0, 0xFF, 0xF7, 0xC7, 0xF8, 0x00, 0xBF, 0x00, 0x26, 0xF6, 0x43,
+0x00, 0xBF, 0x00, 0xBF, 0x30, 0x46, 0x70, 0xBD, 0xB0, 0x9C, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72,
+0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x62, 0x75, 0x66,
+0x66, 0x65, 0x72, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2C, 0x20, 0x69, 0x67, 0x6E, 0x6F, 0x72, 0x65,
+0x2E, 0x2E, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xB5, 0x07, 0x46, 0x38, 0x46, 0x00, 0xF0,
+0xF5, 0xFF, 0xC5, 0xB2, 0xFF, 0x2D, 0x14, 0xD0, 0x28, 0x20, 0x68, 0x43, 0x09, 0x49, 0x46, 0x18,
+0x00, 0x24, 0x08, 0xE0, 0xA2, 0x00, 0x30, 0x46, 0x08, 0x30, 0x81, 0x58, 0x00, 0x20, 0xFF, 0xF7,
+0x8F, 0xFF, 0x60, 0x1C, 0xC4, 0xB2, 0x70, 0x79, 0xA0, 0x42, 0xF3, 0xDC, 0x28, 0x46, 0x00, 0xF0,
+0x0F, 0xF8, 0xF8, 0xBD, 0x44, 0x93, 0x00, 0x00, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x20, 0x03, 0x49,
+0x08, 0x60, 0x48, 0x60, 0x88, 0x60, 0x08, 0x73, 0x70, 0x47, 0x00, 0x00, 0x88, 0x90, 0x00, 0x00,
+0x10, 0xB5, 0x04, 0x46, 0x28, 0x21, 0x61, 0x43, 0x06, 0x4A, 0x88, 0x18, 0x28, 0x21, 0xFF, 0xF7,
+0x13, 0xFA, 0x04, 0x48, 0x00, 0x1F, 0x00, 0x68, 0x40, 0x1E, 0x02, 0x49, 0x09, 0x1F, 0x08, 0x60,
+0x10, 0xBD, 0x00, 0x00, 0x44, 0x93, 0x00, 0x00, 0x00, 0xBF, 0x00, 0xBF, 0x03, 0x48, 0x04, 0x49,
+0x08, 0x60, 0x00, 0x20, 0x48, 0x60, 0x88, 0x60, 0x08, 0x73, 0x70, 0x47, 0x00, 0x00, 0x01, 0xB0,
+0x88, 0x90, 0x00, 0x00, 0x10, 0xB5, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF, 0x15, 0x48, 0x40, 0x68,
+0x10, 0x21, 0x08, 0x40, 0x00, 0x28, 0xF9, 0xD1, 0x13, 0x49, 0x08, 0x70, 0x08, 0x20, 0x00, 0xF0,
+0xDF, 0xFF, 0x09, 0x20, 0x00, 0xF0, 0xDC, 0xFF, 0x06, 0x20, 0x00, 0xF0, 0xD9, 0xFF, 0x17, 0x20,
+0x00, 0x04, 0x0C, 0x49, 0xC8, 0x60, 0x01, 0x20, 0xC0, 0x02, 0x88, 0x60, 0xC0, 0x10, 0x0B, 0x49,
+0x08, 0x62, 0x08, 0x46, 0x00, 0x68, 0xFF, 0x21, 0x01, 0x31, 0x08, 0x40, 0x88, 0x42, 0x01, 0xD0,
+0x02, 0x20, 0x10, 0xBD, 0x00, 0xBF, 0x06, 0xA0, 0xFF, 0xF7, 0x2E, 0xF8, 0x00, 0xBF, 0x00, 0x20,
+0xF7, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x09, 0x40, 0x60, 0x90, 0x00, 0x00, 0x00, 0x8C, 0x04, 0x42,
+0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x6C, 0x6D, 0x61, 0x63, 0x20, 0x62, 0x6F,
+0x6F, 0x74, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6C, 0x6C, 0x79, 0x21,
+0x0A, 0x00, 0x00, 0x00, 0x70, 0xB5, 0x00, 0x24, 0x00, 0xBF, 0x00, 0xBF, 0xFF, 0xF7, 0xA4, 0xFF,
+0x00, 0xBF, 0x20, 0x49, 0x20, 0xA0, 0xFF, 0xF7, 0x07, 0xF8, 0x00, 0xBF, 0x02, 0x20, 0x28, 0x49,
+0x88, 0x60, 0x03, 0xE0, 0x7D, 0x20, 0xC0, 0x00, 0xFF, 0xF7, 0xCC, 0xFD, 0x25, 0x48, 0x00, 0x7B,
+0x00, 0x28, 0xF7, 0xD0, 0x23, 0x48, 0x05, 0x68, 0x84, 0x68, 0x00, 0xBF, 0x22, 0x46, 0x15, 0x49,
+0x21, 0xA0, 0xFE, 0xF7, 0xF1, 0xFF, 0x00, 0xBF, 0xA0, 0x07, 0x80, 0x0F, 0x00, 0x28, 0x06, 0xD0,
+0x00, 0xBF, 0x29, 0xA0, 0xFE, 0xF7, 0xE8, 0xFF, 0x00, 0xBF, 0x02, 0x20, 0x70, 0xBD, 0x01, 0x20,
+0x00, 0x04, 0x21, 0x21, 0x49, 0x06, 0x08, 0x63, 0x05, 0xE0, 0x28, 0x68, 0x21, 0x21, 0x49, 0x06,
+0x48, 0x63, 0x2D, 0x1D, 0x24, 0x1F, 0x00, 0x2C, 0xF7, 0xD1, 0x04, 0x20, 0x25, 0x49, 0xC8, 0x62,
+0xFF, 0xF7, 0x4A, 0xFF, 0x00, 0xBF, 0x24, 0xA0, 0xFE, 0xF7, 0xCE, 0xFF, 0x00, 0xBF, 0x00, 0x20,
+0xE4, 0xE7, 0x00, 0x00, 0xE5, 0x29, 0x00, 0x10, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x25, 0x73, 0x3A, 0x20, 0x77, 0x61, 0x69, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x72,
+0x20, 0x72, 0x6F, 0x6D, 0x20, 0x70, 0x61, 0x74, 0x63, 0x68, 0x2E, 0x2E, 0x2E, 0x0A, 0x00, 0x00,
+0x00, 0x01, 0x00, 0x40, 0x88, 0x90, 0x00, 0x00, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x25, 0x73, 0x3A, 0x20, 0x72, 0x6F, 0x6D, 0x20, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20, 0x72,
+0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x2E, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x5B,
+0x25, 0x64, 0x5D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A,
+0x20, 0x72, 0x6F, 0x6D, 0x20, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72,
+0x21, 0x0A, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x42, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x72, 0x6F, 0x6D, 0x20, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20,
+0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6C, 0x6C, 0x79, 0x21, 0x0A, 0x00, 0x00,
+0x10, 0xB5, 0x00, 0xBF, 0x00, 0xBF, 0xFF, 0xF7, 0x15, 0xFF, 0x00, 0x28, 0x07, 0xD0, 0x00, 0xBF,
+0x1B, 0x49, 0x1C, 0xA0, 0xFE, 0xF7, 0x68, 0xFF, 0x00, 0xBF, 0x02, 0x20, 0x10, 0xBD, 0xFF, 0xF7,
+0x51, 0xFF, 0x00, 0x28, 0x07, 0xD0, 0x00, 0xBF, 0x15, 0x49, 0x1E, 0xA0, 0xFE, 0xF7, 0x5C, 0xFF,
+0x00, 0xBF, 0x02, 0x20, 0xF2, 0xE7, 0x02, 0x20, 0x21, 0x21, 0x49, 0x06, 0x08, 0x60, 0x22, 0x48,
+0x22, 0x49, 0x08, 0x61, 0x22, 0x48, 0x48, 0x61, 0x22, 0x48, 0x88, 0x61, 0x00, 0x20, 0xC8, 0x61,
+0x21, 0x21, 0x49, 0x06, 0x08, 0x60, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF, 0x1E, 0x48, 0x00, 0x78,
+0x0A, 0x28, 0xFB, 0xD1, 0x1D, 0x48, 0xFF, 0xF7, 0x0D, 0xFD, 0x03, 0x20, 0x1C, 0x49, 0x88, 0x60,
+0x00, 0xBF, 0x03, 0x49, 0x1B, 0xA0, 0xFE, 0xF7, 0x37, 0xFF, 0x00, 0xBF, 0x00, 0x20, 0xCD, 0xE7,
+0xF4, 0x29, 0x00, 0x10, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x3A,
+0x20, 0x6C, 0x6D, 0x61, 0x63, 0x20, 0x62, 0x6F, 0x6F, 0x74, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x21,
+0x0A, 0x00, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x3A,
+0x20, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x72, 0x6F, 0x6D, 0x20, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20,
+0x66, 0x61, 0x69, 0x6C, 0x21, 0x0A, 0x00, 0x00, 0x00, 0x80, 0x1A, 0x3C, 0x40, 0x00, 0x00, 0x42,
+0x00, 0x00, 0x5A, 0x27, 0x08, 0x00, 0x40, 0x03, 0x60, 0x90, 0x00, 0x00, 0xA0, 0x86, 0x01, 0x00,
+0x00, 0x01, 0x00, 0x40, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x20,
+0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x2E, 0x2E, 0x2E, 0x0A, 0x00, 0x10, 0xB5, 0x12, 0x49,
+0x0A, 0x68, 0x13, 0x03, 0xDB, 0x0F, 0x83, 0x42, 0x1C, 0xD0, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x28,
+0x03, 0xD0, 0x01, 0x23, 0xDB, 0x04, 0x1A, 0x43, 0x04, 0xE0, 0x01, 0x24, 0xE4, 0x04, 0x13, 0x46,
+0xA3, 0x43, 0x1A, 0x46, 0x0A, 0x60, 0x00, 0x28, 0x0C, 0xD0, 0x04, 0xE0, 0x0B, 0x68, 0x01, 0x24,
+0xE4, 0x04, 0x23, 0x43, 0x0B, 0x60, 0x04, 0x4B, 0x0C, 0x3B, 0x5B, 0x68, 0xDB, 0x07, 0xDB, 0x0F,
+0x00, 0x2B, 0xF3, 0xD0, 0x10, 0xBD, 0x00, 0x00, 0x0C, 0x00, 0x09, 0x40, 0x00, 0x24, 0x30, 0x48,
+0x30, 0x49, 0xC8, 0x60, 0x64, 0x20, 0xFF, 0xF7, 0x95, 0xFC, 0x00, 0xF0, 0x37, 0xFF, 0x00, 0xBF,
+0x2D, 0x48, 0xFE, 0xF7, 0xC1, 0xFE, 0x00, 0xBF, 0x00, 0xBF, 0x2C, 0x48, 0xFE, 0xF7, 0xBC, 0xFE,
+0x00, 0xBF, 0x00, 0xBF, 0x2A, 0xA2, 0x2D, 0xA1, 0x30, 0xA0, 0xFE, 0xF7, 0xB5, 0xFE, 0x00, 0xBF,
+0x00, 0xBF, 0x25, 0x48, 0xFE, 0xF7, 0xB0, 0xFE, 0x00, 0xBF, 0x01, 0x20, 0x37, 0x49, 0x88, 0x60,
+0x00, 0xF0, 0xBC, 0xF9, 0xFF, 0xF7, 0x34, 0xFF, 0x01, 0xF0, 0xC2, 0xF9, 0x00, 0xF0, 0xEA, 0xFE,
+0x00, 0xF0, 0xF8, 0xF8, 0x00, 0xBF, 0x1C, 0x48, 0xFE, 0xF7, 0x9E, 0xFE, 0x00, 0xBF, 0x00, 0xBF,
+0x2F, 0x48, 0xFE, 0xF7, 0x99, 0xFE, 0x00, 0xBF, 0x00, 0xBF, 0x17, 0x48, 0xFE, 0xF7, 0x94, 0xFE,
+0x00, 0xBF, 0x23, 0xE0, 0x2B, 0x48, 0x00, 0x68, 0x00, 0x28, 0x0D, 0xDD, 0x07, 0x20, 0xFF, 0xF7,
+0x35, 0xFA, 0x06, 0x20, 0xFF, 0xF7, 0x32, 0xFA, 0x00, 0xF0, 0x2A, 0xFE, 0x07, 0x20, 0xFF, 0xF7,
+0x39, 0xFA, 0x06, 0x20, 0xFF, 0xF7, 0x36, 0xFA, 0x64, 0x1C, 0x23, 0x48, 0x84, 0x42, 0x07, 0xD1,
+0x00, 0x24, 0x00, 0xBF, 0x21, 0xA0, 0xFE, 0xF7, 0x77, 0xFE, 0x00, 0xBF, 0xFF, 0xF7, 0x92, 0xFC,
+0x25, 0x48, 0x00, 0x68, 0x01, 0x28, 0x01, 0xD1, 0xFF, 0xF7, 0x2E, 0xFD, 0xDA, 0xE7, 0x00, 0x00,
+0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x07, 0x40, 0xF0, 0x2B, 0x00, 0x10, 0x68, 0x2B, 0x00, 0x10,
+0x41, 0x75, 0x67, 0x20, 0x31, 0x30, 0x20, 0x32, 0x30, 0x31, 0x37, 0x00, 0x64, 0x65, 0x76, 0x65,
+0x6C, 0x6F, 0x70, 0x6D, 0x65, 0x6E, 0x74, 0x5F, 0x31, 0x2E, 0x33, 0x00, 0x5B, 0x20, 0x69, 0x6E,
+0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x3D, 0x3D, 0x3D, 0x3D, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F,
+0x6E, 0x20, 0x25, 0x73, 0x20, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x3A,
+0x20, 0x25, 0x73, 0x20, 0x3D, 0x3D, 0x3D, 0x3D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40,
+0xAC, 0x2B, 0x00, 0x10, 0x24, 0x95, 0x00, 0x00, 0xFF, 0xFF, 0x5F, 0x00, 0x5B, 0x20, 0x69, 0x6E,
+0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x6D, 0x30, 0x20, 0x69, 0x73, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69,
+0x6E, 0x67, 0x2E, 0x2E, 0x2E, 0x0A, 0x00, 0x00, 0x64, 0x90, 0x00, 0x00, 0x10, 0xB5, 0x03, 0x46,
+0x00, 0x20, 0x02, 0xE0, 0x1C, 0x5C, 0x14, 0x54, 0x40, 0x1C, 0x88, 0x42, 0xFA, 0xD3, 0x10, 0xBD,
+0xF8, 0xB5, 0x2A, 0x48, 0x40, 0x68, 0x01, 0x01, 0x28, 0x48, 0x0C, 0x30, 0x0D, 0x18, 0x0C, 0x38,
+0x00, 0x68, 0x40, 0x1E, 0x25, 0x49, 0x08, 0x60, 0x49, 0x68, 0x48, 0x1C, 0x26, 0x21, 0xFE, 0xF7,
+0xC6, 0xFF, 0x22, 0x48, 0x41, 0x60, 0x28, 0x68, 0x01, 0x28, 0x04, 0xD0, 0x02, 0x28, 0x24, 0xD0,
+0x03, 0x28, 0x2D, 0xD1, 0x16, 0xE0, 0x1E, 0x4C, 0xE8, 0x68, 0x21, 0x79, 0x88, 0x42, 0x09, 0xD1,
+0x21, 0x79, 0x48, 0x1C, 0x0C, 0x21, 0xFE, 0xF7, 0xBC, 0xFF, 0x21, 0x71, 0x20, 0x68, 0x40, 0x1E,
+0x20, 0x60, 0x06, 0xE0, 0x00, 0xBF, 0x22, 0x79, 0xE9, 0x68, 0x16, 0x48, 0xFE, 0xF7, 0xEC, 0xFD,
+0x00, 0xBF, 0x1B, 0xE0, 0xE8, 0x68, 0xC6, 0xB2, 0x30, 0x01, 0x11, 0x49, 0x58, 0x39, 0x47, 0x18,
+0x39, 0x46, 0x02, 0x20, 0xFF, 0xF7, 0xDC, 0xFC, 0x10, 0xE0, 0xE8, 0x68, 0x10, 0x38, 0xC6, 0xB2,
+0x31, 0x01, 0x0D, 0x48, 0x0F, 0x18, 0x39, 0x46, 0x01, 0x20, 0xFF, 0xF7, 0xD1, 0xFC, 0x05, 0xE0,
+0x00, 0xBF, 0x0A, 0xA0, 0xFE, 0xF7, 0xD0, 0xFD, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x20,
+0x28, 0x60, 0x68, 0x60, 0xA8, 0x60, 0xE8, 0x60, 0xF8, 0xBD, 0x00, 0x00, 0x24, 0x95, 0x00, 0x00,
+0x08, 0x9D, 0x00, 0x00, 0x34, 0x2C, 0x00, 0x10, 0xB0, 0x9A, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72,
+0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x5F, 0x72, 0x78, 0x5F, 0x6E,
+0x6F, 0x64, 0x65, 0x2C, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6D, 0x73, 0x67, 0x74, 0x79,
+0x70, 0x65, 0x0A, 0x00, 0x10, 0xB5, 0x00, 0xBF, 0x00, 0xBF, 0x9B, 0x21, 0x89, 0x00, 0x07, 0x48,
+0xFE, 0xF7, 0x42, 0xFF, 0x00, 0x20, 0x06, 0x49, 0x08, 0x60, 0x06, 0x49, 0x08, 0x60, 0x00, 0xBF,
+0x05, 0x49, 0x06, 0xA0, 0xFE, 0xF7, 0x98, 0xFD, 0x00, 0xBF, 0x10, 0xBD, 0x24, 0x95, 0x00, 0x00,
+0x68, 0x90, 0x00, 0x00, 0x6C, 0x90, 0x00, 0x00, 0x36, 0x2A, 0x00, 0x10, 0x5B, 0x20, 0x69, 0x6E,
+0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x20, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x2E,
+0x0A, 0x00, 0x00, 0x00, 0x70, 0xB5, 0xA4, 0xB0, 0x00, 0x24, 0x00, 0x25, 0x00, 0xBF, 0x00, 0xBF,
+0x00, 0xBF, 0x15, 0xE0, 0x20, 0x01, 0x42, 0x49, 0x40, 0x18, 0x40, 0x68, 0xA1, 0x00, 0x41, 0x4A,
+0x50, 0x50, 0x20, 0x01, 0x3E, 0x49, 0x40, 0x18, 0x81, 0x68, 0xA2, 0x00, 0x3D, 0x48, 0x90, 0x30,
+0x81, 0x50, 0x02, 0x20, 0x21, 0x01, 0x3A, 0x4A, 0x89, 0x18, 0x08, 0x73, 0x60, 0x1C, 0xC4, 0xB2,
+0x04, 0x2C, 0xE7, 0xDB, 0x00, 0x24, 0x17, 0xE0, 0x21, 0x01, 0x37, 0x48, 0x08, 0x18, 0x41, 0x68,
+0x20, 0x1D, 0x80, 0x00, 0x33, 0x4A, 0x11, 0x50, 0x21, 0x01, 0x33, 0x48, 0x08, 0x18, 0x81, 0x68,
+0x20, 0x1D, 0x82, 0x00, 0x2F, 0x48, 0x90, 0x30, 0x81, 0x50, 0x02, 0x21, 0x22, 0x01, 0x2E, 0x48,
+0x10, 0x18, 0x01, 0x73, 0x60, 0x1C, 0xC4, 0xB2, 0x20, 0x2C, 0xE5, 0xDB, 0x8C, 0x21, 0x01, 0xA8,
+0xFE, 0xF7, 0xE2, 0xFE, 0x00, 0x20, 0xC0, 0x43, 0x01, 0x90, 0x00, 0x20, 0x02, 0x90, 0x04, 0x20,
+0x03, 0x90, 0x00, 0x24, 0x0F, 0xE0, 0xA0, 0x00, 0x22, 0x49, 0x09, 0x58, 0xE2, 0x00, 0x04, 0xA8,
+0x81, 0x50, 0xA1, 0x00, 0x1F, 0x48, 0x90, 0x30, 0x41, 0x58, 0xE2, 0x00, 0x04, 0xA8, 0x10, 0x18,
+0x41, 0x60, 0x60, 0x1C, 0xC4, 0xB2, 0x04, 0x2C, 0xED, 0xDB, 0x02, 0x26, 0x00, 0x24, 0x2A, 0xE0,
+0x8C, 0x21, 0x01, 0xA8, 0xFE, 0xF7, 0xC0, 0xFE, 0x00, 0x20, 0xC0, 0x43, 0x01, 0x90, 0x00, 0x20,
+0x02, 0x90, 0x10, 0x20, 0x03, 0x90, 0x00, 0x25, 0x15, 0xE0, 0x20, 0x01, 0x00, 0x1D, 0x40, 0x19,
+0x80, 0x00, 0x10, 0x49, 0x09, 0x58, 0xEA, 0x00, 0x04, 0xA8, 0x81, 0x50, 0x20, 0x01, 0x00, 0x1D,
+0x40, 0x19, 0x81, 0x00, 0x0B, 0x48, 0x90, 0x30, 0x41, 0x58, 0xEA, 0x00, 0x04, 0xA8, 0x10, 0x18,
+0x41, 0x60, 0x68, 0x1C, 0xC5, 0xB2, 0x10, 0x2D, 0xE7, 0xDB, 0x8C, 0x21, 0x01, 0xA8, 0xFF, 0xF7,
+0x7D, 0xFA, 0x60, 0x1C, 0xC4, 0xB2, 0xB4, 0x42, 0xD2, 0xDB, 0x24, 0xB0, 0x70, 0xBD, 0x00, 0x00,
+0xB0, 0x9C, 0x00, 0x00, 0x90, 0x97, 0x00, 0x00, 0xB0, 0x9A, 0x00, 0x00, 0x10, 0xB5, 0x00, 0xBF,
+0x00, 0xBF, 0x00, 0x20, 0x19, 0x49, 0x08, 0x70, 0xFF, 0xF7, 0xB4, 0xFB, 0x07, 0x20, 0x00, 0xF0,
+0x77, 0xFC, 0x17, 0x48, 0x01, 0x21, 0x89, 0x07, 0xC8, 0x63, 0x08, 0x46, 0x00, 0x68, 0x02, 0x21,
+0x08, 0x43, 0x49, 0x07, 0x08, 0x60, 0x13, 0x48, 0x00, 0x68, 0x09, 0x13, 0x08, 0x43, 0x11, 0x49,
+0x08, 0x60, 0x08, 0x46, 0x40, 0x68, 0x09, 0x13, 0x08, 0x43, 0x0E, 0x49, 0x48, 0x60, 0x00, 0xBF,
+0x00, 0xBF, 0x01, 0x21, 0x0C, 0xA0, 0xFE, 0xF7, 0xC7, 0xFC, 0x00, 0xBF, 0x01, 0x20, 0x09, 0x49,
+0xC0, 0x31, 0x08, 0x60, 0x00, 0xBF, 0x00, 0x20, 0x48, 0x60, 0x00, 0xBF, 0x0D, 0x49, 0x0E, 0xA0,
+0xFE, 0xF7, 0xBA, 0xFC, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF, 0x10, 0xBD, 0x84, 0x90, 0x00, 0x00,
+0xFF, 0xFF, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x53, 0x45, 0x54, 0x5F, 0x53, 0x44, 0x49, 0x4F, 0x5F, 0x52, 0x57, 0x5F, 0x45, 0x4E, 0x20,
+0x25, 0x64, 0x0A, 0x00, 0xAD, 0x2A, 0x00, 0x10, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x25, 0x73, 0x20, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x2E, 0x0A, 0x00, 0x00, 0x00,
+0xFE, 0xB5, 0x00, 0x20, 0x01, 0x90, 0x06, 0x20, 0xFF, 0xF7, 0x38, 0xF8, 0x01, 0x20, 0x80, 0x07,
+0xC5, 0x6B, 0xE8, 0x07, 0xC0, 0x0F, 0x00, 0x28, 0x2B, 0xD0, 0x1E, 0x20, 0x01, 0x21, 0x89, 0x07,
+0x48, 0x61, 0x5E, 0x48, 0x00, 0x78, 0x01, 0x28, 0x10, 0xD1, 0x5D, 0x48, 0x00, 0x6A, 0x00, 0x04,
+0x00, 0x0E, 0x00, 0x90, 0x00, 0xF0, 0x2C, 0xF9, 0x01, 0x20, 0x80, 0x07, 0x00, 0x68, 0x01, 0x21,
+0x08, 0x43, 0x89, 0x07, 0x08, 0x60, 0x01, 0x20, 0xC8, 0x63, 0x0E, 0xE0, 0x53, 0x48, 0x00, 0x78,
+0x02, 0x28, 0x05, 0xD1, 0x00, 0xF0, 0xCC, 0xF8, 0x01, 0x20, 0x81, 0x07, 0xC8, 0x63, 0x04, 0xE0,
+0x00, 0xBF, 0x50, 0x48, 0xFE, 0xF7, 0x60, 0xFC, 0x00, 0xBF, 0x00, 0x20, 0x4B, 0x49, 0x08, 0x70,
+0x90, 0xE0, 0x28, 0x07, 0xC0, 0x0F, 0x00, 0x28, 0x33, 0xD0, 0x01, 0x20, 0x80, 0x07, 0x00, 0x68,
+0x40, 0x08, 0x40, 0x00, 0x01, 0x21, 0x89, 0x07, 0x08, 0x60, 0x08, 0x46, 0x84, 0x68, 0x20, 0x01,
+0xC0, 0x0F, 0x00, 0x28, 0x05, 0xD0, 0xE6, 0x05, 0xF6, 0x0D, 0x00, 0x27, 0x70, 0x02, 0x01, 0x90,
+0x03, 0xE0, 0x00, 0x26, 0xE7, 0x05, 0xFF, 0x0D, 0x01, 0x97, 0xA0, 0x01, 0xC0, 0x0B, 0x02, 0x90,
+0x3A, 0x48, 0x00, 0x78, 0x01, 0x28, 0x03, 0xD0, 0x38, 0x48, 0x00, 0x78, 0x00, 0x28, 0x0A, 0xD1,
+0x01, 0x20, 0x36, 0x49, 0x08, 0x70, 0x01, 0x99, 0x02, 0x98, 0x00, 0xF0, 0x53, 0xFA, 0x08, 0x20,
+0xC1, 0x06, 0xC8, 0x63, 0x5E, 0xE0, 0x00, 0xBF, 0x29, 0x46, 0x33, 0x48, 0xFE, 0xF7, 0x24, 0xFC,
+0x58, 0xE0, 0xE8, 0x06, 0xC0, 0x0F, 0x00, 0x28, 0x36, 0xD0, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x21,
+0x2E, 0xA0, 0xFE, 0xF7, 0x19, 0xFC, 0x00, 0xBF, 0x00, 0x20, 0x29, 0x49, 0x08, 0x60, 0x00, 0xBF,
+0x88, 0x05, 0x84, 0x68, 0x20, 0x01, 0xC0, 0x0F, 0x00, 0x28, 0x05, 0xD0, 0xE6, 0x05, 0xF6, 0x0D,
+0x00, 0x27, 0x70, 0x02, 0x01, 0x90, 0x03, 0xE0, 0x00, 0x26, 0xE7, 0x05, 0xFF, 0x0D, 0x01, 0x97,
+0xA0, 0x01, 0xC0, 0x0B, 0x02, 0x90, 0x1D, 0x48, 0x00, 0x78, 0x02, 0x28, 0x03, 0xD0, 0x1B, 0x48,
+0x00, 0x78, 0x00, 0x28, 0x0A, 0xD1, 0x02, 0x20, 0x18, 0x49, 0x08, 0x70, 0x01, 0x99, 0x02, 0x98,
+0x00, 0xF0, 0x8E, 0xF8, 0x10, 0x20, 0x81, 0x06, 0xC8, 0x63, 0x23, 0xE0, 0x00, 0xBF, 0x29, 0x46,
+0x1D, 0x48, 0xFE, 0xF7, 0xE9, 0xFB, 0x1D, 0xE0, 0xA8, 0x01, 0xC0, 0x0F, 0x00, 0x28, 0x0A, 0xD0,
+0x00, 0xBF, 0x1A, 0x49, 0x1A, 0xA0, 0xFE, 0xF7, 0xDF, 0xFB, 0x00, 0xBF, 0x01, 0x20, 0x40, 0x06,
+0x41, 0x01, 0xC8, 0x63, 0x0E, 0xE0, 0x68, 0x03, 0xC0, 0x0F, 0x00, 0x28, 0x07, 0xD0, 0x08, 0x49,
+0x40, 0x31, 0xC8, 0x68, 0xC8, 0x60, 0x09, 0x13, 0x0A, 0x03, 0xD1, 0x63, 0x02, 0xE0, 0x01, 0x20,
+0x80, 0x07, 0xC5, 0x63, 0x06, 0x20, 0xFE, 0xF7, 0x7D, 0xFF, 0xFE, 0xBD, 0x84, 0x90, 0x00, 0x00,
+0x00, 0x01, 0x00, 0x40, 0xDC, 0x2C, 0x00, 0x10, 0x88, 0x2D, 0x00, 0x10, 0x5B, 0x20, 0x69, 0x6E,
+0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x53, 0x45, 0x54, 0x5F, 0x53, 0x44, 0x49, 0x4F, 0x5F, 0x52, 0x57,
+0x5F, 0x45, 0x4E, 0x20, 0x25, 0x64, 0x0A, 0x00, 0x30, 0x2D, 0x00, 0x10, 0xBE, 0x2A, 0x00, 0x10,
+0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x70, 0x72, 0x6F,
+0x67, 0x72, 0x61, 0x6D, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2E, 0x2E, 0x2E, 0x0A, 0x00, 0x00,
+0x10, 0xB5, 0x10, 0x48, 0x40, 0x68, 0x01, 0x01, 0x0E, 0x48, 0x0C, 0x30, 0x0C, 0x18, 0x0E, 0x48,
+0x00, 0x68, 0x61, 0x68, 0x88, 0x42, 0x14, 0xD3, 0x00, 0x20, 0x0B, 0x49, 0x08, 0x60, 0xFF, 0xF7,
+0x6F, 0xFD, 0xFF, 0xF7, 0x7B, 0xF8, 0x00, 0x20, 0x08, 0x49, 0x08, 0x60, 0x00, 0xBF, 0x00, 0xBF,
+0x01, 0x21, 0x07, 0xA0, 0xFE, 0xF7, 0x80, 0xFB, 0x00, 0xBF, 0x01, 0x20, 0x0B, 0x49, 0x08, 0x60,
+0x00, 0xBF, 0x10, 0xBD, 0x24, 0x95, 0x00, 0x00, 0x68, 0x90, 0x00, 0x00, 0x6C, 0x90, 0x00, 0x00,
+0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x53, 0x45, 0x54, 0x5F, 0x53, 0x44, 0x49,
+0x4F, 0x5F, 0x52, 0x57, 0x5F, 0x45, 0x4E, 0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x01, 0x00, 0x40,
+0x09, 0x4A, 0x12, 0x68, 0x52, 0x18, 0x08, 0x4B, 0x1A, 0x60, 0x08, 0x4A, 0x52, 0x68, 0x13, 0x01,
+0x06, 0x4A, 0x0C, 0x32, 0x9A, 0x18, 0x92, 0x68, 0x12, 0x18, 0x01, 0x23, 0x9B, 0x07, 0x1A, 0x61,
+0x1F, 0x22, 0x5A, 0x61, 0x70, 0x47, 0x00, 0x00, 0x68, 0x90, 0x00, 0x00, 0x24, 0x95, 0x00, 0x00,
+0xFE, 0xB5, 0x00, 0x26, 0x00, 0x25, 0x7D, 0x48, 0x00, 0x6A, 0x00, 0x04, 0x00, 0x0E, 0x01, 0x90,
+0x01, 0x98, 0x80, 0x07, 0x80, 0x0F, 0x00, 0x90, 0x00, 0x98, 0x01, 0x28, 0x04, 0xD0, 0x02, 0x28,
+0x5F, 0xD0, 0x03, 0x28, 0x7D, 0xD1, 0xD6, 0xE0, 0x01, 0x98, 0x00, 0x06, 0x87, 0x0E, 0x00, 0xBF,
+0x39, 0x46, 0x73, 0xA0, 0xFE, 0xF7, 0x30, 0xFB, 0x00, 0xBF, 0x07, 0x2F, 0x2E, 0xD1, 0x75, 0x48,
+0x86, 0x68, 0x30, 0x46, 0x22, 0x30, 0xFE, 0xF7, 0xC9, 0xFC, 0x72, 0x49, 0x48, 0x70, 0x00, 0xBF,
+0x08, 0x46, 0x41, 0x78, 0x70, 0xA0, 0xFE, 0xF7, 0x1F, 0xFB, 0x00, 0xBF, 0x6D, 0x48, 0x40, 0x78,
+0x08, 0x28, 0x05, 0xDD, 0x00, 0xBF, 0x75, 0xA0, 0xFE, 0xF7, 0x16, 0xFB, 0x00, 0xBF, 0xC2, 0xE0,
+0x00, 0x24, 0x0E, 0xE0, 0xA2, 0x00, 0x31, 0x46, 0x26, 0x31, 0x50, 0x18, 0xFE, 0xF7, 0xAE, 0xFC,
+0x61, 0x1C, 0x8A, 0x00, 0x63, 0x49, 0x50, 0x31, 0x88, 0x50, 0x00, 0xBF, 0x00, 0xBF, 0x60, 0x1C,
+0xC4, 0xB2, 0x60, 0x48, 0x40, 0x78, 0xA0, 0x42, 0xEC, 0xDC, 0x21, 0xE0, 0x5D, 0x48, 0x40, 0x68,
+0x5C, 0x49, 0x09, 0x6D, 0x88, 0x42, 0x1B, 0xD3, 0x6D, 0x48, 0x6E, 0x49, 0x08, 0x63, 0x00, 0xBF,
+0x6C, 0x48, 0x00, 0x6B, 0x02, 0x90, 0x02, 0x98, 0xC0, 0x0F, 0xC0, 0x07, 0x00, 0x28, 0xF7, 0xD1,
+0xFF, 0xF7, 0xF4, 0xFB, 0x94, 0x21, 0x53, 0x48, 0xFE, 0xF7, 0x86, 0xFC, 0x00, 0xBF, 0x66, 0xA0,
+0xFE, 0xF7, 0xE2, 0xFA, 0x00, 0xBF, 0x69, 0x48, 0x40, 0x68, 0x40, 0x1C, 0x67, 0x49, 0x48, 0x60,
+0x89, 0xE0, 0x4C, 0x48, 0x80, 0x78, 0x4B, 0x49, 0x49, 0x78, 0x88, 0x42, 0x72, 0xD1, 0x49, 0x48,
+0x80, 0x78, 0x81, 0x00, 0x47, 0x48, 0x50, 0x30, 0x40, 0x58, 0x46, 0x49, 0x49, 0x68, 0x88, 0x42,
+0x68, 0xD8, 0x00, 0xBF, 0x00, 0xBF, 0x43, 0x48, 0x40, 0x78, 0x00, 0x28, 0x4F, 0xDD, 0x41, 0x48,
+0x86, 0x68, 0xFE, 0xF7, 0x6F, 0xFF, 0x05, 0x46, 0x00, 0x2D, 0x30, 0xD0, 0x30, 0x46, 0x1E, 0x30,
+0x00, 0xE0, 0x62, 0xE0, 0xFE, 0xF7, 0x5A, 0xFC, 0x28, 0x60, 0x00, 0xBF, 0x29, 0x68, 0x54, 0xA0,
+0xFE, 0xF7, 0xB2, 0xFA, 0x00, 0xBF, 0x28, 0x68, 0x0C, 0x28, 0x02, 0xD2, 0x28, 0x68, 0x00, 0x28,
+0x04, 0xD1, 0xFF, 0x21, 0xC6, 0x31, 0x30, 0x46, 0xFF, 0xF7, 0x86, 0xF8, 0x31, 0x48, 0x40, 0x78,
+0x68, 0x71, 0x00, 0x24, 0x09, 0xE0, 0xA1, 0x00, 0x2E, 0x48, 0x74, 0x30, 0x41, 0x58, 0xA2, 0x00,
+0x28, 0x46, 0x08, 0x30, 0x81, 0x50, 0x60, 0x1C, 0xC4, 0xB2, 0x2A, 0x48, 0x40, 0x78, 0xA0, 0x42,
+0xF1, 0xDC, 0x4A, 0x48, 0x00, 0x68, 0x40, 0x1C, 0x48, 0x49, 0x08, 0x60, 0x04, 0xE0, 0x00, 0xBF,
+0x47, 0x48, 0xFE, 0xF7, 0x89, 0xFA, 0x00, 0xBF, 0x00, 0x24, 0x0C, 0xE0, 0xA2, 0x00, 0x33, 0x46,
+0xC5, 0x33, 0xD1, 0x18, 0x62, 0x1C, 0x93, 0x00, 0x1E, 0x4A, 0x08, 0x32, 0xD0, 0x58, 0xFE, 0xF7,
+0x2E, 0xFC, 0x60, 0x1C, 0xC4, 0xB2, 0x1B, 0x48, 0x40, 0x78, 0xA0, 0x42, 0xEE, 0xDC, 0xFF, 0x21,
+0xC9, 0x31, 0x30, 0x46, 0xFE, 0xF7, 0xF2, 0xFF, 0x00, 0xBF, 0x3A, 0xA0, 0xFE, 0xF7, 0x6C, 0xFA,
+0x00, 0xBF, 0x2E, 0x48, 0x00, 0x68, 0x40, 0x1C, 0x2C, 0x49, 0x08, 0x60, 0x94, 0x21, 0x11, 0x48,
+0xFE, 0xF7, 0x02, 0xFC, 0x0F, 0xE0, 0x39, 0x48, 0x40, 0x68, 0x38, 0x49, 0x89, 0x68, 0x88, 0x42,
+0x02, 0xD1, 0x01, 0x20, 0x35, 0x49, 0x08, 0x73, 0x05, 0xE0, 0x00, 0xBF, 0x34, 0xA0, 0xFE, 0xF7,
+0x53, 0xFA, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x20, 0xFE, 0xBD, 0x00, 0x01, 0x00, 0x40,
+0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x63, 0x6D, 0x64, 0x69, 0x64, 0x3A, 0x25,
+0x64, 0x0A, 0x00, 0x00, 0xAC, 0x92, 0x00, 0x00, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x54, 0x58, 0x20, 0x4D, 0x53, 0x47, 0x3A, 0x20, 0x74, 0x78, 0x20, 0x70, 0x6B, 0x74, 0x20,
+0x63, 0x6E, 0x74, 0x3A, 0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72,
+0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x74, 0x78, 0x5F, 0x70, 0x6B, 0x74, 0x5F, 0x63, 0x6E, 0x74, 0x20,
+0x3E, 0x20, 0x4D, 0x41, 0x58, 0x5F, 0x41, 0x4D, 0x50, 0x44, 0x55, 0x5F, 0x50, 0x4B, 0x54, 0x00,
+0xAD, 0xDE, 0xFF, 0x7F, 0x00, 0x04, 0x00, 0x42, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x63, 0x6D, 0x64, 0x20, 0x73, 0x65, 0x6E, 0x64, 0x2E, 0x0A, 0x00, 0x98, 0x90, 0x00, 0x00,
+0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x74, 0x78, 0x20, 0x70, 0x6B, 0x74, 0x20,
+0x64, 0x65, 0x73, 0x63, 0x69, 0x64, 0x3A, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x40, 0x93, 0x00, 0x00,
+0x80, 0x2C, 0x00, 0x10, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x74, 0x78, 0x20,
+0x63, 0x6D, 0x64, 0x20, 0x73, 0x65, 0x6E, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x88, 0x90, 0x00, 0x00,
+0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x55, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E,
+0x20, 0x54, 0x58, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2C, 0x20, 0x69, 0x67, 0x6E, 0x6F, 0x72, 0x65,
+0x21, 0x0A, 0x00, 0x00, 0xF3, 0xB5, 0x87, 0xB0, 0x0C, 0x46, 0x00, 0x20, 0x05, 0x90, 0x00, 0x27,
+0x71, 0x48, 0x00, 0x6A, 0x00, 0x04, 0x05, 0x0E, 0x00, 0x26, 0x70, 0x48, 0x04, 0x90, 0x00, 0x20,
+0x03, 0x90, 0x02, 0x90, 0x01, 0x90, 0xA8, 0x07, 0x80, 0x0F, 0x06, 0x90, 0x07, 0x98, 0x00, 0x28,
+0x71, 0xD1, 0x06, 0x98, 0x01, 0x28, 0x04, 0xD0, 0x02, 0x28, 0x4B, 0xD0, 0x03, 0x28, 0x6B, 0xD1,
+0x71, 0xE0, 0x28, 0x06, 0x80, 0x0E, 0x05, 0x90, 0x05, 0x98, 0x00, 0x28, 0x05, 0xD1, 0x64, 0x48,
+0x64, 0x49, 0x08, 0x65, 0x00, 0xBF, 0x00, 0xBF, 0x04, 0xE0, 0x62, 0x48, 0x04, 0x65, 0x00, 0xBF,
+0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF, 0x05, 0x98, 0x07, 0x28, 0x0F, 0xD1, 0x01, 0x20, 0x5D, 0x49,
+0x08, 0x70, 0x00, 0x20, 0x88, 0x70, 0x08, 0x46, 0x44, 0x60, 0x04, 0x98, 0x88, 0x60, 0x01, 0x21,
+0x89, 0x07, 0x04, 0x98, 0x08, 0x61, 0x1F, 0x20, 0x48, 0x61, 0x22, 0xE0, 0x01, 0x20, 0xFF, 0xF7,
+0x9D, 0xFA, 0x55, 0x48, 0x00, 0x6B, 0x03, 0x90, 0x03, 0x98, 0xC0, 0x0F, 0xC0, 0x07, 0x00, 0x28,
+0x12, 0xD1, 0x52, 0x48, 0xC0, 0x6B, 0x02, 0x90, 0x01, 0x20, 0x4E, 0x49, 0x08, 0x70, 0x00, 0x20,
+0x88, 0x70, 0x08, 0x46, 0x44, 0x60, 0x02, 0x98, 0x88, 0x60, 0x01, 0x21, 0x89, 0x07, 0x02, 0x98,
+0x08, 0x61, 0x1F, 0x20, 0x48, 0x61, 0x04, 0xE0, 0x00, 0xBF, 0x49, 0xA0, 0xFE, 0xF7, 0x74, 0xF9,
+0x00, 0xBF, 0x45, 0xE0, 0x28, 0x07, 0x80, 0x0F, 0x03, 0x28, 0x02, 0xD1, 0x28, 0x06, 0x07, 0x0F,
+0x00, 0xE0, 0x01, 0x27, 0x00, 0x20, 0xFE, 0xF7, 0x8B, 0xFD, 0x06, 0x46, 0x00, 0x2E, 0x14, 0xD0,
+0x3C, 0x48, 0x87, 0x70, 0x44, 0x60, 0xBA, 0x00, 0x08, 0x30, 0xB1, 0x68, 0x81, 0x50, 0x78, 0x1E,
+0x81, 0x00, 0x38, 0x48, 0x74, 0x30, 0x46, 0x50, 0x01, 0x21, 0x89, 0x07, 0xB0, 0x68, 0x08, 0x61,
+0x1F, 0x20, 0x48, 0x61, 0x06, 0xE0, 0x24, 0xE0, 0x21, 0xE0, 0x00, 0xBF, 0x41, 0xA0, 0xFE, 0xF7,
+0x4B, 0xF9, 0x00, 0xBF, 0x1C, 0xE0, 0x4C, 0x48, 0x00, 0x68, 0x00, 0x28, 0x16, 0xD0, 0x4A, 0x48,
+0x80, 0x68, 0x00, 0x28, 0x04, 0xD1, 0x28, 0x48, 0x40, 0x6A, 0x80, 0xB2, 0x46, 0x49, 0x88, 0x60,
+0x45, 0x48, 0x00, 0x68, 0x01, 0x21, 0x89, 0x07, 0x08, 0x61, 0x43, 0x48, 0x44, 0x60, 0x00, 0x20,
+0x41, 0x49, 0x08, 0x73, 0x1F, 0x20, 0x01, 0x21, 0x89, 0x07, 0x48, 0x61, 0x00, 0xE0, 0x00, 0xBF,
+0x37, 0xE0, 0x06, 0x98, 0x01, 0x28, 0x04, 0xD0, 0x02, 0x28, 0x03, 0xD0, 0x03, 0x28, 0x2E, 0xD1,
+0x19, 0xE0, 0x00, 0xBF, 0x01, 0x20, 0xFF, 0xF7, 0x29, 0xFA, 0x1A, 0x48, 0x80, 0x78, 0x01, 0x90,
+0x01, 0x98, 0x81, 0x00, 0x17, 0x48, 0x08, 0x30, 0x40, 0x58, 0x16, 0x49, 0x49, 0x68, 0x40, 0x18,
+0x01, 0x21, 0x89, 0x07, 0x08, 0x61, 0x1F, 0x20, 0x48, 0x61, 0x12, 0x48, 0x40, 0x68, 0x00, 0x19,
+0x10, 0x49, 0x48, 0x60, 0x14, 0xE0, 0x2C, 0x48, 0x00, 0x68, 0x2B, 0x49, 0x49, 0x68, 0x40, 0x18,
+0x01, 0x21, 0x89, 0x07, 0x08, 0x61, 0x28, 0x48, 0x40, 0x68, 0x00, 0x19, 0x26, 0x49, 0x48, 0x60,
+0x00, 0x20, 0x08, 0x73, 0x1F, 0x20, 0x01, 0x21, 0x89, 0x07, 0x48, 0x61, 0x00, 0xE0, 0x00, 0xBF,
+0x00, 0xBF, 0x00, 0x20, 0x09, 0xB0, 0xF0, 0xBD, 0x00, 0x01, 0x00, 0x40, 0xAC, 0x90, 0x00, 0x00,
+0x22, 0x02, 0x00, 0x00, 0xAC, 0x92, 0x00, 0x00, 0x00, 0x04, 0x00, 0x42, 0xC0, 0x0F, 0x00, 0xB7,
+0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x73, 0x64, 0x69, 0x6F, 0x5F, 0x74, 0x78,
+0x5F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x2C, 0x20, 0x47, 0x52, 0x41, 0x4D, 0x20, 0x69,
+0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x76, 0x61, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x0A,
+0x00, 0x00, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x73, 0x64, 0x69,
+0x6F, 0x5F, 0x74, 0x78, 0x5F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x2C, 0x20, 0x61, 0x6C,
+0x6C, 0x6F, 0x63, 0x20, 0x74, 0x78, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x65, 0x72,
+0x72, 0x6F, 0x72, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x88, 0x90, 0x00, 0x00, 0x70, 0xB5, 0x05, 0x46,
+0x00, 0x24, 0x0E, 0x4E, 0x00, 0xBF, 0x10, 0xE0, 0x00, 0xBF, 0x00, 0xBF, 0x28, 0x20, 0x60, 0x43,
+0x80, 0x19, 0x00, 0x79, 0x01, 0x28, 0x06, 0xD1, 0x28, 0x20, 0x60, 0x43, 0x30, 0x58, 0xA8, 0x42,
+0x01, 0xD1, 0x20, 0x46, 0x70, 0xBD, 0x60, 0x1C, 0xC4, 0xB2, 0x0C, 0x2C, 0xEC, 0xDB, 0x00, 0xBF,
+0x03, 0xA0, 0xFE, 0xF7, 0x91, 0xF8, 0x00, 0xBF, 0xFF, 0x20, 0xF3, 0xE7, 0x44, 0x93, 0x00, 0x00,
+0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x5F,
+0x74, 0x78, 0x5F, 0x73, 0x65, 0x6E, 0x64, 0x5F, 0x6E, 0x6F, 0x64, 0x65, 0x2C, 0x20, 0x65, 0x72,
+0x72, 0x6F, 0x72, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F,
+0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x20, 0x6E, 0x6F, 0x64, 0x65, 0x0A, 0x00, 0x00,
+0x10, 0xB5, 0x04, 0x46, 0x20, 0x46, 0xFE, 0xF7, 0x11, 0xFC, 0x20, 0x46, 0xFE, 0xF7, 0x26, 0xFC,
+0x20, 0x46, 0xFE, 0xF7, 0xFF, 0xFB, 0x62, 0xB6, 0x20, 0x46, 0xFE, 0xF7, 0x13, 0xFC, 0x10, 0xBD,
+0x10, 0xB5, 0x1D, 0x48, 0x40, 0x68, 0x01, 0x01, 0x1B, 0x48, 0x0C, 0x30, 0x0C, 0x18, 0x1B, 0x48,
+0x00, 0x68, 0x00, 0x28, 0x2E, 0xD1, 0x18, 0x48, 0x00, 0x68, 0x00, 0x28, 0x2A, 0xDD, 0x20, 0x68,
+0x00, 0x28, 0x07, 0xD1, 0x00, 0xBF, 0x14, 0x48, 0x01, 0x68, 0x15, 0xA0, 0xFE, 0xF7, 0x44, 0xF8,
+0x00, 0xBF, 0x10, 0xBD, 0x00, 0xBF, 0x61, 0x68, 0x1B, 0xA0, 0xFE, 0xF7, 0x3D, 0xF8, 0x00, 0xBF,
+0x60, 0x68, 0x01, 0x21, 0xC9, 0x02, 0x88, 0x42, 0x07, 0xD9, 0x00, 0xBF, 0x1E, 0xA0, 0xFE, 0xF7,
+0x33, 0xF8, 0x00, 0xBF, 0xFF, 0xF7, 0x14, 0xFA, 0xEB, 0xE7, 0x07, 0x48, 0x00, 0x68, 0x00, 0x28,
+0x08, 0xDD, 0x60, 0x68, 0x05, 0x49, 0x08, 0x60, 0x08, 0x46, 0x00, 0x68, 0x40, 0x04, 0x40, 0x0C,
+0x1C, 0x49, 0x48, 0x60, 0x00, 0xBF, 0xDC, 0xE7, 0x24, 0x95, 0x00, 0x00, 0x6C, 0x90, 0x00, 0x00,
+0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x75, 0x6E, 0x65, 0x78, 0x70, 0x65, 0x63,
+0x74, 0x65, 0x64, 0x20, 0x52, 0x58, 0x20, 0x64, 0x61, 0x74, 0x61, 0x21, 0x2C, 0x20, 0x63, 0x6E,
+0x74, 0x3D, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x73, 0x64, 0x69, 0x6F, 0x20, 0x72, 0x78, 0x20, 0x70, 0x6B, 0x74, 0x20, 0x6C, 0x65, 0x6E,
+0x3A, 0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A,
+0x20, 0x70, 0x74, 0x6B, 0x5F, 0x6C, 0x65, 0x6E, 0x20, 0x3E, 0x20, 0x32, 0x30, 0x34, 0x38, 0x0A,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0x10, 0xB5, 0x00, 0xBF, 0x04, 0x49, 0x05, 0xA0,
+0xFD, 0xF7, 0xE2, 0xFF, 0x00, 0xBF, 0x01, 0x20, 0x08, 0x49, 0x88, 0x60, 0x10, 0xBD, 0x00, 0x00,
+0x06, 0x2A, 0x00, 0x10, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x20,
+0x45, 0x6E, 0x74, 0x65, 0x72, 0x2E, 0x2E, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x40, 0x01, 0x08, 0x40,
+0x00, 0xBF, 0x00, 0xBF, 0x01, 0x20, 0x05, 0x49, 0x88, 0x61, 0x08, 0x46, 0x00, 0x69, 0x40, 0x08,
+0x40, 0x00, 0x08, 0x61, 0x00, 0x20, 0x02, 0x49, 0x08, 0x70, 0x70, 0x47, 0x00, 0x00, 0x04, 0x40,
+0x85, 0x90, 0x00, 0x00, 0x10, 0xB5, 0x00, 0xBF, 0x00, 0xBF, 0x94, 0x21, 0x09, 0x48, 0xFE, 0xF7,
+0x53, 0xF9, 0xFF, 0x21, 0xE5, 0x31, 0x08, 0x48, 0xFE, 0xF7, 0x4E, 0xF9, 0x14, 0x21, 0x07, 0x48,
+0xFE, 0xF7, 0x4A, 0xF9, 0x00, 0xBF, 0x06, 0x49, 0x06, 0xA0, 0xFD, 0xF7, 0xA5, 0xFF, 0x00, 0xBF,
+0x10, 0xBD, 0x00, 0x00, 0xAC, 0x92, 0x00, 0x00, 0x40, 0x93, 0x00, 0x00, 0x98, 0x90, 0x00, 0x00,
+0x1B, 0x2A, 0x00, 0x10, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x20,
+0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x07, 0x20, 0x13, 0x49,
+0x88, 0x60, 0x00, 0x20, 0x11, 0x49, 0x80, 0x39, 0x48, 0x60, 0x08, 0x61, 0x08, 0x46, 0xC0, 0x68,
+0x00, 0x09, 0x00, 0x01, 0xC0, 0x1C, 0xC8, 0x60, 0x08, 0x46, 0xC0, 0x68, 0x80, 0x21, 0x08, 0x43,
+0x0A, 0x49, 0x80, 0x39, 0xC8, 0x60, 0x01, 0x20, 0x08, 0x60, 0x00, 0x20, 0x48, 0x60, 0x08, 0x46,
+0xC0, 0x68, 0x80, 0x21, 0x88, 0x43, 0x05, 0x49, 0x80, 0x39, 0xC8, 0x60, 0x01, 0x20, 0x03, 0x49,
+0x88, 0x61, 0x03, 0x20, 0xC8, 0x61, 0x01, 0x20, 0x08, 0x62, 0x70, 0x47, 0x80, 0x00, 0x05, 0x40,
+0x08, 0x49, 0x03, 0xE0, 0x49, 0x1E, 0x00, 0x29, 0x00, 0xD1, 0x70, 0x47, 0x06, 0x4A, 0xD2, 0x6B,
+0x02, 0x23, 0x1A, 0x40, 0x00, 0x2A, 0xF5, 0xD0, 0x03, 0x4A, 0x40, 0x3A, 0x10, 0x60, 0x00, 0xBF,
+0xF3, 0xE7, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x40, 0x00, 0x05, 0x40, 0x10, 0xB5, 0x00, 0xBF,
+0x04, 0x49, 0x05, 0xA0, 0xFD, 0xF7, 0x48, 0xFF, 0x00, 0xBF, 0x02, 0x20, 0x08, 0x49, 0x88, 0x60,
+0x10, 0xBD, 0x00, 0x00, 0x10, 0x2A, 0x00, 0x10, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x25, 0x73, 0x20, 0x45, 0x6E, 0x74, 0x65, 0x72, 0x2E, 0x2E, 0x2E, 0x0A, 0x00, 0x00, 0x00,
+0x40, 0x01, 0x08, 0x40, 0xF0, 0xB5, 0x97, 0xB0, 0xC1, 0x48, 0x16, 0x90, 0x00, 0x1F, 0x15, 0x90,
+0x00, 0x26, 0x00, 0x20, 0x13, 0x90, 0x0B, 0x90, 0x07, 0x20, 0xFE, 0xF7, 0xCF, 0xFA, 0x15, 0x98,
+0x00, 0x68, 0x0A, 0x90, 0x0A, 0x98, 0xC0, 0x0F, 0xC0, 0x07, 0x00, 0x28, 0x0E, 0xD1, 0x00, 0xBF,
+0xB8, 0x49, 0xB9, 0xA0, 0xFD, 0xF7, 0x18, 0xFF, 0x00, 0xBF, 0x01, 0x21, 0xC9, 0x07, 0x16, 0x98,
+0x01, 0x60, 0x07, 0x20, 0xFE, 0xF7, 0xC6, 0xFA, 0x17, 0xB0, 0xF0, 0xBD, 0x0A, 0x98, 0x40, 0x00,
+0x40, 0x08, 0xBA, 0x49, 0x88, 0x42, 0x11, 0xD1, 0x00, 0xBF, 0xB9, 0x48, 0x40, 0x68, 0xC0, 0x07,
+0xC0, 0x0F, 0x00, 0x28, 0xF9, 0xD0, 0x04, 0x20, 0xB6, 0x49, 0x88, 0x60, 0x0A, 0x20, 0xB6, 0x49,
+0x08, 0x70, 0x00, 0xBF, 0xB5, 0xA0, 0xFD, 0xF7, 0xF7, 0xFE, 0x3D, 0xE1, 0xB9, 0x48, 0x86, 0x6B,
+0xC0, 0x6B, 0x14, 0x90, 0xB7, 0x48, 0x40, 0x30, 0x00, 0x68, 0x13, 0x90, 0x10, 0x96, 0x10, 0x9E,
+0x30, 0x68, 0x40, 0x1C, 0x00, 0x28, 0x6F, 0xD1, 0x0F, 0x96, 0x00, 0xBF, 0x0F, 0x98, 0x81, 0x68,
+0xB1, 0xA0, 0xFD, 0xF7, 0xE1, 0xFE, 0x00, 0xBF, 0xB7, 0x48, 0xC0, 0x68, 0x40, 0x1C, 0xB6, 0x49,
+0xC8, 0x60, 0x00, 0x20, 0x0B, 0x90, 0x70, 0xE0, 0xB4, 0x48, 0x00, 0x68, 0x26, 0x28, 0x05, 0xDB,
+0x00, 0xBF, 0xB3, 0xA0, 0xFD, 0xF7, 0xD0, 0xFE, 0x00, 0xBF, 0x6B, 0xE0, 0x0B, 0x98, 0x81, 0x00,
+0x0F, 0x98, 0x0C, 0x30, 0x40, 0x58, 0x09, 0x90, 0xAC, 0x48, 0x80, 0x68, 0x01, 0x01, 0xAB, 0x48,
+0x0C, 0x30, 0x0D, 0x18, 0x09, 0x98, 0x04, 0x28, 0x1A, 0xD2, 0x03, 0x20, 0x28, 0x60, 0x09, 0x98,
+0x81, 0x00, 0xB3, 0x48, 0x40, 0x58, 0xA8, 0x60, 0x09, 0x98, 0x80, 0x00, 0xB0, 0x49, 0x90, 0x39,
+0x08, 0x58, 0xE8, 0x60, 0xA8, 0x68, 0x0E, 0x90, 0x0E, 0x98, 0x14, 0x30, 0xFE, 0xF7, 0x4E, 0xF8,
+0x07, 0x46, 0x0E, 0x98, 0x1C, 0x30, 0xFE, 0xF7, 0x49, 0xF8, 0x38, 0x18, 0x68, 0x60, 0x2C, 0xE0,
+0x09, 0x98, 0x04, 0x28, 0x21, 0xD3, 0x09, 0x98, 0x30, 0x28, 0x1E, 0xD2, 0x02, 0x20, 0x28, 0x60,
+0x09, 0x98, 0x0C, 0x38, 0x11, 0x90, 0x11, 0x98, 0x81, 0x00, 0xA1, 0x48, 0x40, 0x58, 0xA8, 0x60,
+0x11, 0x98, 0x80, 0x00, 0x9E, 0x49, 0x90, 0x39, 0x08, 0x58, 0xE8, 0x60, 0xA8, 0x68, 0x0E, 0x90,
+0x0E, 0x98, 0x14, 0x30, 0xFE, 0xF7, 0x2A, 0xF8, 0x07, 0x46, 0x0E, 0x98, 0x1C, 0x30, 0xFE, 0xF7,
+0x25, 0xF8, 0x38, 0x18, 0x68, 0x60, 0x00, 0xBF, 0x07, 0xE0, 0x00, 0xBF, 0x95, 0xA0, 0x09, 0x99,
+0xFD, 0xF7, 0x7A, 0xFE, 0x00, 0xBF, 0x15, 0xE0, 0x15, 0xE0, 0x84, 0x49, 0x89, 0x68, 0x48, 0x1C,
+0x26, 0x21, 0xFE, 0xF7, 0x2C, 0xF8, 0x81, 0x48, 0x81, 0x60, 0x00, 0x68, 0x40, 0x1C, 0x7F, 0x49,
+0x08, 0x60, 0x0B, 0x98, 0x40, 0x1C, 0xC0, 0xB2, 0x0B, 0x90, 0x0F, 0x98, 0x81, 0x68, 0x0B, 0x98,
+0x81, 0x42, 0x89, 0xD8, 0xA5, 0xE0, 0x20, 0x21, 0x01, 0xA8, 0xFD, 0xF7, 0xFD, 0xFF, 0x0D, 0x96,
+0x0D, 0x98, 0x10, 0x30, 0xFD, 0xF7, 0xFA, 0xFF, 0x07, 0x46, 0x01, 0xA9, 0xFE, 0xF7, 0x02, 0xFC,
+0x00, 0xBF, 0x01, 0xA9, 0x89, 0xA0, 0xFD, 0xF7, 0x4F, 0xFE, 0x00, 0xBF, 0x6E, 0x48, 0x80, 0x68,
+0x40, 0x1C, 0x6D, 0x49, 0x88, 0x60, 0x0D, 0x98, 0x10, 0x30, 0xFD, 0xF7, 0xE7, 0xFF, 0x01, 0x28,
+0x1C, 0xD1, 0x69, 0x48, 0x00, 0x69, 0x40, 0x1C, 0x67, 0x49, 0x08, 0x61, 0x0C, 0x96, 0x0C, 0x98,
+0x4E, 0x30, 0xFD, 0xF7, 0xDB, 0xFF, 0x12, 0x90, 0x00, 0xBF, 0x83, 0xA0, 0x12, 0x99, 0xFD, 0xF7,
+0x33, 0xFE, 0x00, 0xBF, 0x12, 0x98, 0x0C, 0x28, 0x03, 0xD2, 0x12, 0x98, 0xFE, 0xF7, 0x84, 0xFD,
+0x0E, 0xE0, 0x00, 0xBF, 0x85, 0xA0, 0xFD, 0xF7, 0x27, 0xFE, 0x09, 0xE0, 0x0D, 0x98, 0x10, 0x30,
+0xFD, 0xF7, 0xC4, 0xFF, 0x08, 0x28, 0x03, 0xD1, 0x00, 0xBF, 0x00, 0xBF, 0xFF, 0xF7, 0x9A, 0xF8,
+0x8D, 0x4C, 0x00, 0xBF, 0x00, 0xBF, 0x20, 0x68, 0x0C, 0x28, 0x51, 0xD2, 0x53, 0x48, 0x00, 0x68,
+0x26, 0x28, 0x4D, 0xDA, 0x51, 0x48, 0x80, 0x68, 0x11, 0x90, 0x00, 0xBF, 0x00, 0xBF, 0x01, 0x21,
+0x49, 0x02, 0x13, 0x98, 0x88, 0x42, 0x05, 0xD9, 0x00, 0xBF, 0x84, 0xA0, 0xFD, 0xF7, 0x04, 0xFE,
+0x00, 0xBF, 0xF1, 0xE6, 0x01, 0x21, 0x11, 0x98, 0x02, 0x01, 0x48, 0x48, 0x0C, 0x30, 0x81, 0x50,
+0x11, 0x99, 0x0A, 0x01, 0x45, 0x49, 0x0C, 0x31, 0x51, 0x18, 0x13, 0x98, 0x48, 0x60, 0x60, 0x79,
+0x81, 0x00, 0x20, 0x46, 0x08, 0x30, 0x41, 0x58, 0x11, 0x98, 0x02, 0x01, 0x3F, 0x48, 0x0C, 0x30,
+0x10, 0x18, 0x81, 0x60, 0x61, 0x79, 0x11, 0x98, 0x02, 0x01, 0x3C, 0x48, 0x0C, 0x30, 0x10, 0x18,
+0xC1, 0x60, 0x3A, 0x49, 0x89, 0x68, 0x48, 0x1C, 0x26, 0x21, 0xFD, 0xF7, 0x98, 0xFF, 0x37, 0x48,
+0x81, 0x60, 0x00, 0x68, 0x40, 0x1C, 0x35, 0x49, 0x08, 0x60, 0x60, 0x79, 0x81, 0x00, 0x20, 0x46,
+0x08, 0x30, 0x42, 0x58, 0x30, 0x46, 0x13, 0x99, 0xFE, 0xF7, 0xA8, 0xFF, 0x20, 0x68, 0x40, 0x1C,
+0x20, 0x60, 0x61, 0x79, 0x48, 0x1C, 0x0C, 0x21, 0xFD, 0xF7, 0x8B, 0xFF, 0x61, 0x71, 0x07, 0xE0,
+0x00, 0xBF, 0x2A, 0x48, 0x02, 0x68, 0x21, 0x68, 0x6C, 0x48, 0xFD, 0xF7, 0xBD, 0xFD, 0x00, 0xBF,
+0x00, 0xBF, 0x00, 0x21, 0x14, 0x98, 0x01, 0x60, 0x01, 0x21, 0xC9, 0x07, 0x16, 0x98, 0x01, 0x60,
+0x07, 0x20, 0xFE, 0xF7, 0x67, 0xF9, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF, 0x9C, 0xE6, 0x00, 0x00,
+0x38, 0x04, 0x00, 0x42, 0xFD, 0x29, 0x00, 0x10, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A,
+0x20, 0x25, 0x73, 0x3A, 0x20, 0x75, 0x6E, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20,
+0x77, 0x69, 0x66, 0x69, 0x20, 0x69, 0x73, 0x72, 0x21, 0x0A, 0x00, 0x00, 0xAD, 0xDB, 0xEA, 0x7D,
+0x00, 0x00, 0x09, 0x40, 0x40, 0x01, 0x08, 0x40, 0x60, 0x90, 0x00, 0x00, 0x5B, 0x20, 0x69, 0x6E,
+0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x72, 0x70, 0x75, 0x20, 0x72, 0x65, 0x61, 0x64, 0x79, 0x2E, 0x2E,
+0x2E, 0x0A, 0x00, 0x00, 0x00, 0x10, 0x00, 0xB7, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x72, 0x65, 0x63, 0x76, 0x20, 0x45, 0x56, 0x45, 0x4E, 0x54, 0x5F, 0x52, 0x58, 0x20, 0x70,
+0x6B, 0x74, 0x73, 0x3A, 0x25, 0x64, 0x0A, 0x00, 0x98, 0x90, 0x00, 0x00, 0x24, 0x95, 0x00, 0x00,
+0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x67, 0x5F, 0x72, 0x78, 0x5F, 0x72, 0x65,
+0x63, 0x76, 0x5F, 0x71, 0x2E, 0x63, 0x6E, 0x74, 0x20, 0x3E, 0x3D, 0x20, 0x4D, 0x41, 0x58, 0x5F,
+0x52, 0x58, 0x5F, 0x51, 0x55, 0x45, 0x55, 0x45, 0x5F, 0x53, 0x49, 0x5A, 0x45, 0x00, 0x00, 0x00,
+0x20, 0x98, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x74, 0x68, 0x65,
+0x20, 0x64, 0x65, 0x73, 0x63, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64,
+0x2C, 0x20, 0x64, 0x65, 0x73, 0x63, 0x3A, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x5B, 0x20, 0x69, 0x6E,
+0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x72, 0x65, 0x63, 0x76, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x74, 0x3A,
+0x20, 0x25, 0x73, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x74, 0x78, 0x5F, 0x64, 0x6F, 0x6E, 0x65, 0x2C, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+0x70, 0x74, 0x6F, 0x72, 0x5F, 0x69, 0x64, 0x3A, 0x25, 0x64, 0x0A, 0x00, 0x5B, 0x65, 0x72, 0x72,
+0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+0x74, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x78, 0x5F, 0x64, 0x6F, 0x6E, 0x65, 0x20, 0x65,
+0x76, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6F, 0x75, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x72,
+0x61, 0x6E, 0x67, 0x65, 0x0A, 0x00, 0x00, 0x00, 0x08, 0x9D, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72,
+0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x74, 0x5F, 0x6C, 0x65, 0x6E, 0x67, 0x74,
+0x68, 0x20, 0x3E, 0x20, 0x52, 0x58, 0x5F, 0x45, 0x56, 0x45, 0x4E, 0x54, 0x5F, 0x42, 0x55, 0x46,
+0x46, 0x45, 0x52, 0x5F, 0x4C, 0x45, 0x4E, 0x47, 0x54, 0x48, 0x0A, 0x00, 0x00, 0x2B, 0x00, 0x10,
+0x70, 0xB5, 0x00, 0x24, 0x78, 0x4D, 0x00, 0xBF, 0x00, 0xBF, 0x53, 0x21, 0xC9, 0x02, 0x77, 0x48,
+0xFD, 0xF7, 0x7A, 0xFE, 0x20, 0x20, 0x11, 0x21, 0x89, 0x01, 0x69, 0x18, 0x48, 0x60, 0x40, 0x01,
+0x28, 0x18, 0x05, 0x64, 0x00, 0xBF, 0x15, 0xE0, 0xE0, 0x02, 0x70, 0x49, 0x40, 0x18, 0x21, 0x01,
+0x49, 0x19, 0x88, 0x60, 0x00, 0x20, 0x21, 0x01, 0x49, 0x19, 0x08, 0x73, 0x1F, 0x2C, 0x05, 0xD0,
+0x60, 0x1C, 0x00, 0x01, 0x40, 0x19, 0x21, 0x01, 0x68, 0x50, 0x02, 0xE0, 0x00, 0x20, 0x21, 0x01,
+0x68, 0x50, 0x64, 0x1C, 0x20, 0x2C, 0xE7, 0xDB, 0x20, 0x20, 0x89, 0x21, 0xC9, 0x00, 0x69, 0x18,
+0x48, 0x60, 0xE8, 0x1D, 0xFF, 0x30, 0xFA, 0x30, 0x01, 0x21, 0x89, 0x02, 0x69, 0x18, 0x88, 0x64,
+0x00, 0x24, 0x29, 0xE0, 0xE0, 0x02, 0x5E, 0x49, 0x41, 0x18, 0x22, 0x01, 0xE8, 0x1D, 0xFF, 0x30,
+0xFA, 0x30, 0x10, 0x18, 0x81, 0x60, 0x00, 0x21, 0x22, 0x01, 0xE8, 0x1D, 0xFF, 0x30, 0xFA, 0x30,
+0x10, 0x18, 0x01, 0x73, 0x20, 0x46, 0x10, 0x30, 0x22, 0x01, 0xE9, 0x1D, 0xFF, 0x31, 0xFA, 0x31,
+0x51, 0x18, 0x48, 0x60, 0x1F, 0x2C, 0x08, 0xD0, 0x60, 0x1C, 0x01, 0x01, 0xE8, 0x1D, 0xFF, 0x30,
+0xFA, 0x30, 0x09, 0x18, 0x22, 0x01, 0x81, 0x50, 0x05, 0xE0, 0x00, 0x21, 0x22, 0x01, 0xE8, 0x1D,
+0xFF, 0x30, 0xFA, 0x30, 0x81, 0x50, 0x64, 0x1C, 0x20, 0x2C, 0xD3, 0xDB, 0x04, 0x20, 0x45, 0x21,
+0x09, 0x01, 0x69, 0x18, 0x48, 0x60, 0x00, 0x02, 0x28, 0x18, 0x01, 0x21, 0x89, 0x02, 0x69, 0x18,
+0x08, 0x65, 0x00, 0x24, 0x2A, 0xE0, 0x60, 0x03, 0x42, 0x49, 0x40, 0x18, 0x21, 0x01, 0x01, 0x22,
+0x92, 0x02, 0xAA, 0x18, 0x89, 0x18, 0x88, 0x60, 0x00, 0x21, 0x20, 0x01, 0x01, 0x22, 0x92, 0x02,
+0xAA, 0x18, 0x80, 0x18, 0x01, 0x73, 0x20, 0x01, 0x01, 0x21, 0x89, 0x02, 0x69, 0x18, 0x40, 0x18,
+0x44, 0x60, 0x03, 0x2C, 0x0B, 0xD0, 0x60, 0x1C, 0x00, 0x01, 0x01, 0x21, 0x89, 0x02, 0x69, 0x18,
+0x41, 0x18, 0x20, 0x01, 0x01, 0x22, 0x92, 0x02, 0xAA, 0x18, 0x11, 0x50, 0x05, 0xE0, 0x00, 0x20,
+0x21, 0x01, 0x01, 0x22, 0x92, 0x02, 0xAA, 0x18, 0x50, 0x50, 0x64, 0x1C, 0x04, 0x2C, 0xD2, 0xDB,
+0x00, 0x20, 0x01, 0x21, 0x89, 0x02, 0x69, 0x18, 0x88, 0x65, 0x8B, 0x21, 0xC9, 0x00, 0x69, 0x18,
+0x08, 0x71, 0x8B, 0x21, 0xC9, 0x00, 0x69, 0x18, 0x48, 0x71, 0x00, 0x24, 0x09, 0xE0, 0x60, 0x02,
+0x25, 0x49, 0x41, 0x18, 0xA2, 0x00, 0x8B, 0x20, 0xC0, 0x00, 0x28, 0x18, 0x08, 0x30, 0x81, 0x50,
+0x64, 0x1C, 0x0C, 0x2C, 0xF3, 0xDB, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x24, 0x02, 0xE0, 0x00, 0xBF,
+0x00, 0xBF, 0x64, 0x1C, 0x11, 0x20, 0x80, 0x01, 0x28, 0x18, 0x40, 0x68, 0xA0, 0x42, 0xF6, 0xD8,
+0x00, 0xBF, 0x00, 0xBF, 0x00, 0x24, 0x02, 0xE0, 0x00, 0xBF, 0x00, 0xBF, 0x64, 0x1C, 0x89, 0x20,
+0xC0, 0x00, 0x28, 0x18, 0x40, 0x68, 0xA0, 0x42, 0xF6, 0xD8, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x24,
+0x02, 0xE0, 0x00, 0xBF, 0x00, 0xBF, 0x64, 0x1C, 0x45, 0x20, 0x00, 0x01, 0x28, 0x18, 0x40, 0x68,
+0xA0, 0x42, 0xF6, 0xD8, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x24, 0x02, 0xE0, 0x00, 0xBF, 0x00, 0xBF,
+0x64, 0x1C, 0x0C, 0x2C, 0xFA, 0xDB, 0x00, 0xBF, 0x08, 0x49, 0x09, 0xA0, 0xFD, 0xF7, 0xF4, 0xFB,
+0x00, 0xBF, 0x00, 0x20, 0x70, 0xBD, 0x00, 0x00, 0xB0, 0x98, 0x00, 0x00, 0x00, 0xC8, 0x00, 0xB0,
+0x00, 0xC8, 0x01, 0xB0, 0x00, 0xC8, 0x02, 0xB0, 0x00, 0x48, 0x03, 0xB0, 0x68, 0x2A, 0x00, 0x10,
+0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x25, 0x73, 0x20, 0x53, 0x55, 0x43, 0x43,
+0x45, 0x53, 0x53, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x10, 0xB5, 0x03, 0x46, 0x00, 0x20, 0x02, 0xE0,
+0x14, 0x5C, 0x1C, 0x54, 0x40, 0x1C, 0x88, 0x42, 0xFA, 0xD3, 0x10, 0xBD, 0x4E, 0x4D, 0x49, 0x45,
+0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x48, 0x61, 0x72, 0x64, 0x46, 0x61, 0x75,
+0x6C, 0x74, 0x45, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x53, 0x56, 0x43, 0x48,
+0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x00, 0x50, 0x65, 0x6E, 0x64, 0x53, 0x56, 0x43, 0x00, 0x6C,
+0x6D, 0x61, 0x63, 0x5F, 0x62, 0x6F, 0x6F, 0x74, 0x00, 0x69, 0x6E, 0x69, 0x74, 0x5F, 0x72, 0x6F,
+0x6D, 0x5F, 0x70, 0x61, 0x74, 0x63, 0x68, 0x5F, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x00, 0x66,
+0x72, 0x65, 0x65, 0x5F, 0x72, 0x6F, 0x6D, 0x5F, 0x70, 0x61, 0x74, 0x63, 0x68, 0x5F, 0x62, 0x75,
+0x66, 0x66, 0x65, 0x72, 0x00, 0x6C, 0x6F, 0x61, 0x64, 0x5F, 0x72, 0x6F, 0x6D, 0x5F, 0x70, 0x61,
+0x74, 0x63, 0x68, 0x00, 0x6C, 0x70, 0x77, 0x5F, 0x69, 0x6E, 0x69, 0x74, 0x00, 0x77, 0x69, 0x66,
+0x69, 0x5F, 0x69, 0x73, 0x72, 0x00, 0x73, 0x6C, 0x65, 0x65, 0x70, 0x5F, 0x69, 0x73, 0x72, 0x00,
+0x77, 0x61, 0x6B, 0x65, 0x75, 0x70, 0x5F, 0x69, 0x73, 0x72, 0x00, 0x74, 0x78, 0x5F, 0x69, 0x6E,
+0x69, 0x74, 0x00, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x5F, 0x74, 0x78, 0x5F, 0x73, 0x65, 0x6E, 0x64,
+0x5F, 0x6E, 0x6F, 0x64, 0x65, 0x00, 0x72, 0x78, 0x5F, 0x69, 0x6E, 0x69, 0x74, 0x00, 0x72, 0x78,
+0x5F, 0x6D, 0x65, 0x6D, 0x5F, 0x69, 0x6E, 0x69, 0x74, 0x00, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x5F,
+0x61, 0x6E, 0x64, 0x5F, 0x72, 0x65, 0x66, 0x69, 0x6C, 0x6C, 0x5F, 0x6C, 0x70, 0x77, 0x5F, 0x72,
+0x78, 0x5F, 0x71, 0x75, 0x65, 0x75, 0x65, 0x00, 0x77, 0x6C, 0x61, 0x6E, 0x5F, 0x6D, 0x65, 0x6D,
+0x5F, 0x69, 0x6E, 0x69, 0x74, 0x00, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x5F, 0x62, 0x75, 0x66, 0x5F,
+0x66, 0x72, 0x6F, 0x6D, 0x5F, 0x71, 0x75, 0x65, 0x75, 0x65, 0x00, 0x66, 0x72, 0x65, 0x65, 0x5F,
+0x62, 0x75, 0x66, 0x5F, 0x74, 0x6F, 0x5F, 0x71, 0x75, 0x65, 0x75, 0x65, 0x00, 0x65, 0x6E, 0x61,
+0x62, 0x6C, 0x65, 0x5F, 0x73, 0x64, 0x69, 0x6F, 0x5F, 0x69, 0x72, 0x71, 0x00, 0x73, 0x64, 0x69,
+0x6F, 0x5F, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5F, 0x69, 0x6E, 0x69, 0x74, 0x00, 0x73, 0x64,
+0x69, 0x6F, 0x5F, 0x69, 0x73, 0x72, 0x00, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
+0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x40, 0x30, 0x58, 0x00, 0x30, 0x31, 0x32, 0x33, 0x34,
+0x35, 0x36, 0x37, 0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x40, 0x30, 0x78, 0x00, 0x04,
+0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x10,
+0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x6C, 0x70, 0x77, 0x5F, 0x65, 0x76, 0x65,
+0x6E, 0x74, 0x5F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x2C, 0x20, 0x63, 0x6D, 0x64, 0x20,
+0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2C, 0x20, 0x6E, 0x6F,
+0x20, 0x66, 0x69, 0x66, 0x6F, 0x20, 0x6F, 0x72, 0x20, 0x72, 0x78, 0x5F, 0x71, 0x75, 0x65, 0x75,
+0x65, 0x20, 0x6E, 0x6F, 0x64, 0x65, 0x2C, 0x66, 0x69, 0x66, 0x6F, 0x20, 0x63, 0x6E, 0x74, 0x3A,
+0x25, 0x64, 0x2C, 0x20, 0x72, 0x78, 0x5F, 0x71, 0x75, 0x65, 0x75, 0x65, 0x20, 0x6E, 0x6F, 0x64,
+0x65, 0x3A, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A,
+0x20, 0x3D, 0x3D, 0x3D, 0x3D, 0x20, 0x52, 0x4B, 0x39, 0x31, 0x32, 0x20, 0x46, 0x69, 0x72, 0x6D,
+0x77, 0x61, 0x72, 0x65, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x28, 0x50,
+0x6F, 0x77, 0x65, 0x72, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x52, 0x6F, 0x63, 0x6B, 0x63, 0x68,
+0x69, 0x70, 0x29, 0x20, 0x3D, 0x3D, 0x3D, 0x3D, 0x0A, 0x00, 0x00, 0x00, 0x5B, 0x20, 0x69, 0x6E,
+0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x20,
+0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x52, 0x4B, 0x39, 0x31, 0x32, 0x20, 0x69,
+0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x79, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+0x20, 0x20, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x0A, 0x00, 0x00, 0x00,
+0x5B, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x5D, 0x3A, 0x20, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,
+0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,
+0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,
+0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,
+0x0A, 0x00, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x72, 0x65, 0x6D,
+0x6F, 0x76, 0x65, 0x5F, 0x72, 0x78, 0x5F, 0x6E, 0x6F, 0x64, 0x65, 0x2C, 0x20, 0x72, 0x78, 0x20,
+0x63, 0x6D, 0x64, 0x20, 0x66, 0x69, 0x66, 0x6F, 0x20, 0x69, 0x64, 0x78, 0x20, 0x65, 0x72, 0x72,
+0x6F, 0x72, 0x2C, 0x20, 0x6D, 0x73, 0x67, 0x20, 0x69, 0x64, 0x78, 0x3A, 0x25, 0x64, 0x2C, 0x20,
+0x66, 0x69, 0x66, 0x6F, 0x20, 0x66, 0x72, 0x6F, 0x6E, 0x74, 0x3A, 0x25, 0x64, 0x0A, 0x00, 0x00,
+0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x73, 0x64, 0x69, 0x6F, 0x5F, 0x74, 0x78,
+0x5F, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x5F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65,
+0x72, 0x2C, 0x20, 0x67, 0x5F, 0x74, 0x78, 0x5F, 0x73, 0x65, 0x6E, 0x64, 0x5F, 0x71, 0x20, 0x69,
+0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x76, 0x61, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20,
+0x62, 0x75, 0x74, 0x20, 0x66, 0x75, 0x6C, 0x6C, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20,
+0x6E, 0x6F, 0x74, 0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x0A, 0x00, 0x5B, 0x65, 0x72, 0x72,
+0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x3A, 0x20, 0x64, 0x65, 0x76, 0x69,
+0x63, 0x65, 0x20, 0x73, 0x64, 0x69, 0x6F, 0x20, 0x64, 0x6F, 0x6E, 0x65, 0x20, 0x69, 0x6E, 0x74,
+0x65, 0x72, 0x72, 0x75, 0x70, 0x74, 0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x73, 0x20, 0x77,
+0x68, 0x69, 0x6C, 0x65, 0x20, 0x74, 0x78, 0x2F, 0x72, 0x78, 0x20, 0x61, 0x6C, 0x72, 0x65, 0x61,
+0x64, 0x79, 0x20, 0x66, 0x69, 0x6E, 0x69, 0x73, 0x68, 0x65, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x00,
+0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x3A, 0x20,
+0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x73, 0x64, 0x69, 0x6F, 0x20, 0x72, 0x78, 0x20, 0x69,
+0x6E, 0x74, 0x65, 0x72, 0x72, 0x75, 0x70, 0x74, 0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x73,
+0x20, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x74, 0x78, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74,
+0x20, 0x66, 0x69, 0x6E, 0x69, 0x73, 0x68, 0x65, 0x64, 0x2C, 0x20, 0x69, 0x6E, 0x74, 0x72, 0x3A,
+0x30, 0x78, 0x25, 0x78, 0x0A, 0x00, 0x00, 0x00, 0x5B, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x5D, 0x3A,
+0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x3A, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x73,
+0x64, 0x69, 0x6F, 0x20, 0x74, 0x78, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x72, 0x75, 0x70, 0x74,
+0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x73, 0x20, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x72,
+0x78, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x69, 0x6E, 0x69, 0x73, 0x68, 0x65,
+0x64, 0x2C, 0x69, 0x6E, 0x74, 0x72, 0x3A, 0x30, 0x78, 0x25, 0x78, 0x0A, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x2E, 0x00, 0x10, 0x00, 0x88, 0x00, 0x00, 0x88, 0x08, 0x00, 0x00, 0x54, 0x07, 0x00, 0x10,
+0x24, 0x30, 0x00, 0x10, 0x88, 0x90, 0x00, 0x00, 0xB8, 0x0C, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x10,
+0x00, 0x0F, 0x10, 0x52, 0x50, 0x55, 0x5F, 0x43, 0x4D, 0x44, 0x5F, 0x52, 0x45, 0x53, 0x45, 0x54,
+0x00, 0x01, 0x61, 0x20, 0x00, 0x06, 0x1D, 0x53, 0x43, 0x41, 0x4E, 0x00, 0x20, 0x00, 0x07, 0x14,
+0x5F, 0x41, 0x42, 0x4F, 0x52, 0x54, 0x20, 0x00, 0x08, 0x18, 0x55, 0x4E, 0x55, 0x53, 0x45, 0x44,
+0x31, 0x40, 0x00, 0x06, 0x18, 0x45, 0x54, 0x4B, 0x45, 0x59, 0x60, 0x41, 0x40, 0x02, 0x1D, 0x32,
+0x20, 0x02, 0x17, 0x33, 0x40, 0x03, 0x12, 0x54, 0x58, 0xBE, 0xE1, 0x40, 0x02, 0x1D, 0x34, 0x20,
+0x02, 0x19, 0x35, 0x60, 0x00, 0x07, 0x1C, 0x5F, 0x50, 0x4F, 0x57, 0x45, 0x52, 0x40, 0x02, 0x1D,
+0x36, 0x60, 0x06, 0x17, 0x37, 0x80, 0x03, 0x1C, 0x50, 0x53, 0xC0, 0x00, 0x0C, 0x13, 0x50, 0x53,
+0x5F, 0x45, 0x43, 0x4F, 0x4E, 0x5F, 0x43, 0x46, 0x47, 0x60, 0x00, 0x09, 0x1C, 0x56, 0x49, 0x46,
+0x5F, 0x43, 0x54, 0x52, 0x4C, 0x80, 0x02, 0x1D, 0x38, 0xA0, 0x02, 0x17, 0x39, 0xA0, 0x17, 0x42,
+0x41, 0xC3, 0x10, 0x04, 0x53, 0x53, 0x49, 0x83, 0xF0, 0x05, 0x49, 0x4E, 0x46, 0x4F, 0xC0, 0xD0,
+0x0A, 0x4D, 0x43, 0x53, 0x54, 0x5F, 0x41, 0x44, 0x44, 0x52, 0xA2, 0xB1, 0x20, 0xD0, 0x05, 0x46,
+0x4C, 0x54, 0x52, 0xA6, 0xD9, 0x40, 0x0A, 0x16, 0x30, 0xA0, 0x00, 0x04, 0x1B, 0x52, 0x4F, 0x43,
+0xE0, 0x00, 0x08, 0x17, 0x43, 0x48, 0x41, 0x4E, 0x4E, 0x45, 0x4C, 0xE0, 0x35, 0x20, 0xD5, 0x3C,
+0x01, 0x11, 0x80, 0x0A, 0x18, 0x31, 0x00, 0x04, 0x09, 0x14, 0x51, 0x5F, 0x50, 0x41, 0x52, 0x41,
+0x4D, 0x53, 0xC0, 0x04, 0x0A, 0x16, 0x4D, 0x49, 0x42, 0x5F, 0x53, 0x54, 0x41, 0x54, 0x53, 0xE0,
+0x03, 0x1B, 0x48, 0x59, 0x20, 0x51, 0x80, 0x02, 0x1D, 0x32, 0xA0, 0x02, 0x1D, 0x33, 0x20, 0x02,
+0x1D, 0x34, 0x20, 0x02, 0x1D, 0x35, 0x20, 0x02, 0x1D, 0x36, 0x20, 0x02, 0x1D, 0x37, 0x20, 0x06,
+0x17, 0x38, 0xA0, 0x04, 0x05, 0x11, 0x4C, 0x45, 0x41, 0x52, 0x02, 0x71, 0x20, 0x0C, 0x04, 0x12,
+0x4F, 0x4E, 0x54, 0xC5, 0x03, 0x79, 0x00, 0x06, 0x13, 0x58, 0xFF, 0x89, 0x00, 0xCC, 0x0A, 0x46,
+0x47, 0x5F, 0x50, 0x57, 0x52, 0x4D, 0x47, 0x4D, 0xA1, 0x04, 0x10, 0x04, 0x45, 0x56, 0x54, 0x3C,
+0x02, 0x17, 0x00, 0x01, 0x21, 0x20, 0x1D, 0xDC, 0x03, 0x00, 0x05, 0x17, 0x44, 0x4F, 0x4E, 0x45,
+0x20, 0x10, 0x04, 0x44, 0x49, 0x53, 0x9F, 0x00, 0x07, 0x12, 0x4E, 0x45, 0x43, 0x54, 0x45, 0x44,
+0x40, 0x0D, 0x16, 0xFC, 0x04, 0xC1, 0x20, 0x02, 0x17, 0x32, 0x80, 0x3D, 0x5C, 0x05, 0x00, 0x09,
+0x16, 0x43, 0x4F, 0x4D, 0x50, 0x4C, 0x45, 0x54, 0x45, 0x20, 0x3D, 0x7C, 0x05, 0x01, 0x10, 0x26,
+0x81, 0x60, 0x02, 0x17, 0x33, 0x60, 0x3D, 0xFC, 0x05, 0x01, 0x15, 0x61, 0x81, 0x40, 0x02, 0x1D,
+0x34, 0xC0, 0x02, 0x1D, 0x35, 0x20, 0x02, 0x17, 0x36, 0x80, 0x6D, 0x1C, 0x03, 0x01, 0x16, 0xA0,
+0x6D, 0x1C, 0x03, 0x01, 0x16, 0x20, 0x00, 0x09, 0x17, 0x4E, 0x57, 0x5F, 0x46, 0x4F, 0x55, 0x4E,
+0x44, 0x20, 0x07, 0x1B, 0x4F, 0x41, 0xE0, 0x2D, 0x72, 0x04, 0x1D, 0xBE, 0x05, 0x00, 0x07, 0x12,
+0x4F, 0x4C, 0x5F, 0x41, 0x43, 0x4B, 0x20, 0x1C, 0x06, 0x4F, 0x4D, 0x4D, 0x41, 0x4E, 0x84, 0x05,
+0x2D, 0x65, 0x04, 0xD9, 0x0A, 0x31, 0x20, 0x22, 0x48, 0x1B, 0x0A, 0x13, 0x47, 0x25, 0x31, 0xC0,
+0x8D, 0x9C, 0x05, 0xF1, 0x24, 0xA1, 0x20, 0x00, 0x04, 0x13, 0x57, 0x41, 0x4B, 0x40, 0x0C, 0x04,
+0x13, 0x4D, 0x41, 0x43, 0x3C, 0x04, 0xC5, 0x60, 0x06, 0x1D, 0x37, 0x80, 0x06, 0x18, 0x38, 0x80,
+0x08, 0x05, 0x15, 0x53, 0x52, 0x4D, 0x4E, 0x01, 0x3D, 0x20, 0x03, 0x42, 0x4F, 0x80, 0x07, 0x14,
+0x55, 0x53, 0xC0, 0x00, 0x0A, 0x39, 0x46, 0x57, 0x5F, 0x45, 0x52, 0x52, 0x4F, 0x52, 0x00, 0x01,
+0x00, 0x00, 0x00, 0x00, };
+
+#endif //_FW_DATA_H_
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/hal_common.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/hal_common.h
new file mode 100755
index 000000000..5749c20ce
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/hal_common.h
@@ -0,0 +1,462 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _HAL_COMMON_H_
+#define _HAL_COMMON_H_
+#include "rpu.h"
+
+typedef int (*msg_handler)(void *nbuff);
+extern struct hal_priv *hpriv;
+extern char *mac_addr;
+extern const char *hal_name;
+struct device *hal_get_dev(void);
+extern bool waiting_for_rpu_ready;
+extern bool block_rpu_comm;
+
+enum PROBE_STATUS {
+	PROBE_INIT,
+	PROBE_TRIGGERED,
+	PROBE_CALLED,
+	PROBE_SUCCESS,
+	PROBE_FAILED
+};
+	
+enum RPU_SLEEP_TYPE {
+	RPU_SLEEP = 0,
+	RPU_AWAKE,
+};
+
+enum IO_TX_CMD_TYPE {
+	IO_TX_PKT_CMD = 1,
+	IO_TX_PKT_DATA,
+	IO_TX_PKT_PATCH,
+};
+
+enum IO_TX_PKT_TYPE {
+	IO_TX_PKT_MPDU = 1,
+	IO_TX_PKT_AMSDU,
+	IO_TX_PKT_AMPDU,
+};
+
+struct io_tx_ctrl_info {
+	unsigned char type;
+	unsigned char cmd_id;
+	unsigned char pkt_type;
+	unsigned char ampdu_seq;
+	unsigned int patch_len;
+};
+
+typedef struct {
+	void *parent;  /* some external entity that the thread supposed to work for */
+	char *proc_name;
+	struct task_struct *p_task;
+	long thr_pid;
+	int prio; /* priority */
+	struct semaphore sema;
+	int terminated;
+	struct completion completed;
+	spinlock_t spinlock;
+	int up_cnt;
+} tsk_ctl_t;
+
+#define TRUE 1
+#define FALSE 0
+
+#define PROC_START(thread_func, owner, tsk_ctl, flags, name) \
+{ \
+        sema_init(&((tsk_ctl)->sema), 0); \
+        init_completion(&((tsk_ctl)->completed)); \
+        (tsk_ctl)->parent = owner; \
+        (tsk_ctl)->proc_name = name;  \
+        (tsk_ctl)->terminated = FALSE; \
+        (tsk_ctl)->p_task  = kthread_run(thread_func, tsk_ctl, (char*)name); \
+        (tsk_ctl)->thr_pid = (tsk_ctl)->p_task->pid; \
+        spin_lock_init(&((tsk_ctl)->spinlock)); \
+}
+
+#define PROC_STOP(tsk_ctl) \
+{ \
+        (tsk_ctl)->terminated = TRUE; \
+        smp_wmb(); \
+        up(&((tsk_ctl)->sema)); \
+        wait_for_completion(&((tsk_ctl)->completed)); \
+        RPU_INFO_HAL("%s(): thread:%s:%lx terminated OK\n", __func__, \
+                         (tsk_ctl)->proc_name, (tsk_ctl)->thr_pid); \
+        (tsk_ctl)->thr_pid = -1; \
+}
+
+#define TXRX_DATA_LOCK
+#define TX_USE_THREAD
+
+typedef int (*fw_bring_up_func)(void *priv);
+typedef int (*fw_tear_down_func)(void *priv);
+
+extern enum PROBE_STATUS probe_status;
+struct hal_priv {
+        /* Pointer to the bus device for e.g. PCI dev, Platform dev etc */
+        void *bus_dev;
+	
+	/* RPU Host RAM mappings*/
+	void __iomem *base_addr_rpu_host_ram;
+	void __iomem *tx_base_addr_rpu_host_ram;
+	void __iomem *rx_base_addr_rpu_host_ram;
+
+	/* RPU and GRAM mappings */
+	unsigned long rpu_mem_addr;
+	unsigned long gram_mem_addr;
+	unsigned long rpu_sysbus_base_addr;
+	unsigned long rpu_perip_base_addr;
+	unsigned long gram_base_addr;
+	unsigned long shm_offset;
+	unsigned long hal_disabled;
+	unsigned long hal_init;
+	unsigned long gram_b4_addr;
+
+	/* DTS entries */
+	unsigned long rpu_sysbus_base;
+	unsigned long rpu_sysbus_len;
+	unsigned long rpu_pkd_gram_base;
+	unsigned long rpu_pkd_gram_len;
+	unsigned long rpu_gram_base;
+	unsigned long rpu_gram_len;
+
+	/* TX */
+	struct sk_buff_head txq;
+	//struct tasklet_struct tx_tasklet;
+#ifdef TX_USE_THREAD
+	tsk_ctl_t thr_tx_ctl;
+#else
+	struct work_struct tx_work;
+	struct workqueue_struct *tx_wkq;
+#endif
+	unsigned short cmd_cnt;
+	struct buf_info *tx_buf_info;
+	struct hal_tx_data *hal_tx_data;
+	int max_txq_len;
+
+	/* RX */
+	struct sk_buff_head rxq;
+	//struct tasklet_struct rx_tasklet;
+	//struct tasklet_struct recv_tasklet;
+	struct work_struct rx_work;
+	struct workqueue_struct *rx_wkq;
+	tsk_ctl_t thr_rx_ctl;
+	unsigned short event_cnt;
+	msg_handler rcv_handler;
+	struct buf_info *rx_buf_info;
+	unsigned char *rx_tmp_buf;
+	int max_rxq_len;
+
+	/* Buffers info from IF layer*/
+	unsigned int tx_bufs;
+	unsigned int rx_bufs_2k;
+	unsigned int rx_bufs_12k;
+	unsigned int max_data_size;
+
+	/* Temp storage to refill first and process next*/
+	struct sk_buff_head refillq;
+	int irq;
+	int irq_flags;
+	unsigned char *rf_params;
+	struct tasklet_struct rpu_ready_tasklet;
+
+	struct platform_device *plat_dev;
+
+	struct host_io_info *io_info;
+
+#ifdef TXRX_DATA_LOCK
+	struct mutex txrx_mutex;
+#endif
+	fw_bring_up_func fw_bring_up_func;
+	fw_tear_down_func fw_tear_down_func;
+
+	struct work_struct fw_err_work;
+	int fw_error;
+	int fw_error_counter;
+	int fw_error_counter_scan;
+	int fw_error_processing;
+	int fw_error_reason;
+	int lpw_error_counter;
+	int fw_error_cmd_done;
+	struct wake_lock fw_err_lock;
+	int during_fw_download;
+	int shutdown;
+
+	int during_pm_resume;
+	struct notifier_block pm_notifier;
+};
+
+#define HAL_HOST_ZONE_DMA_LEN (64 * 1024 * 1024)
+#define HAL_HOST_BOUNCE_BUF_LEN (4 * 1024 * 1024)
+#define HAL_HOST_NON_BOUNCE_BUF_LEN (60 * 1024 * 1024)
+
+/*Porting information:
+ * HAL_RPU_IRQ_LINE: This is the interrupt number assigned to RPU host port
+ *                    interrupt.
+ * HAL_HOST_RPU_RAM_START: This is the physical address of the start of
+ *                          Host RAM which is reserved for RPU
+ * HAL_HOST_ZONE_DMA_START: This is the physical address of the start of 64MB
+ *                          ZONE_DMA area which is currently assigned a dummy
+ *                          value of 0xABABABAB. TSB needs to provide the actual
+ *                          value for this.
+ *
+ * These are the only values which need to be modified as per host memory
+ * map and interrupt configuration.
+ * The values for HAL_SHARED_MEM_OFFSET, HAL_WLAN_GRAM_LEN,  HAL_COMMAND_OFFSET,
+ * and  HAL_EVENT_OFFSET can be changed by in future software releases.
+ */
+
+#define HAL_HOST_SYSBUS_BASE_OFF 0x00e00000
+#define HAL_HOST_PKD_GRAM_BASE_OFF 0x00c00000
+#define HAL_HOST_B4_GRAM_BASE_OFF 0x00000000
+
+#define HAL_HOST_RPU_LEN 0x0003E800
+#define HAL_RPU_GRAM_BASE 0xB7000000
+
+#ifdef RPU_SLEEP_ENABLE
+/* RPU Sleep Controller registers
+ */
+#define SLEEP_CONTROLLER_BASE_ADDR (hpriv->rpu_sysbus_base_addr + 0x02C00)
+#define UCC_SLEEP_CTRL_WAKEUP_TIME (SLEEP_CONTROLLER_BASE_ADDR + 0x14)
+#endif
+
+/* DDR_PHYS_WLN_BASE */
+#define HAL_HOST_RPU_RAM_START 0x02C00000
+
+#define HAL_HOST_RPU_RAM_LEN (4 * 1024 * 1024)
+
+
+/**
+ * struct buf_info - Structure to hold context information for TX/RX buffers.
+ * @dma_buf: The DMA mapped address of the TX/RX buffer.
+ * @src_ptr: Starting address of the buffer containing the TX/RX frame.
+ * @dma_buf_len: The length of the DMA mapped buffer.
+ * @dma_buf_priv: Indicates whether the TX/RX buffer is in the bounce buffer
+ *                area.
+ * @skb: Address of the network buffer which is being used for the TX/RX frame.
+ *
+ * This structure contains context information about a TX/RX buffer and holds
+ * information which is needed once the Firmware has finished processing the
+ * buffer.
+ */
+struct buf_info {
+	dma_addr_t dma_buf;
+	void __iomem *src_ptr;
+	unsigned int dma_buf_len;
+	unsigned int dma_buf_priv;   /* Is the DMA buffer in our private area */
+	struct sk_buff *skb;
+} __packed;
+
+int _rpu_umac_if_init(struct proc_dir_entry **);
+void _rpu_umac_if_exit(void);
+int reset_hal_params(void);
+
+static inline void hal_rpu_read(struct hal_priv *hpriv,
+				    unsigned long base,
+				    unsigned long offset,
+				    unsigned int *data)
+{
+	if (base == RPU_SYSBUS_REG)
+		*data = readl((void __iomem *)(hpriv->rpu_sysbus_base_addr + offset));
+	else if (base == RPU_GRAM_PACKED)
+		*data = readl((void __iomem *)(hpriv->gram_base_addr + offset));
+	else if (base == RPU_GRAM_MSB)
+		*data = readl((void __iomem *)(hpriv->gram_b4_addr + offset));
+}
+
+static inline void hal_rpu_write(struct hal_priv *hpriv,
+				     unsigned long base,
+				     unsigned long offset,
+				     unsigned int data)
+{
+	if (base == RPU_SYSBUS_REG)
+		writel(data, (void __iomem *)(hpriv->rpu_sysbus_base_addr+ offset));
+	else if (base == RPU_GRAM_PACKED)
+		writel(data, (void __iomem *)(hpriv->gram_base_addr + offset));
+	else if (base == RPU_GRAM_MSB)
+		writel(data, (void __iomem *)(hpriv->gram_b4_addr + offset));
+}
+
+/**
+ * struct hal_ops_tag - This structure has ops which are used by the Host to
+ *                      interface with the RPU.
+ * @init: Setup Memory Mapping of RPU Regions.
+ *        This op is called at startup before any messages are sent/received.
+ *        The HAL performs local initializations and sets up the memory
+ *        mappings of different RPU regions (like GRAM/SYSBUS etc).
+ *        This op can sleep.
+ *
+ * @deinit: Unmap the RPU regions.
+ *          This op is called when the services of HAL are no longer needed.
+ *          The HAL frees up resources and unmaps the RPU regions mapped by
+ *          @init.
+ *          This op can sleep.
+ *
+ * @start: This op is used to kick off the communication between the Host and
+ *         the RPU once the Host is ready to process messages from the RPU.
+ *
+ * @stop: This op is used to shutdown the communication between the Host and
+ *        RPU.
+ *
+ * @register_callback: This op is used to register a handler which will be
+ *                     invoked by Host HAL to pass RPU events to the next
+ *                     layer.
+ *
+ * @send: This op is used to send commands to RPU.
+ *
+ * @init_bufs: Program the information about RX buffers to RPU and creates
+ *             mapping tables to maintain context information for TX and RX
+ *             buffers.
+ *             This op is invoked to inform the HAL that it has to prepare for
+ *             receiving WLAN data packets from the RPU. This op allocates a
+ *             pool of RX buffers in Host memory and then programs the
+ *             Descriptor ID and DMAable address of each buffer to the RPU
+ *             using @cmd_hal.
+ *             This op can sleep.
+ *             Returns 0 on success and non-zero on failure.
+ *
+ * @deinit_bufs: This op is used to free the resources allocated using
+ *               @init_bufs.
+ *
+ * @map_tx_buf: DMA mapping for a Tx buffer.
+ *              This op is invoked prior to invoking the @send op for messages
+ *              which have payloads associated with them (currently only
+ *              @cmd_tx_ctrl). The Host HAL performs the following things via
+ *              this op -
+ *                 a. Bounce Buffer handling - Making sure that the TX buffer
+ *                    falls within a DMAable region, else copying it to a bounce
+ *                    buffer.
+ *                 b. DMA mapping - DMA mapping the TX buffer/Bounce buffer. The
+ *                    result of the mapping is communicated back to the caller.
+ *                 c. Mapping table updation - Updates the information about the
+ *                    TX buffer (@buf_info) in a mapping table indexed by
+ *                    Descriptor ID's.
+ *              Returns 0 on success and error on failure.
+ *
+ * @unmap_tx_buf: Unmapping of a TX buffer.
+ *                This op is invoked when driver receives @umac_event_tx_done
+ *                from the RPU which indicates that the processing of a TX
+ *                frame has been completed. The Host HAL performs the following
+ *                things via this op -
+ *                 a. DMA unmapping - DMA unmapping the TX buffer/Bounce buffer
+ *                    which was mapped using @map_tx_buf. The information about the
+ *                    buffer is retrieved from the mapping table using the
+ *                    Descriptor ID as an index.
+ *                 b. Mapping table updation - Clears off the entry in the
+ *                    mapping table corresponding to the Descriptor ID.
+ *
+ * @reset_hal_params: This op initializes the Command and Event counts (which are
+ *                    used by the Host and Firmware HAL's to validate the
+ *                    interrupts).
+ *
+ * @enable_irq_wake: This op is used to inform the Host to keep the IRQ active
+ *                   even when it goes to a low power state.
+ *
+ * @disable_irq_wake: This op is used to inform the Host to disable the IRQ
+ *                    when it goes to a low power state.
+ *
+ * @get_dev: This op is used to return OS specific device structure depending on
+ *           the bus type.
+ *
+ * @trigger_timed_sleep: Trigger the LPW to enter in to Sleep and wakeup
+ *			 after a timeout.
+ *
+ * @trigger_wakeup: Trigger the LPW to wakeup, this will assert/de-assert
+ *		    the WAKEUP_NOW signal.
+ *
+ * @rpu_sleep_status: Query the sleep controller about the state of RPU Sleep.
+ *
+ * @get_dump_gram: This op is is used to return the starting pointer
+ *		   to GRAM dump.
+ *
+ * @get_dump_core: This op is is used to return the starting pointer
+ *		   to CORE dump.
+ *
+ * @get_dump_perip: This op is is used to return the starting pointer
+ *		    to PERIP dump.
+ *
+ * @get_dump_sysbus: This op is is used to return the starting pointer
+ *		     to SYSBUS dump.
+ *
+ * @get_dump_len: This op is is used to return the length of the dump
+ * 		  for a give region.
+ *
+ * @rpu_set_mem: This op is is used to set the memory of RPU.
+ *
+ * @rpu_read_mem: This op is is used to to read from the RPU memory
+ *		  to local memory.
+ *
+ * @rpu_write_mem: This op is is used to write from the local memory
+ *		   to RPU memory.
+ *
+ * @mtx_start_thread: This op is is used to start the MTX threads
+ *		      (Applicable only for META)
+ *
+ * @mtx_stop_thread: This op is is used to stop the MTX threads.
+ *		      (Applicable only for META)
+ *
+ * These APIs allow the upper parts of the Host driver to control the HAL.
+ * None of these APIs can put the caller to sleep unless stated explicitly in
+ * the description.
+ */
+struct hal_ops_tag {
+	int (*init)(void *dev);
+	int (*deinit)(void *dev);
+	int (*start)(void);
+	int (*stop)(void);
+	void (*register_callback)(msg_handler);
+	void (*send)(void* msg, void* payload, unsigned int descriptor_id);
+	int (*init_bufs)(unsigned int tx_bufs,
+			 unsigned int rx_bufs_2k,
+			 unsigned int rx_bufs_12k,
+			 unsigned int tx_max_data_size);
+	void (*deinit_bufs)(void);
+	int (*map_tx_buf)(int pkt_desc,
+			  int frame_id,
+			  unsigned char * data,
+			  int len,
+			  dma_addr_t *dma_addr);
+	int (*unmap_tx_buf)(int pkt_desc, int frame_id);
+	int (*reset_hal_params)(void);
+#ifdef CONFIG_PM
+	void (*enable_irq_wake)(void);
+	void (*disable_irq_wake)(void);
+#endif
+	struct device * (*get_dev)(void);
+#ifdef RPU_SLEEP_ENABLE
+	void (*trigger_timed_sleep)(int val);
+	void (*trigger_wakeup)(enum RPU_SLEEP_TYPE);
+	bool (*rpu_sleep_status)(void);
+#endif
+	int (*rpu_set_mem)(unsigned int *dst,
+			     unsigned int val,
+			     unsigned int len);
+	int (*rpu_read_mem)(unsigned int *src,
+			     unsigned int *dst,
+			     unsigned int len);
+	int (*rpu_write_mem)(unsigned int *src,
+			     unsigned int *dst,
+			     unsigned int len);
+	void (*mtx_start_thread)(unsigned int thrd_num,
+				 unsigned int stack_ptr,
+				 unsigned int prog_ctr,
+				 unsigned int catch_state_addr);
+	void (*mtx_stop_thread)(unsigned int thrd_num);
+
+        void (*set_mem_region)(unsigned int);
+        void (*request_mem_regions)(unsigned char **,
+                                    unsigned char **,
+                                    unsigned char **);
+
+};
+
+extern struct hal_ops_tag hal_ops;
+#endif /* _HAL_H_ */
+
+/* EOF */
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/hal_io.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/hal_io.h
new file mode 100755
index 000000000..6e82700c4
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/hal_io.h
@@ -0,0 +1,24 @@
+#ifndef _COMMON_IO_H
+#define _COMMON_IO_H
+
+
+int rk915_clear_irq(struct hal_priv *priv);
+void rk915_lock(struct hal_priv *priv);
+void rk915_unlock(struct hal_priv *priv);
+int rk915_read_data_len(struct hal_priv *priv);
+int rk915_writeb(struct hal_priv *priv, unsigned int addr, int val);
+int rk915_readb(struct hal_priv *priv, unsigned int addr);
+int rk915_data_read(struct hal_priv *priv, unsigned int addr,
+						    unsigned char *buf, unsigned int len);
+int rk915_data_write(struct hal_priv *priv, unsigned int addr,
+						    void *buf, size_t buf_len);
+int rk915_data_write_sg(struct hal_priv *priv, unsigned int addr,
+						    void *buf, size_t buf_len);
+int rk915_io_init(struct hal_priv *priv);
+int rk915_ejtag(struct hal_priv *priv);
+int rk915_serias_read(struct hal_priv *priv, u16 addr,
+						void *buf, size_t buf_len, u32 max_len);
+int rk915_io_reset(struct hal_priv *priv);
+void rk915_notify_pm(struct hal_priv *priv, int wakeup);
+
+#endif //_COMMON_IO_H
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/if_io.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/if_io.h
new file mode 100755
index 000000000..8b5c09c66
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/if_io.h
@@ -0,0 +1,79 @@
+#ifndef _IF_IO_H_
+#define _IF_IO_H_
+
+enum IO_IF_TYPE {
+	IO_IF_SDIO = 0,
+	IO_IF_USB,
+	IO_IF_SPI,
+	IO_IF_PCIE,
+};
+
+enum FW_ERR_REASON {
+	FW_ERR_SDIO,
+	FW_ERR_RESET_CMD,
+	FW_ERR_LPW_RECOVERY
+};
+
+#define SUPPORT_SDIO_SLEEP	0
+#define NOTIFY_M0_SLEEP		1
+#define SDIO_AUTO_SLEEP		0
+
+#define MAX_RX_SERIAS_COUNT	16
+#define MAX_RX_SERIAS_BYTES	(MAX_RX_SERIAS_COUNT * MAX_DATA_SIZE_2K + 512)
+struct host_io_info {
+	struct device		*dev;
+	unsigned int		irq;
+	bool				irq_request;
+	struct host_io_ops 	*io_ops;
+	unsigned char		type;
+	void*			rx_serias_buf;
+	void*			rx_serias_buf_curr;
+	unsigned short		rx_serias_len[MAX_RX_SERIAS_COUNT];
+	int			rx_serias_count;
+	int			rx_serias_idx;
+	unsigned int		rx_next_len;
+	void			*priv_data;
+	struct firmware_info	firmware;
+#if SDIO_AUTO_SLEEP
+	struct delayed_work	sleep_work;
+#endif
+	bool				bus_init;
+};
+
+struct cmd_rx_ctrl {
+	struct host_rpu_msg_hdr	mac_hdr;
+	unsigned int		pkt_count;
+	unsigned short		pkt_len[MAX_RX_SERIAS_COUNT];
+} __IMG_PKD;
+
+struct host_io_ops {
+	int	(*io_send)(struct host_io_info *host, unsigned int addr, unsigned char *buf, unsigned int len);
+	int	(*io_send_sg)(struct host_io_info *host, unsigned int addr, unsigned char *buf, unsigned int len);
+	int	(*io_recv)(struct host_io_info *host, unsigned int addr, unsigned char *buf, unsigned int len);
+	int	(*io_readb)(struct host_io_info *host, unsigned int addr);
+	int	(*io_writeb)(struct host_io_info *host, unsigned int addr, unsigned char val);
+	int	(*io_writeb_comp)(struct host_io_info *host);
+	int	(*io_init)(struct host_io_info *host);
+	int	(*io_register_irq)(struct host_io_info *host);
+	void	(*lock)(struct host_io_info *host);
+	void	(*unlock)(struct host_io_info *host);
+	int	(*io_ejtag)(struct host_io_info *host);
+	int	(*io_reset)(struct host_io_info *host);
+	int	(*io_notify_pm)(struct host_io_info *host, int wakeup);
+#if SUPPORT_SDIO_SLEEP
+	int	(*sleep)(struct host_io_info *host);
+	int	(*wakeup)(struct host_io_info *host);
+#endif
+};
+
+void rk915_sdio_pre_init(void);
+int rk915_sdio_init(struct host_io_info *phost);
+int rk915_sdio_deinit(struct host_io_info *phost);
+int rk915_sdio_recovery_init(struct host_io_info *phost);
+void rk915_signal_io_error(int reason);
+int rk915_sdio_register_driver(void);
+void rk915_sdio_unregister_driver(void);
+void rk915_sdio_set_clock(struct host_io_info *phost, int hz);
+
+#endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/p2p.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/p2p.h
new file mode 100755
index 000000000..abc36c258
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/p2p.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _P2P_H_
+#define _P2P_H_
+void rpu_roc_complete_work(struct work_struct *work);
+int remain_on_channel(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif,
+			     struct ieee80211_channel *channel,
+			     int duration,
+			     enum ieee80211_roc_type type);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
+int cancel_remain_on_channel(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif);
+#else
+int cancel_remain_on_channel(struct ieee80211_hw *hw);
+#endif
+void rpu_noa_event(int event, struct umac_event_noa *noa, void *context,
+			   struct sk_buff *skb);
+#endif /* _P2P_H_*/
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/platform.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/platform.h
new file mode 100755
index 000000000..9f6d303f4
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/platform.h
@@ -0,0 +1,18 @@
+#ifndef __RK915_PLATFORM_H_
+#define __RK915_PLATFORM_H_
+
+void rk915_poweroff(void);
+void rk915_poweron(void);
+void rk915_rescan_card(unsigned insert);
+int rk915_platform_bus_init(struct host_io_info *phost);
+int rk915_platform_bus_rec_init(struct host_io_info *phost);
+int rk915_platform_bus_deinit(struct host_io_info *phost);
+int rk915_register_irq(struct host_io_info *host);
+int rk915_free_irq(struct host_io_info *host);
+void rk915_irq_enable(int enable);
+int rk915_bus_register_driver(void);
+void rk915_bus_unregister_driver(void);
+
+#define RK915_POWER_ON_DELAY_MS	20
+
+#endif //__RK915_PLATFORM_H_
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/rpu.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/rpu.h
new file mode 100755
index 000000000..500feed2c
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/rpu.h
@@ -0,0 +1,196 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _RPU_H_
+#define _RPU_H_
+
+/* RPU Porting information: Based on RPU Config.
+
+ * These are the only values which need to be modified as per 
+ * a) host memory map 
+ * b) HOSt <->MCU interrupt configuration.
+ * c) RPU Config specific details
+ */
+
+/*********************************************************************
+ * RPU Config Specific Details
+ *********************************************************************
+ */
+#define HAL_RPU_GRAM_BASE 0xB7000000
+#define HAL_RPU_GRAM_LEN 0x1eac0
+#define HAL_SHARED_MEM_OFFSET 0xffc
+/* fwldr.c converts these to HOST addresses
+ * so pass RPU addresses here.
+ * From: uccrunTime/Platform/configs
+ */
+#define RPU_COREA_REGION_START 0x80880000
+#define RPU_COREA_REGION_LEN 0x4C000
+
+#define RPU_COREB_REGION_START 0x82000000
+#define RPU_COREB_REGION_LEN 0x4C000
+/*********************************************************************
+ */
+
+/********************************************************************
+ * HOST processor to Meta Processor on RPU Communications Registers
+ ********************************************************************
+ * Refer: Volt RPU.Technical Reference Manual.pdf
+	The host_to_mtx_cmd register is written to by the host in order to
+	send data to the META. The act of writing causes an event on the META
+	(the host_int interrupt occurs). The META handles this event by reading
+	host_to_mtx_cmd, collecting the message data.
+
+	The META clears the interrupt and in the process acknowledges reception
+	of the message by writing to the mtx_to_host_ack register. The host checks
+	for this acknowledgement by reading host_to_mtx_cmd, checking the state of
+	the HOST_INT bit.
+
+	A message initiated by the META and destined for the host uses the same
+	scheme, but utilising the mtx_to_host_cmd and host_to_mtx_ack registers and
+	by responding to the mtx_int interrupt.
+*/
+
+/* SYSBUS - System Control - REGSYSREG 
+ * RPU_CORE_REG is a subset of System Bus Registers
+ */
+#define HAL_RPU_CORE_REG_OFFSET	0x400
+
+/* Register HOST_TO_MTX_CMD */
+#define HOST_TO_MTX_CMD 0x0030
+#define HOST_TO_MTX_CMD_ADDR ((hpriv->rpu_mem_addr) + \
+				    HOST_TO_MTX_CMD)
+#define MTX_HOST_INT_SHIFT 31
+
+/* Register MTX_TO_HOST_CMD */
+#define MTX_TO_HOST_CMD 0x0034
+#define MTX_TO_HOST_CMD_ADDR ((hpriv->rpu_mem_addr) + \
+				    MTX_TO_HOST_CMD)
+
+/* Register HOST_TO_MTX_ACK */
+#define HOST_TO_MTX_ACK 0x0038
+#define HOST_TO_MTX_ACK_ADDR ((hpriv->rpu_mem_addr) + \
+				    HOST_TO_MTX_ACK)
+#define MTX_INT_CLR_SHIFT 31
+
+/* Register MTX_TO_HOST_ACK */
+#define MTX_TO_HOST_ACK 0x003C
+#define MTX_TO_HOST_ACK_ADDR ((hpriv->rpu_mem_addr) + \
+				    MTX_TO_HOST_ACK)
+
+/* Register MTX_INT_ENABLE
+ * Enable INT line within META Block
+ */
+#define MTX_INT_ENABLE 0x0044
+#define MTX_INT_ENABLE_ADDR ((hpriv->rpu_mem_addr) + \
+				   MTX_INT_ENABLE)
+#define MTX_INT_EN_SHIFT 31
+
+/* System Level Interrupt Control for each block.
+ * Enable INT line for META block.
+ */
+#define SYS_INT_ENAB 0x0000
+#define SYS_INT_ENAB_ADDR ((hpriv->rpu_mem_addr) + SYS_INT_ENAB)
+#define SYS_INT_MTX_IRQ_ENAB_SHIFT 15
+
+/*********************************************************************
+ */
+/*********************************************************************
+ * RPU MTX FW Download Registers
+ *********************************************************************
+ */
+
+enum rpu_mem_region {
+	RPU_MEM_CORE,
+	RPU_MEM_DIRECT,
+	RPU_MEM_ERR
+};
+
+
+#define RPU_GRAM_BASE	    0xB7000000
+
+#define RPU_OFFSET_MASK    0x00FFFFFF
+#define RPU_BASE_MASK      0xFF000000
+#define RPU_GRAM_PACKED    0xB7
+#define RPU_GRAM_MSB       0xB4
+
+
+#define RPU_SYSBUS_REG     0xA4
+#define UCCP_BEV	   0xBF
+
+#define REGMIPSMCU 0xA4000000                	       /* 7.5 */
+#define MIPS_MCU_CONTROL REGMIPSMCU + 0x0              /* 13.1.1 */
+#define MIPS_MCU_BOOT_EXCP_INSTR_0 REGMIPSMCU + 0x50   /* 13.1.15 */
+#define MIPS_MCU_BOOT_EXCP_INSTR_1 REGMIPSMCU + 0x54   /* 13.1.16 */
+#define MIPS_MCU_BOOT_EXCP_INSTR_2 REGMIPSMCU + 0x58   /* 13.1.17 */
+#define MIPS_MCU_BOOT_EXCP_INSTR_3 REGMIPSMCU + 0x5c   /* 13.1.18 */
+
+#define MIPS_MCU_SYS_CORE_MEM_CTRL  REGMIPSMCU + 0x30  /* 13.1.10 */
+#define MIPS_MCU_SYS_CORE_MEM_WDATA REGMIPSMCU + 0x34  /* 13.1.11 */
+#define MIPS_MCU_SYS_CORE_MEM_RDATA REGMIPSMCU + 0x38  /* 13.1.11 */
+
+
+#define MTX_REG_INDIRECT(unit, reg) (((reg & 0x7) << 4) | (unit & 0xF))
+
+#define MTX_PC_REG_IND_ADDR        MTX_REG_INDIRECT(5, 0)
+#define MTX_A0STP_REG_IND_ADDR     MTX_REG_INDIRECT(3, 0)
+
+#define MTX_PCX_REG_IND_ADDR MTX_REG_INDIRECT(5, 1)
+#define MTX_TXMASK_REG_IND_ADDR MTX_REG_INDIRECT(7, 1)
+#define MTX_TXMASKI_REG_IND_ADDR MTX_REG_INDIRECT(7, 3)
+#define MTX_TXPOLL_REG_IND_ADDR MTX_REG_INDIRECT(7, 4)
+#define MTX_TXPOLLI_REG_IND_ADDR MTX_REG_INDIRECT(7, 6)
+#define MTX_TXSTAT_REG_IND_ADDR MTX_REG_INDIRECT(7, 0)
+#define MTX_TXSTATI_REG_IND_ADDR MTX_REG_INDIRECT(7, 2)
+
+#define REG_IND_READ_FLAG (1 << 16)
+
+#define MTX_TXPRIVEXT_ADDR 0x048000E8
+#define MTX_TXSTATUS_ADDR 0x48000010
+#define	MTX_TXENABLE_ADDR 0x04800000
+#define	MTX_START_EXECUTION 1
+#define	MTX_STOP_EXECUTION 0
+
+#define MTX_TXUXXRXDT 0x0480FFF0
+#define MTX_TXUXXRXRQ 0x0480FFF8
+
+#define MSLV_BASE_ADDR 0x0203C000
+
+/* DATA Exchange Register */
+#define MSLVDATAX (MSLV_BASE_ADDR + 0x2000)
+
+/* DATA Transfer Register */
+#define MSLVDATAT (MSLV_BASE_ADDR + 0x2040)
+
+/* Control Register 0 */
+#define MSLVCTRL0 (MSLV_BASE_ADDR + 0x2080)
+
+/* Soft Reset register */
+#define MSLVSRST (MSLV_BASE_ADDR + 0x2600)
+
+#define SLAVE_ADDR_MODE_MASK 0xFFFFFFFC
+#define SLAVE_SINGLE_WRITE 0x00
+#define SLAVE_SINGLE_READ 0x01
+#define SLAVE_BLOCK_WRITE 0x02
+#define SLAVE_BLOCK_READ 0x03
+
+/* Control Register 1 */
+#define MSLVCTRL1 (MSLV_BASE_ADDR + 0x20c0)
+
+#define MSLVCTRL1_POLL_MASK 0x07000000
+#define MSLAVE_READY(v) ((v & MSLVCTRL1_POLL_MASK) == MSLVCTRL1_POLL_MASK)
+#define LTP_THREAD_NUM 0 /* Since, only one thread exists */
+
+/* Thread completion signature */
+#define RPU_THRD_EXEC_SIG_OFFSET 0x00066CBC
+#define RPU_THRD_EXEC_SIG 0x5A5A5A5A
+
+#define MAX_LOAD_MEM_LEN 4096
+/*********************************************************************
+ */
+#endif /* _RPU_H_ */
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/rpu_if.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/rpu_if.h
new file mode 100755
index 000000000..3b3b2f485
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/rpu_if.h
@@ -0,0 +1,276 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _RPU_IF_H_
+#define _RPU_IF_H_
+
+#include <linux/skbuff.h>
+
+#include "hal.h"
+#include "host_rpu_if.h"
+
+#define UMAC_ROC_AC WLAN_AC_VO
+
+struct umac_key {
+	unsigned char *peer_mac;
+	unsigned char *tx_mic;
+	unsigned char *rx_mic;
+	unsigned char *key;
+};
+
+struct ssid_desc {
+	unsigned char ssid[MAX_SSID_LEN];
+	unsigned char ssid_len;
+};
+
+struct scan_req {
+	unsigned int n_channels;
+	int n_ssids;
+	unsigned int ie_len;
+	unsigned char ie[256];
+	unsigned int p2p_probe;
+	/*TODO: Make this a structure*/
+	unsigned short center_freq[50];
+	unsigned char freq_max_power[50];
+	unsigned char chan_flags[50];
+	struct ssid_desc ssids[MAX_NUM_SSIDS];
+};
+
+/*commands*/
+extern int rpu_scan(int index,
+			    struct scan_req *req);
+
+extern int rpu_scan_abort(int index);
+
+
+extern int rpu_prog_tx(unsigned int queue,
+			       unsigned int more_data,
+			       unsigned int tokenid,
+			       bool retry);
+
+extern int rpu_prog_reset(unsigned int reset_type,
+				  unsigned int rpu_mode);
+
+extern int rpu_prog_vif_ctrl(int index,
+				     unsigned char *vif_addr,
+				     unsigned int  vif_type,
+				     unsigned int  add_vif);
+
+extern int rpu_prog_vif_basic_rates(int index,
+					    unsigned char *vif_addr,
+					    unsigned int basic_rate_set);
+
+extern int rpu_prog_vif_short_slot(int index,
+					   unsigned char *vif_addr,
+					   unsigned int use_short_slot);
+
+extern int rpu_prog_vif_atim_window(int index,
+					    unsigned char *vif_addr,
+					    unsigned int atim_window);
+
+extern int rpu_prog_vif_aid(int index,
+				    unsigned char *vif_addr,
+				    unsigned int aid);
+
+extern int rpu_prog_vif_op_channel(int index,
+					   unsigned char *vif_addr,
+					   unsigned char op_channel);
+
+extern int rpu_prog_vif_conn_state(int index,
+					      unsigned char *vif_addr,
+					      unsigned int state);
+
+extern int rpu_prog_vif_assoc_cap(int index,
+					  unsigned char *vif_addr,
+					  unsigned int caps);
+
+extern int rpu_prog_vif_beacon_int(int index,
+					   unsigned char *vif_addr,
+					   unsigned int bcn_int);
+
+extern int rpu_prog_vif_dtim_period(int index,
+					    unsigned char *vif_addr,
+					    unsigned int dtim_period);
+
+extern int rpu_prog_vif_apsd_type(int index,
+					  unsigned char *vif_addr,
+					  unsigned int uapsd_type);
+
+extern int rpu_prog_long_retry(int index,
+				       unsigned char *vif_addr,
+				       unsigned int long_retry);
+
+extern int rpu_prog_short_retry(int index,
+					unsigned char *vif_addr,
+					unsigned int short_retry);
+
+extern int rpu_prog_vif_bssid(int index,
+				      unsigned char *vif_addr,
+				      unsigned char *bssid);
+
+extern int rpu_prog_vif_smps(int index,
+				     unsigned char *vif_addr,
+				     unsigned char smps_mode);
+
+extern int rpu_prog_ps_state(int index,
+				     unsigned char *vif_addr,
+				     unsigned int powersave_state);
+
+extern int rpu_prog_global_cfg(unsigned int rx_msdu_lifetime,
+				       unsigned int tx_msdu_lifetime,
+				       unsigned int sensitivity,
+				       unsigned int dyn_ed_enabled,
+				       unsigned char *rf_params);
+
+extern int rpu_prog_cfgmisc(unsigned int flag);
+
+extern int rpu_prog_txpower(unsigned int txpower);
+
+extern int rpu_prog_patch_feature(unsigned int feature);
+
+extern int rpu_prog_btinfo(unsigned int bt_state);
+
+extern int rpu_prog_mcast_addr_cfg(unsigned char  *mcast_addr,
+					   unsigned int add_filter);
+
+extern int rpu_prog_mcast_filter_control(unsigned int
+						 enable_mcast_filtering);
+
+extern int rpu_prog_rcv_bcn_mode(unsigned int  bcn_rcv_mode);
+extern int rpu_prog_cont_tx(int val);
+extern int rpu_prog_txq_params(int index,
+				       unsigned char *vif_addr,
+				       unsigned int queue,
+				       unsigned int aifs,
+				       unsigned int txop,
+				       unsigned int cwmin,
+				       unsigned int cwmax,
+				       unsigned int uapsd);
+
+extern int rpu_prog_channel(unsigned int prim_ch,
+				    unsigned int center_freq1,
+				    unsigned int center_freq2,
+				    unsigned int ch_width,
+				    unsigned int freq_band);
+
+extern int rpu_prog_peer_key(int index,
+				     unsigned char *vif_addr,
+				     unsigned int op,
+				     unsigned int key_id,
+				     unsigned int key_type,
+				     unsigned int cipher_type,
+				     struct umac_key *key);
+
+extern int rpu_prog_if_key(int   index,
+				   unsigned char *vif_addr,
+				   unsigned int op,
+				   unsigned int key_id,
+				   unsigned int cipher_type,
+				   struct umac_key *key);
+
+extern int rpu_prog_mib_stats(void);
+
+extern int rpu_prog_clear_stats(void);
+
+extern int rpu_prog_phy_stats(void);
+
+extern int rpu_prog_ba_session_data(unsigned int op,
+					    unsigned short tid,
+					    unsigned short *ssn,
+					    unsigned short ba_policy,
+					    unsigned char *sta_addr,
+					    unsigned char *peer_add);
+
+
+extern int rpu_prog_roc(unsigned int roc_status,
+				unsigned int roc_channel,
+				unsigned int roc_duration,
+				unsigned int roc_type);
+extern int rpu_prog_read_csr(unsigned int addr);
+
+#ifdef CONFIG_PM
+extern int rpu_prog_econ_ps_state(int if_index,
+					  unsigned int ps_state);
+#endif
+
+extern int rpu_prog_phy_thresh(unsigned int *thresh);
+
+extern int rpu_prog_txrx_test(int status);
+extern int rpu_fw_priv_cmd(unsigned int type, void *priv);
+extern int rpu_fw_priv_cmd_sync(unsigned int type, void *priv);
+
+/* Events  */
+extern void rpu_scan_complete(void *context,
+				      struct host_event_scanres *scan_res,
+				      unsigned char *skb,
+				      unsigned int len);
+extern void rpu_scan_abort_complete(void *context);
+
+extern void rpu_reset_complete(char *rpu_version,
+				       void *context);
+
+extern void rpu_proc_tx_complete(struct umac_event_tx_done *txdone,
+				    void *context);
+
+extern void rpu_proc_rx_event(void *nbuff, void *context);
+
+extern void rpu_tx_complete(struct umac_event_tx_done *txdone,
+				    void *context);
+
+extern void rpu_tx_proc_unfi_tx_done(void);
+
+extern void rpu_rx_frame(struct sk_buff *skb,
+				 void *context);
+
+
+extern void rpu_mac_stats(struct umac_event_mac_stats *mac_stats,
+				  void *context);
+
+extern void rpu_fw_priv_cmd_done(struct fw_priv_cmd_done *event,
+			   void *context);
+
+extern void rpu_fw_info_dump_start(void *context, unsigned int type, unsigned int reg);
+
+extern void rpu_noa_event(int event,
+				  struct umac_event_noa *noa_event,
+				  void *context,
+				  struct sk_buff *skb);
+
+extern void rpu_ch_prog_complete(int event,
+					 struct umac_event_ch_prog_complete *ch,
+					 void *context);
+
+/*Sleep Controll config API's
+ */
+int rpu_prog_pwrmgmt_pwr_on_value(unsigned int *pwr_on_values, unsigned int size);
+int rpu_prog_pwrmgmt_pwr_off_value(unsigned int *pwr_off_values, unsigned int size);
+int rpu_prog_pwrmgmt_ram_on_state(unsigned int *ram_on_states, unsigned int size);
+int rpu_prog_pwrmgmt_ram_off_state(unsigned int *ram_off_states, unsigned int size);
+int rpu_prog_pwrmgmt_pwr_on_time(unsigned int *pwr_on_times, unsigned int size);
+int rpu_prog_pwrmgmt_pwr_off_time(unsigned int *pwr_off_times, unsigned int size) ;
+int rpu_prog_pwrmgmt_ram_on_time(unsigned int *ram_on_times, unsigned int size);
+int rpu_prog_pwrmgmt_ram_off_time(unsigned int *ram_off_times, unsigned int size) ;
+int rpu_prog_pwrmgmt_sleep_freq(unsigned int sleep_freq);
+int rpu_prog_pwrmgmt_clk_adj(unsigned int clk_adj_val);
+int rpu_prog_pwrmgmt_wakeup_time(unsigned int wakeup_time);
+/* Init/Deinit */
+
+extern int rpu_if_init(void *context,
+				    const char *name);
+
+extern void rpu_if_deinit(void);
+
+extern void rpu_if_free_outstnding(void);
+
+
+
+#endif /* _RPU_IF_H_ */
+
+/* EOF */
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/sdio.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/sdio.h
new file mode 100755
index 000000000..ac00a6d2a
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/sdio.h
@@ -0,0 +1,131 @@
+#ifndef IF_SDIO_H
+#define IF_SDIO_H
+
+#define TX_MSG_CMD		1
+#define TX_MSG_PKT		2
+#define TX_MSG_PATCH		3
+
+#define PKT_TYPE_MPDU		1
+#define PKT_TYPE_AMSDU		2
+#define PKT_TYPE_AMPDU		3
+
+#define READ_EVENT_REQ		1
+#define READ_PKT_REQ		2
+
+enum sdio_rw_op_type {
+	SDIO_RW_DONE_STATUS = 0,
+	SDIO_WRITE_STATUS,
+	SDIO_READ_STATUS,
+};
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+// Host Read Only Regs
+//////////////////////////////////////////////////////////////////////////////////////////////
+
+/* Host need to check this reg before each write operation.
+ * for write to read
+ * 8bit
+ * device:W/R   host:R
+ * SDIO_HOST_READ_REG_WRITE_EN[0]=1'b1: host write enable
+ * SDIO_HOST_READ_REG_WRITE_EN[0]=1'b0: host write disable
+ * SDIO_HOST_READ_REG_WRITE_EN[7:1]: reason code(reserved)
+ */
+#define SDIO_HOST_READ_REG_WRITE_EN			0 
+
+/* Host need to check this reg before read operation.
+ * for read to read
+ * 16bit
+ * device:W/R   host:R
+ * SDIO_RX_CTRL_REG[14:0]: length
+ * SDIO_RX_CTRL_REG[15]: 1'b1 more data, 1'b0 no more data
+ */
+#define SDIO_HOST_READ_REG_RECV_LEN_L		2
+#define SDIO_HOST_READ_REG_RECV_LEN_H		3
+
+/* 8bit
+ * device:W/R   host:R
+ * SDIO_RX_CTRL_REG[7:0]: firmware state
+ */
+enum FW_STATE {
+	WAIT_FW = 0,
+	M0_STARTED,
+	WAIT_PATCH,
+	WAIT_PATCH2,
+	LPW_READY,
+	M0_READY,
+	M0_SLEEP,
+	RESET_COMPLETE,
+};
+
+#define SDIO_HOST_READ_REG_FW_STATE			64
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+// Host Write Only Regs
+//////////////////////////////////////////////////////////////////////////////////////////////
+
+/* Host need to write this reg before write operation.
+ * for write to write
+ * 8bit
+ * device:R     host:W/R
+ * SDIO_HOST_WRITE_REG_PKT_INFO[1:0]: type(CMD/PKT/PATCH)
+ * type:
+ *      2'b01:CMD
+ *      2'b10:PKT
+ *      2'b11:PATCH
+ *
+ * SDIO_HOST_WRITE_REG_PKT_INFO[1:0]=2'b00: type=CMD, 
+ * SDIO_HOST_WRITE_REG_PKT_INFO[7:2]:CMDID
+ *
+ * SDIO_HOST_WRITE_REG_PKT_INFO[1:0]=2'b01: type=PKT, 
+ * SDIO_HOST_WRITE_REG_PKT_INFO[3:2]:pkt type(AMPDU/AMSDU/MPDU)
+ * pkt type:
+ *      2'b01:MPDU
+ *      2'b10:AMSDU
+ *      2'b11:AMPDU
+ * SDIO_HOST_WRITE_REG_PKT_INFO[3:2]=2'b11, 
+ * SDIO_HOST_WRITE_REG_PKT_INFO[7:4]:AMPDU PKT SEQ
+ */
+#define SDIO_HOST_WRITE_REG_PKT_INFO		17
+
+/* Host need to write this reg before patch transmited.
+ * only for patch download
+ * 16bit
+ * device:R		host:W/R
+ * rom patch total length
+ */
+#define SDIO_HOST_WRITE_REG_PATCH_LEN_L		18
+#define SDIO_HOST_WRITE_REG_PATCH_LEN_H		19
+#define SDIO_HOST_WRITE_REG_NOTIFY_ADDR	17
+#define SDIO_HOST_WRITE_REG_NOTIFY_VAL	1
+#define SDIO_HOST_WRITE_REG_INT_ADDR	32
+#define SDIO_HOST_WRITE_REG_CLR_INT		2
+#define SDIO_HOST_WRITE_REQ_INT_STA		35
+
+#define SDIO_CMD_ADDR			0x10000
+#define SDIO_HOST_PATCH_ADDR	0
+#define SDIO_START_CMD_ID		0x5A5A5A5A
+
+/* hwio addr info */
+#define IO_START_CMD_ADDR		SDIO_CMD_ADDR
+
+#define IO_FW_STATE			SDIO_HOST_READ_REG_FW_STATE
+
+#define IO_PATCH_LEN_L			SDIO_HOST_WRITE_REG_PATCH_LEN_L
+#define IO_PATCH_LEN_H			SDIO_HOST_WRITE_REG_PATCH_LEN_H
+
+#define IO_PATCH_ADDR			SDIO_HOST_PATCH_ADDR
+#define IO_START_CMD_ID			SDIO_START_CMD_ID
+
+#define IO_RECV_LEN_L 			SDIO_HOST_READ_REG_RECV_LEN_L
+#define IO_RECV_LEN_H 			SDIO_HOST_READ_REG_RECV_LEN_H
+
+#define IO_INT_ADDR			SDIO_HOST_WRITE_REG_INT_ADDR
+#define IO_INT_CLR_IRQ_VAL		SDIO_HOST_WRITE_REG_CLR_INT
+
+#define IO_NOTIFY_ADDR			SDIO_HOST_WRITE_REG_NOTIFY_ADDR
+#define IO_NOTIFY_VAL			SDIO_HOST_WRITE_REG_NOTIFY_VAL
+#define IO_NOTIFY_SLEEP			2
+#define IO_NOTIFY_WAKEUP		3
+
+#endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/soc.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/soc.h
new file mode 100755
index 000000000..b2ae19116
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/soc.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _SOC_H_
+#define _SOC_H_
+
+#include <linux/clk.h>
+#include <linux/iio/consumer.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_device.h>
+
+#include "utils.h"
+#include "hal_common.h"
+
+/*SoC Porting information:
+ */
+
+struct soc_ops_tag {
+	void (*program_rpu_dma_start)(struct hal_priv *priv);
+	void (*clock_init)(struct hal_priv *priv);
+	void (*clock_deinit)(struct hal_priv *priv);
+	int (*parse_dtb) (struct hal_priv *priv);
+	void (*set_mem_region)(unsigned int addr);
+};
+
+extern struct soc_ops_tag soc_ops;
+
+/* As per LPW TRM, refer 4.1 section, mapped in FPGA
+ */
+#ifdef HAL_PCIE
+#define WAKEUP_NOW_OFFSET 0x00F10030
+#define HP_RPU_READY 0x00F10034
+#endif
+#ifdef HAL_HOSTPORT
+#endif
+
+#endif /* _SOC_H_ */
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/utils.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/utils.h
new file mode 100755
index 000000000..08089de9e
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/utils.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _UTILS_H
+#define _UTILS_H
+
+#include "core.h"
+#define MASK_BITS(msb, lsb) (((1U << ((msb) - (lsb) + 1)) - 1) \
+			     << (lsb))
+
+#define EXTRACT_BITS(arg, msb, lsb) ((arg & MASK_BITS(msb, lsb)) >> (lsb))
+
+#define INSERT_BITS(arg, msb, lsb, value) ((arg) = ((arg) &		     \
+						    ~MASK_BITS(msb, lsb)) |  \
+						    (((value) << (lsb)) &    \
+						     MASK_BITS(msb, lsb)))
+
+#define FRAME_CTRL_TYPE(arg) EXTRACT_BITS(arg, 3, 2)
+#define FRAME_CTRL_STYPE(arg) EXTRACT_BITS(arg, 7, 4)
+#define FTYPE_DATA 0x02
+#define FSTYPE_QOS_DATA 0x08
+void update_aux_adc_voltage(struct img_priv *priv,
+				   unsigned char pdout);
+int conv_str_to_byte(unsigned char *byte,
+		     unsigned char *str,
+		     int len);
+extern int wait_for_scan_abort(struct img_priv *priv);
+extern int wait_for_scan_complete(struct img_priv *priv);
+extern int wait_for_cancel_hw_roc(struct img_priv *priv);
+extern int wait_for_channel_prog_complete(struct img_priv *priv);
+extern int wait_for_tx_queue_flush_complete(struct img_priv *priv,
+					    unsigned int token);
+int wait_for_hp_ready_blocking_sleep(void);
+int wait_for_hp_ready_blocking_busy_wait(void);
+int wait_for_fw_error_process_complete(struct img_priv *priv);
+int wait_for_pm_resume_done(struct img_priv *priv);
+int wait_for_rxq_empty(struct img_priv *priv);
+int wait_for_fw_error_cmd_done(struct img_priv *priv);
+int find_main_iface(struct img_priv *priv);
+int find_p2p_iface(struct img_priv *priv);
+bool is_main_iface(u8 *if_addr);
+
+/*
+ * IEEE 802.11 address fields:
+ * ToDS FromDS Addr1 Addr2 Addr3 Addr4
+ *   0        0        DA    SA    BSSID n/a
+ *   0        1        DA    BSSID SA    n/a
+ *   1        0        BSSID SA    DA    n/a
+ *   1        1        RA    TA    DA    SA
+ */
+static inline u8 *ieee80211_get_BSSID(struct ieee80211_hdr *hdr)
+{
+	if (ieee80211_has_a4(hdr->frame_control))
+		return NULL;
+	if (ieee80211_has_fromds(hdr->frame_control))
+		return hdr->addr2;
+	if (ieee80211_has_tods(hdr->frame_control))
+		return hdr->addr1;
+	return hdr->addr3;
+}
+
+#endif /* _UTILS_H */
+
+/* EOF */
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/version.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/version.h
new file mode 100755
index 000000000..b20047be3
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/version.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _VERSION_H
+#define _VERSION_H
+#define RPU_DRIVER_VERSION "8_0_0"
+#define RPU_DRIVER_NAME "RPUWIFI"
+
+#define VERSION_INFO " 2022-11-08-17:51:56.2094f659.Wei"
+
+#endif /* _VERSION_H */
+
+/* EOF */
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/inc/wow.h b/drivers/net/wireless/rockchip_wlan/rk915/inc/wow.h
new file mode 100755
index 000000000..a6cf8e02e
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/inc/wow.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _WOW_H_
+#define _WOW_H_
+#include <linux/syscore_ops.h>
+
+extern struct syscore_ops host_syscore_ops;
+
+void wow_enable_irq_wake(void);
+void wow_disable_irq_wake(void);
+
+
+#endif /* _WOW_H_ */
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/rk915_rftest.sh b/drivers/net/wireless/rockchip_wlan/rk915/rk915_rftest.sh
new file mode 100755
index 000000000..be7a68f16
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/rk915_rftest.sh
@@ -0,0 +1,297 @@
+#!/system/bin/sh
+
+#############################################
+#
+# Version Information
+#
+#   v0.5 support continue test without reboot DUT
+#   v0.4 add echo mode to check data transmission path
+#   v0.3 add rx sensitivity test
+#   v0.2 add Tx power config
+#   v0.1 init
+#
+#   Authors: cmy@rock-chips.com
+#
+#############################################
+
+version=0.6
+
+dev_dir=/proc/net/rk915
+tmp_file=/data/rk915_fw_info.txt
+
+channel=1
+rate=1
+is_80211n=0
+payload_len=1400
+payload_num=-1
+tx_power=15
+rx=0
+echo_mode=0
+
+if [ -f "/default.prop" ];then
+run_plat=android
+else
+run_plat=linux
+killall dnsmasq dhcpcd
+fi
+
+#echo "current platform is $run_plat"
+
+if [ -f "/sys/power/wake_lock" ];then
+  echo temporary > /sys/power/wake_lock
+fi
+
+if [ -f "/system/lib/modules/rk915.ko" ];then
+  ko_path=/system/lib/modules
+fi
+
+if [ -f "/vendor/lib/modules/wifi/rk915.ko" ];then
+  ko_path=/vendor/lib/modules/wifi
+fi
+
+if [ -f "/vendor/lib/modules/rk915.ko" ];then
+  ko_path=/vendor/lib/modules
+fi
+
+trap 'do_exit' 1 2 3 6 15
+
+do_exit()
+{
+    echo ""
+    echo "Exiting..."
+    stop_rftest
+
+    exit 0
+}
+
+stop_rftest()
+{
+    echo "Stopping..."
+
+    echo "stop_packet_gen=0" > $dev_dir/params
+    echo "stop_prod_mode=0" > $dev_dir/params
+    echo "production_test=0" > $dev_dir/params
+#    echo "production_test=0" > $dev_dir/params && sleep 0.5
+
+    echo "Done."
+}
+
+shwo_usage()
+{
+    echo "RK915 RF test unit. Version: "$version
+    echo "Usage: $0 [OPTION]..."
+
+    echo "\ntx test:\n"
+
+    echo "  -c\t\tSetup channel"
+    echo "\t\t2.4GHz\tChannel: 1..14"
+
+    echo "  -n\t\tEnable 802.11n"
+
+    echo "  -r\t\tSetup rate"
+    echo "\t\t802.11n\t\tRate: 0..7"
+    echo "\t\tnon 802.11n\tRate: 1 2 55 11 6 9 12 18 24 36 48 54"
+
+    echo "  -l\t\tSetup payload length"
+    echo "  -s\t\tSetup how many counts of payload do you want to send, -1 means infinite package send"
+
+    echo "  -t\t\tSetup TxPower  0..20"
+
+    echo "\nrx sensitivity test:\n"
+
+    echo "  -x\n\t\t 1 : Setup rx sensitivity test(fw_skip_rx_pkt_submit)\n\t\t 2 : Setup rx sensitivity test\n\t\t 3 : rx pkgs recv counts"
+    echo "  -c\t\tSetup channel"
+
+    echo "\necho test:\n"
+    echo "  -e\t\tEnter ECHO mode to check data transmission path"
+    echo "\n"
+    echo "  -f\t\tFinish test"
+    echo ""
+}
+
+while getopts "c:r:l:s:x:nt:e:f" arg
+do
+    case $arg in
+        c)
+            channel=$OPTARG
+            ;;
+        n)
+            is_80211n=1
+            ;;
+        r)
+            rate=$OPTARG
+            ;;
+        l)
+            payload_len=$OPTARG
+            ;;
+        t)
+            tx_power=$OPTARG
+            ;;
+        s)
+            payload_num=$OPTARG
+            ;;
+        x)
+            rx=$OPTARG
+            ;;
+        e)
+            echo_mode=1
+            ;;
+        f)
+            do_exit
+            ;;
+        *)
+            shwo_usage
+            exit 1
+            ;;
+    esac
+done
+
+if [ $rx == 4 ]; then
+    rmmod rk915
+    sleep 0.1
+    insmod $ko_path/rk915.ko down_fw_in_probe=1 default_phy_threshold=180 lpw_no_sleep=1
+    sleep 1
+    production_test=0
+    eval $(cat $dev_dir/params | grep "production_test" | busybox awk '
+    {
+        printf("production_test=%d;",$3)
+    }
+    ')
+    if [ $production_test == 0 ]; then
+        echo "production_test=1" > $dev_dir/params
+        echo "fw_skip_rx_pkt_submit=1" > $dev_dir/params
+    fi
+    echo "Start tx cw test(fw_skip_rx_pkt_submit), Set channel: $channel"
+    channel=$((channel+128))
+    echo "channel: $channel"
+    echo "start_prod_cw_mode=$channel" > $dev_dir/params
+    exit 0
+fi
+
+if [ x"`lsmod | grep rk915`" == x ]; then
+    echo "Insmod rk915 module"
+    insmod $ko_path/rk915.ko down_fw_in_probe=1 default_phy_threshold=180 lpw_no_sleep=1
+    sleep 0.1
+fi
+
+if [ ! -f "$dev_dir/params" ]; then
+    echo "ERR: rK915 driver not loaded or init failed!"
+    exit 1
+fi
+
+if [ $rx == 1 ]; then
+    production_test=0
+    eval $(cat $dev_dir/params | grep "production_test" | busybox awk '
+    {
+        printf("production_test=%d;",$3)
+    }
+    ')
+    if [ $production_test == 0 ]; then
+        echo "production_test=1" > $dev_dir/params
+        echo "fw_skip_rx_pkt_submit=1" > $dev_dir/params
+    fi
+    echo "Start rx sensitivity test(fw_skip_rx_pkt_submit), Set channel: $channel"
+    echo "start_prod_rx_mode=$channel" > $dev_dir/params
+    exit 0
+fi
+
+if [ $rx == 2 ]; then
+    echo "production_test=1" > $dev_dir/params
+    echo "Start rx sensitivity test, Set channel: $channel"
+    echo "start_prod_rx_mode=$channel" > $dev_dir/params
+    exit 0
+fi
+
+if [ $rx == 3 ]; then
+    fw_skip_rx_pkt_submit=0
+    eval $(cat $dev_dir/params | grep "fw_skip_rx_pkt_submit" | busybox awk '
+    {
+        printf("fw_skip_rx_pkt_submit=%d;",$3)
+    }
+    ')
+	if [ $fw_skip_rx_pkt_submit == 1 ]; then
+        echo "fw_txrx_count_info" > $dev_dir/params
+	sleep 0.1
+        rx_recv_counts=0
+        cat $dev_dir/fw_info > $tmp_file
+        eval $(cat $tmp_file | grep "event_rx_pkt_crc_ok" | busybox awk '
+        {
+            printf("rx_recv_counts=%d;",$3)
+        }
+        ')
+        echo "crc ok: $rx_recv_counts"
+		rx_recv_counts_err=0
+        eval $(cat $tmp_file | grep "event_rx_pkt_crc_err" | busybox awk '
+        {
+            printf("rx_recv_counts_err=%d;",$3)
+        }
+        ')
+        echo "crc err: $rx_recv_counts_err"        
+    else
+        rx_recv_counts=0
+        eval $(cat $dev_dir/mac_stats | grep "rx_packet_data_count" | busybox awk '
+        {
+            printf("rx_recv_counts=%d;",$3)
+        }
+        ')
+        echo "rx recv counts: $rx_recv_counts"
+        echo "rx_packet_data_count=0" > $dev_dir/params
+    fi
+    exit 0
+fi
+
+production_test=0
+eval $(cat $dev_dir/params | grep "production_test" | busybox awk '
+{
+    printf("production_test=%d;",$3)
+}
+')
+if [ $production_test == 0 ]; then
+    echo "Enable production test mode"
+    echo "production_test=1" > $dev_dir/params
+    sleep 0.1
+fi
+    
+echo "Start prod mode, Set channel: $channel"
+if [ $echo_mode == 1 ]; then
+    echo "start_prod_echo_mode=$channel" > $dev_dir/params
+else
+    echo "stop_packet_gen=0" > $dev_dir/params && sleep 0.1
+    echo "start_prod_mode=$channel" > $dev_dir/params
+fi
+sleep 0.1
+
+if [ $is_80211n == 1 ]; then
+    echo "Use 802.11n"
+    echo "prod_mode_rate_flag=8" > $dev_dir/params
+    echo "tx_fixed_rate=-1" > $dev_dir/params
+    echo "Set rate: MCS$rate"
+    echo "tx_fixed_mcs_indx=$rate" > $dev_dir/params
+else
+    echo "prod_mode_rate_flag=0" > $dev_dir/params
+    echo "tx_fixed_mcs_indx=-1" > $dev_dir/params
+    echo "Set rate: $rate Mbps"
+    echo "tx_fixed_rate=$rate" > $dev_dir/params
+fi
+
+echo "Set tx power: $tx_power"
+echo "set_tx_power=$tx_power" > $dev_dir/params
+
+echo "Set payload length: $payload_len"
+echo "payload_length=$payload_len" > $dev_dir/params
+
+echo "Start packet generate"
+if [ $payload_num == -1 ]; then
+    echo "Send infinite packets"
+else
+    echo "Send $payload_num packets"
+fi
+sleep 0.5
+echo "start_packet_gen=$payload_num" > $dev_dir/params
+
+#while true; do busybox printf "."; sleep 1; done
+
+#stop_rftest
+
+exit 0
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/shared/descriptors.h b/drivers/net/wireless/rockchip_wlan/rk915/shared/descriptors.h
new file mode 100755
index 000000000..70a8be9fa
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/shared/descriptors.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _DESCRIPTOR_H_
+#define _DESCRIPTOR_H_
+
+#define NUM_ACS 5
+
+/* Control Path: 1 for CMD and 1 for EVENT */
+#define NUM_CTRL_DESCS	2
+
+/* Data Path */
+
+/* Reserved TX descriptors per AC
+ * (must be multiple of 2, minimum of 2
+ * and maximum of 4)
+ */
+
+#define NUM_TX_DESCS_PER_AC 2
+/* Spare Descriptors shared between all ACs
+ * (at least 1 and maximum of 2)
+ */
+#define NUM_SPARE_TX_DESCS 2	
+
+#define NUM_TX_DESCS ((NUM_ACS *  NUM_TX_DESCS_PER_AC) + NUM_SPARE_TX_DESCS)
+
+/* Max no of sub frames in an AMPDU */
+#define AMSDU_SUPPORT 0
+#if AMSDU_SUPPORT
+#define MAX_SUBFRAMES_IN_AMPDU_HT 8
+#else
+#define MAX_SUBFRAMES_IN_AMPDU_HT 8
+#endif
+#define MAX_FW_TX_PKGS (4*MAX_SUBFRAMES_IN_AMPDU_HT)
+
+
+#define NUM_RX_BUFS_2K	16
+#define NUM_RX_BUFS_12K	16
+
+#define RX_BUFS_12K_START 0
+#define RX_BUFS_12K_END  (RX_BUFS_12K_START + NUM_RX_BUFS_12K)
+
+#define RX_BUFS_2K_START NUM_RX_BUFS_12K
+#define RX_BUFS_2K_END   (RX_BUFS_2K_START +NUM_RX_BUFS_2K) 
+
+#endif /* _DESCRIPTOR_H_ */
+/* EOF */
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/shared/hal.h b/drivers/net/wireless/rockchip_wlan/rk915/shared/hal.h
new file mode 100755
index 000000000..c0b0c6e7d
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/shared/hal.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _HAL_H_
+#define _HAL_H_
+
+//#define TX_SG_MODE
+
+#define __IMG_PKD  __attribute__((packed))
+
+#define HAL_INT_CMD_MAX_RX 16
+#define HAL_INT_EVENT_MAX_RX 16
+
+#define MAX_DATA_SIZE_12K (12 * 1024)
+#define MAX_DATA_SIZE_8K (8 * 1024)
+#define MAX_DATA_SIZE_2K (2 * 1024)
+
+#define NUM_TX_DESC 12
+#define NUM_FRAMES_IN_TX_DESC 32
+#define SHAREDMEM_BUFF_SIZE             ((HAL_SHARED_MEM_MAX_MSG_SIZE * 2))
+
+#define HAL_PRIV_DATA_SIZE 8
+
+#define HAL_SHARED_MEM_MAX_MSG_SIZE 60
+
+#define MSG_STATUS_OFFSET 4
+#define MSG_LEN_OFFSET 8
+
+/* Command, Event, Tx Data and Buff mappping offsets */
+#define HAL_COMMAND_OFFSET (0)
+#define HAL_GRAM_CMD_START HAL_COMMAND_OFFSET
+#define HAL_GRAM_CMD_STATUS HAL_COMMAND_OFFSET + MSG_STATUS_OFFSET
+#define HAL_GRAM_CMD_LEN HAL_GRAM_CMD_START + MSG_LEN_OFFSET
+
+#define HAL_EVENT_OFFSET (HAL_COMMAND_OFFSET + HAL_SHARED_MEM_MAX_MSG_SIZE)
+#define HAL_GRAM_EVENT_START HAL_EVENT_OFFSET
+#define HAL_GRAM_EVENT_STATUS HAL_EVENT_OFFSET + MSG_STATUS_OFFSET
+#define HAL_GRAM_EVENT_LEN HAL_EVENT_OFFSET + MSG_LEN_OFFSET
+
+
+
+/**
+ * struct hal_hdr - Header accompanying each message exchanged between the Host
+ *                  and Firmware.
+ * @id: Used to differentiate between a HAL(Host)<->HAL(Firmware) message
+ *      (0xFFFFFFFF) vs UMAC(Host)<->LMAC(FW) message (0x00000000).
+ * @unused: Unused.
+ *
+ * This structure contains the header information which needs to be prepended to
+ * each message exchanged between the Host and the Firmware. The @id field is
+ * used to differentiate between HAL messages (i.e. messages meant to
+ * be processed only within the Host HAL or Firmware HAL) vs MAC messages
+ * (i.e. messages which the Host/Firmware HAL will forward to the next layer
+ * for further processing).
+ */
+struct hal_hdr {
+	unsigned int id;
+	unsigned int unused;
+} __IMG_PKD;
+
+/**
+ * struct hal_rx_pkt_info - Structure which contains information about a RX
+ *                          buffer allocated by the Host.
+ * @desc: Descriptor ID of the RX buffer.
+ * @ptr: DMAable address of the RX buffer.
+ *
+ * This structure is used to describe a RX buffer allocated in the Host memory
+ * where the RPU can DMA an incoming RX frame.
+ */
+struct hal_rx_pkt_info {
+	/* Rx descriptor */
+	unsigned int desc;
+	unsigned int ptr;
+} __IMG_PKD;
+
+/**
+ * struct hal_rx_command - Structure which describes collection of RX buffers.
+ * @rx_pkt_cnt: The number of RX buffers described.
+ * @rx_pkt: Information (as described by @hal_rx_pkt_info) for multiple RX
+ *          buffers.
+ *
+ * This structure aggregates information (as described by @hal_rx_pkt_info) for
+ * multiple RX buffers, so that they can be sent in a single command to the
+ * RPU.
+ */
+struct hal_rx_command {
+	unsigned int rx_pkt_cnt;
+	struct hal_rx_pkt_info rx_pkt[HAL_INT_CMD_MAX_RX];
+} __IMG_PKD;
+
+/**
+ * struct cmd_hal - Command used by Host HAL to convey information about RX
+ *                  buffers to the RPU HAL.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       0xFFFFFFFF).
+ * @rx_pkt_data: Information (as described by @hal_rx_command) for multiple RX
+ *               buffers.
+ *
+ * This command is used to program information about RX buffers by the Host HAL
+ * to the RPU HAL. The information needs to be programmed in 2 instances:
+ *   a) Initialization:  This is when the initial pool of RX buffers is
+ *                       allocated and the information about these buffers
+ *                       needs to be communicated to the RPU.
+ *   b) Refilling: This will happen when we receive the HAL event @event_hal
+ *                 which has information about one or more RX frames (as
+ *                 indicated by the @rx_pkt_cnt member of the event @event_hal)
+ *                 that have been DMAed by the RPU to the Host in the RX
+ *                 buffers from the existing pool. These buffers now need to be
+ *                 replaced by fresh buffers for further RX frames and the
+ *                 information about these fresh buffers needs to be
+ *                 communicated to the RPU.
+ */
+struct cmd_hal {
+	struct hal_hdr hdr;
+	struct hal_rx_command rx_pkt_data;
+} __IMG_PKD;
+
+/**
+ * struct event_hal - Structure which contains information about RX
+ *                    buffers which the RPU has consumed (by DMAing to them).
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       0xFFFFFFFF).
+ * @rx_pkt_cnt: The number of RX frames received.
+ * @rx_pkt_desc: Descriptor ID's of the RX buffers where the RX frames have
+ *               been DMAed.
+ * @rx_pkt_len: Length of the Payload for each incoming RX frame.
+ * @rx_align_offset: The offset of payload from the DMA start address.
+ *                   (needed to align Qos data).
+ *
+ * This event is used by the Firmware HAL to inform the Host HAL about the RX
+ * frames that have been received and DMAed to the buffers in the RX buffer
+ * pool. This event can convey information about one or more RX frames at a
+ * time. The information conveyed is in the form of Descriptor ID's of the RX
+ * buffers (which the Host had programmed to the RPU using @cmd_hal). The Host
+ * can then use the Descriptor ID's as an index to retrieve the RX buffer
+ * information (as described by @buf_info) from a mapping table that it
+ * maintains internally.
+ */
+struct event_hal {
+	struct hal_hdr hdr;
+	unsigned int rx_pkt_cnt;
+	unsigned int rx_pkt_desc[HAL_INT_EVENT_MAX_RX];
+} __IMG_PKD;
+
+#endif /* _HAL_H_ */
+
+/* EOF */
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/shared/host_rpu_if.h b/drivers/net/wireless/rockchip_wlan/rk915/shared/host_rpu_if.h
new file mode 100755
index 000000000..6c74ad1e4
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/shared/host_rpu_if.h
@@ -0,0 +1,1811 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _HOST_RPU_IF_H_
+#define _HOST_RPU_IF_H_
+
+#include "hal.h"
+
+#define MCST_ADDR_LIMIT	48
+#define WLAN_ADDR_LEN 6
+#define TKIP_MIC_LEN 8
+#define MICHAEL_LEN 16
+#define MAX_KEY_LEN 16
+#define MAX_VIFS 2
+
+#define MAX_PEERS 15
+/* Additional queue for unicast frames directed to non-associated peers (for
+ * e.g. Probe Responses etc)
+ */
+#define MAX_PEND_Q_PER_AC (MAX_PEERS + MAX_VIFS)
+
+
+#define WEP40_KEYLEN 5
+#define WEP104_KEYLEN 13
+#define MAX_WEP_KEY_LEN 13
+
+#define WLAN_20MHZ_OPERATION 0
+#define WLAN_40MHZ_OPERATION 1
+#define WLAN_80MHZ_OPERATION 2
+#define WLAN_SEC_UPPER 0
+#define WLAN_SEC_LOWER 1
+
+#define PWRSAVE_STATE_AWAKE 1
+#define PWRSAVE_STATE_DOZE 0
+
+/* because rpu do not support multi ssid scan now,
+ * we now split multi ssid scan to several single ssid scan
+ */
+#define ENABLE_SPLIT_MULT_SSID_SCAN
+
+#define MAX_SSID_LEN 32
+#ifdef ENABLE_SPLIT_MULT_SSID_SCAN
+#define MAX_NUM_SSIDS 4
+#else
+#define MAX_NUM_SSIDS 1
+#endif
+#define TOTAL_KEY_LEN 32
+#define RX_SEQ_SIZE 6
+#define MAX_IE_LEN 100
+#define ETH_ALEN 6
+
+#define MAX_TX_CMDS 16
+#define MAX_GRAM_PAYLOAD_LEN 52
+
+#define RF_PARAMS_SIZE	369
+#define MAX_RF_CALIB_DATA 900
+
+
+enum rpu_channel_bw {
+	RPU_CHAN_WIDTH_20_NOHT,
+	RPU_CHAN_WIDTH_20 = RPU_CHAN_WIDTH_20_NOHT,
+};
+/**
+ * enum UMAC_QUEUE_NUM - Queues used to transmit frames.
+ * @WLAN_AC_BK: Queue for frames belonging to the "Background" Access Category.
+ * @WLAN_AC_BE: Queue for frames belonging to the "Best-Effort" Access Category.
+ * @WLAN_AC_VI: Queue for frames belonging to the "Video" Access Category.
+ * @WLAN_AC_VO: Queue for frames belonging to the "Voice" Access Category.
+ * @WLAN_AC_BCN: Queue for frames belonging to the "Beacon" Access Category.
+ * @WLAN_AC_MAX_CNT: Maximum number of transmit queues supported.
+ *
+ * This enum represents the queues used to segregate the TX frames depending on
+ * their QoS categories. A separate queue is used for Beacon frames / frames
+ * transmitted during DTIM intervals.
+ */
+enum UMAC_QUEUE_NUM {
+	WLAN_AC_BK = 0,
+	WLAN_AC_BE,
+	WLAN_AC_VI,
+	WLAN_AC_VO,
+	WLAN_AC_BCN,
+	WLAN_AC_MAX_CNT
+};
+
+/**
+ * enum RPU_EVENT_ROC_STAT - Status of the Remain-On-Channel(ROC) operation.
+ * @UMAC_ROC_STAT_STARTED: ROC has started.
+ * @UMAC_ROC_STAT_STOPPED: ROC was stopped.
+ * @UMAC_ROC_STAT_DONE: ROC completed.
+ * @UMAC_ROC_STAT_ABORTED: ROC was aborted.
+ *
+ * This enum represents the different states in which a ROC operation can be in.
+ * ROC is applicable only for P2P Mode.
+ */
+enum RPU_EVENT_ROC_STAT {
+	UMAC_ROC_STAT_STARTED,
+	UMAC_ROC_STAT_STOPPED,
+	UMAC_ROC_STAT_DONE,
+	UMAC_ROC_STAT_ABORTED
+};
+
+/**
+ * enum UMAC_VIF_CHANCTX_TYPE - Types of channel contexts.
+ * @UMAC_VIF_CHANCTX_TYPE_OPER: Operating channel context.
+ * @UMAC_VIF_CHANCTX_TYPE_OFF: Off-channel context.
+ * @MAX_UMAC_VIF_CHANCTX_TYPES: Maximum number of channel context types.
+ *
+ * This enum represents the different types of channel contexts that are
+ * possible during a concurrent multichannel operation. At any point of time a
+ * channel context can be either of the type "Operating" or "Off-channel"
+ */
+enum UMAC_VIF_CHANCTX_TYPE {
+	UMAC_VIF_CHANCTX_TYPE_OPER,
+	UMAC_VIF_CHANCTX_TYPE_OFF,
+	MAX_UMAC_VIF_CHANCTX_TYPES
+};
+
+/**
+ * enum RPU_SLEEP_CONFIG_CHANGED - Flags to indicate what changed in Sleep
+				Controller configuration.
+
+ * @PMFLAG_PWR_ON_VALUE_CHANGED - UCC_SLEEP_CTRL_PWR_ON_VALUE 
+ * @PMFLAG_PWR_OFF_VALUE_CHANGED - UCC_SLEEP_CTRL_PWR_OFF_VALUE
+ * @PMFLAG_RAM_ON_STATE_CHANGED - UCC_SLEEP_CTRL_PWR_OFF_VALUE
+ * @PMFLAG_RAM_OFF_STATE_CHANGED - UCC_SLEEP_CTRL_RAM_OFF_STATE
+ * @PMFLAG_PWR_ON_TIME_CHANGED - UCC_SLEEP_CTRL_PWR_ON_TIME 
+ * @PMFLAG_PWR_OFF_TIME_CHANGED - UCC_SLEEP_CTRL_PWR_OFF_TIME 
+ * @PMFLAG_RAM_ON_TIME_CHANGED - UCC_SLEEP_CTRL_RAM_ON_TIME 
+ * @PMFLAG_RAM_OFF_TIME_CHANGED - UCC_SLEEP_CTRL_RAM_OFF_TIME 
+ * @PMFLAG_SLEEP_FREQ_CHANGED - sleep_timer_freq_hz
+ */
+
+
+enum RPU_SLEEP_CONFIG_CHANGED {
+	PMFLAG_PWR_ON_VALUE_CHANGED  =  0x0001,  
+	PMFLAG_PWR_OFF_VALUE_CHANGED =  0x0002,  
+	PMFLAG_RAM_ON_STATE_CHANGED  =  0x0004,  
+	PMFLAG_RAM_OFF_STATE_CHANGED =  0x0008,  
+	PMFLAG_PWR_ON_TIME_CHANGED   =  0x0010,  
+	PMFLAG_PWR_OFF_TIME_CHANGED  =  0x0020,  
+	PMFLAG_RAM_ON_TIME_CHANGED   =  0x0040,  
+	PMFLAG_RAM_OFF_TIME_CHANGED  =  0x0080,  
+	PMFLAG_SLEEP_FREQ_CHANGED    =  0x0100,   
+	PMFLAG_CLK_ADJ_VAL_CHANGED   =	0x0200,
+	PMFLAG_WAKEUP_TIME_CHANGED   =	0x8000,
+};
+
+/**
+ * enum RPU_CMD_TAG - Commands that the Host can send to the Firmware.
+ * @RPU_CMD_RESET: Used to reset/initialize the Firmware
+ * @RPU_CMD_SCAN: Used to initiate a hardware SCAN operation.
+ * @RPU_CMD_SCAN_ABORT: Used to abort a scan request raised previously from
+ *                       host.
+ * @RPU_CMD_UNUSED1: Unused.
+ * @RPU_CMD_SETKEY: Used to program relevant security keys depending on the
+ *                   security mode enabled.
+ * @RPU_CMD_UNUSED2: Unused.
+ * @RPU_CMD_UNUSED3: Unused.
+ * @RPU_CMD_TX: Used to transmit a frame (MPDU/A-MPDU).
+ * @RPU_CMD_UNUSED4: Unused.
+ * @RPU_CMD_UNUSED5: Unused.
+ * @RPU_CMD_TX_POWER: Used to specify maximum transmit power.
+ * @RPU_CMD_UNUSED6: Unused.
+ * @RPU_CMD_UNUSED7: Unused.
+ * @RPU_CMD_PS: Used to enable/disable WLAN powersave.
+ * @RPU_CMD_PS_ECON_CFG: Used to enable/disable Economy mode.
+ * @RPU_CMD_VIF_CTRL: Used to add or remove a virtual interface.
+ * @RPU_CMD_UNUSED8: Unused.
+ * @RPU_CMD_UNUSED9: Unused.
+ * @RPU_CMD_BA_SESSION_INFO: Used to pass Block ACK parameters to firmware.
+ * @RPU_CMD_MCST_ADDR_CFG: Used to add or remove a multicast address to the
+ *                          firmware.
+ * @RPU_CMD_MCST_FLTR_CTRL: Used to enable/disable multicast filtering in the
+ *                           firmware.
+ * @RPU_CMD_VHT_BEAMFORM_CTRL: Used to pass beamforming related parameters to
+ *                              the firmware.
+ * @RPU_CMD_ROC_CTRL: Used to pass the Remain-On-Channel(ROC) related
+ *                     information to firmware
+ * @RPU_CMD_CHANNEL: Used to program a channel to the firmware.
+ * @RPU_CMD_VIF_CFG: Used to change configuration parameters for an interface.
+ * @RPU_CMD_UNUSED10: Unused.
+ * @RPU_CMD_TXQ_PARAMS: Used to set transmission queue parameters.
+ * @RPU_CMD_MIB_STATS: Used to get MIB stats.
+ * @RPU_CMD_PHY_STATS: Used to get PHY stats.
+ * @RPU_CMD_UNUSED11: Unused.
+ * @RPU_CMD_AUX_ADC_CHAIN_SEL: Used to set AUX path in the PHY.
+ * @RPU_CMD_DETECT_RADAR: Used to start/stop Radar detection operation.
+ * @RPU_CMD_UNUSED12: Unused.
+ * @RPU_CMD_UNUSED13: Unused.
+ * @RPU_CMD_MEASURE: Used to initiate a measurement on a channel.
+ * @RPU_CMD_BT_INFO: Used to provide Bluetooth related information to
+ *                    the Firmware.
+ * @RPU_CMD_CLEAR_STATS: Used to clear all the previous MAC and PHY stats.
+ * @RPU_CMD_CHANCTX_TIME_INFO: Used to communicate information about
+ *                              percentage occupancy of each channel during
+ *                              Concurrent Multichannel operation.
+ * @RPU_CMD_CONT_TX: Used in Production mode for continuous transmission tests.
+ * @RPU_CMD_TX_DEINIT: Used to deinitialize the transmit path per peer on a
+ *                      particular interface (or) per interface during
+ *                      disconnection of peer (or) interface de-initialization.
+ * @RPU_CMD_RX_CTRL: Used to enable/disable RX path in LMAC (currently unused).
+ * @RPU_CMD_CFG_PWRMGMT: Used to configure RPU Sleep Controller.
+ *
+ * This enum contains the different commands which the Host can use to send to
+ * the Firmware to carry out an operation like configuration, executing an
+ * action, requesting some information etc.
+ */
+enum RPU_CMD_TAG {
+	RPU_CMD_RESET = 0,
+	RPU_CMD_SCAN,
+	RPU_CMD_SCAN_ABORT,
+	RPU_CMD_UNUSED1,
+	RPU_CMD_SETKEY,
+	RPU_CMD_UNUSED2,
+	RPU_CMD_UNUSED3,
+	RPU_CMD_TX,
+	RPU_CMD_UNUSED4,
+	RPU_CMD_UNUSED5,
+	RPU_CMD_TX_POWER,
+	RPU_CMD_UNUSED6,
+	RPU_CMD_UNUSED7,
+	RPU_CMD_PS,
+	RPU_CMD_PS_ECON_CFG,
+	RPU_CMD_VIF_CTRL,
+	RPU_CMD_UNUSED8,
+	RPU_CMD_UNUSED9,
+	RPU_CMD_BA_SESSION_INFO,
+	RPU_CMD_MCST_ADDR_CFG,
+	RPU_CMD_MCST_FLTR_CTRL,
+	RPU_CMD_UNUSED10,
+	RPU_CMD_ROC_CTRL,
+	RPU_CMD_CHANNEL,
+	RPU_CMD_VIF_CFG,
+	RPU_CMD_UNUSED11,
+	RPU_CMD_TXQ_PARAMS,
+	RPU_CMD_MIB_STATS,
+	RPU_CMD_PHY_STATS,
+	RPU_CMD_UNUSED12,
+	RPU_CMD_UNUSED13,
+	RPU_CMD_UNUSED14,
+	RPU_CMD_UNUSED15,
+	RPU_CMD_UNUSED16,
+	RPU_CMD_UNUSED17,
+	RPU_CMD_UNUSED18,
+	RPU_CMD_CLEAR_STATS,
+	RPU_CMD_CONT_TX,
+	RPU_CMD_RX_CTRL,
+	RPU_CMD_CFG_PWRMGMT,
+	RPU_CMD_UPD_PHY_THRESH,
+	RPU_CMD_TXRX_TEST,
+	RPU_CMD_FW_PRIV_CMD,
+	RPU_CMD_SL_WP_CTRL,
+	RPU_CMD_READ_CSR,
+	RPU_MAX_CMD_NUMBER
+};
+
+#define RPU_CMD_PATCH_FEATURES 100
+#define RPU_CMD_IP_ADDRESS     101
+#define RPU_CMD_MISC_CFG 200
+
+/**
+ * enum RPU_EVENT_TAG - Events that the firmware can send to the Host.
+ * @RPU_EVENT_RX: Indicates a packet has been received.
+ * @RPU_EVENT_TX_DONE: Indicates completion of a TX request.
+ * @RPU_EVENT_DISCONNECTED: Indicates a disconnection with the peer
+ *                           detected by RPU.
+ * @RPU_EVENT_UNUSED1: Unused.
+ * @RPU_EVENT_UNUSED2: Unused.
+ * @RPU_EVENT_SCAN_COMPLETE: Indicates completion of a scan request.
+ * @RPU_EVENT_SCAN_ABORT_COMPLETE: Indicates completion of a scan abort
+ *                                  request.
+ * @RPU_EVENT_UNUSED3: Unused.
+ * @RPU_EVENT_RESET_COMPLETE: Indicates completion of a reset command.
+ * @RPU_EVENT_UNUSED4: Unused.
+ * @RPU_EVENT_UNUSED5: Unused.
+ * @RPU_EVENT_UNUSED6: Unused.
+ * @RPU_EVENT_MIB_STAT: Used to return MIB statistics.
+ * @RPU_EVENT_PHY_STAT: Used to return PHY statistics.
+ * @RPU_EVENT_NW_FOUND: Unused.
+ * @RPU_EVENT_NOA: Indicates start/stop of Notice-Of-Absence period by the
+ *                  connected P2P-GO.
+ * @RPU_EVENT_CTRL_POOL_ACK: Unused.
+ * @RPU_EVENT_COMMAND_PROC_DONE: Indicates completion of the processing of a
+ *                                command (except RPU_CMD_RESET and
+ *                                RPU_CMD_TX).
+ * @RPU_EVENT_CH_PROG_DONE: Signals completion of the processing of the channel
+ *                           programming command.
+ * @RPU_EVENT_PS_ECON_CFG_DONE: Indicates completion of the processing of the
+ *                               Economy mode configuration command.
+ * @RPU_EVENT_PS_ECON_WAKE: Indicates a wakeup event when in Economy mode.
+ * @RPU_EVENT_MAC_STATS: Used to return MAC statistics.
+ * @RPU_EVENT_RF_CALIB_DATA: Used to return calibration data to the Host.
+ * @RPU_EVENT_RADAR_DETECTED: Indicates Radar detection event.
+ * @RPU_EVENT_MSRMNT_COMPLETE: Unused.
+ * @RPU_EVENT_ROC_STATUS: Informs Host about status of a Remain-On-Channel
+ *                         operation.
+ * @RPU_EVENT_CHAN_SWITCH: Informs Host about a channel switch during
+ *                          concurrent multichannel operation.
+ * @RPU_EVENT_FW_ERROR: Firmware error.
+ * @RPU_EVENT_TX_DEINIT_DONE: Informs Host about the status of a TX
+ *                             deinitialization operation initiated by the Host.
+ *
+ * This enum represents the different types of events that the Firmware can
+ * return to the Host. The events are used to communicate information like
+ * status of command processing issue by the Host, return various statistics, or
+ * some asynchronous events that the Host might be interested in.
+ */
+enum RPU_EVENT_TAG {
+	RPU_EVENT_RX = 0,
+	RPU_EVENT_TX_DONE,
+	RPU_EVENT_DISCONNECTED,
+	RPU_EVENT_UNUSED1,
+	RPU_EVENT_UNUSED2,
+	RPU_EVENT_SCAN_COMPLETE,
+	RPU_EVENT_SCAN_ABORT_COMPLETE,
+	RPU_EVENT_UNUSED3,
+	RPU_EVENT_RESET_COMPLETE,
+	RPU_EVENT_UNUSED4,
+	RPU_EVENT_UNUSED5,
+	RPU_EVENT_UNUSED6,
+	RPU_EVENT_MIB_STAT,
+	RPU_EVENT_PHY_STAT,
+	RPU_EVENT_NW_FOUND,
+	RPU_EVENT_NOA,
+	RPU_EVENT_CTRL_POOL_ACK,
+	RPU_EVENT_COMMAND_PROC_DONE,
+	RPU_EVENT_CH_PROG_DONE,
+	RPU_EVENT_PS_ECON_CFG_DONE,
+	RPU_EVENT_PS_ECON_WAKE,
+	RPU_EVENT_MAC_STATS,
+	RPU_EVENT_UNUSED7,
+	RPU_EVENT_UNUSED8,
+#ifndef RK915	
+	RPU_EVENT_MSRMNT_COMPLETE,
+#endif
+	RPU_EVENT_ROC_STATUS,
+	RPU_EVENT_FW_ERROR,
+	RPU_EVENT_BLOCK_ALL,
+	RPU_EVENT_UNBLOCK_ALL,
+	RPU_EVENT_FW_PRIV_CMD_DONE,
+	RPU_EVENT_TXRX_TEST,
+	RPU_EVENT_RX_SERIAS,
+	RPU_EVENT_AIRKISS_STATUS,
+	RPU_EVENT_READ_CSR_CMP,
+	RPU_MAX_EVENT_NUMBER
+};
+
+/**
+ * enum UMAC_TX_FLAGS - Flags to specify additional qualifiers for a transmit
+ *                      frame.
+ * @UMAC_TX_FLAG_OFFCHAN_FRM: Frame to transmitted on an Off-Channel.
+ *
+ * This enum represents the different qualifiers that can be specified for
+ * transmit frames.
+ */
+enum UMAC_TX_FLAGS {
+	UMAC_TX_FLAG_OFFCHAN_FRM
+};
+
+/**
+ * enum UMAC_PS_ECON_WAKE_TRIG - Triggers which can cause a wake-up during
+ *                               Economy mode operation.
+ * @TRIG_PKT_RCV: Wake-up due to frame reception.
+ * @TRIG_DISCONNECT: Wake-up due to a disconnection event.
+ *
+ * This enum represents the different triggers that can cause the wake-up after
+ * a sleep during Economy mode operation.
+ */
+enum UMAC_PS_ECON_WAKE_TRIG {
+	TRIG_PKT_RCV,
+	TRIG_DISCONNECT
+};
+
+/**
+ * enum POWER_SAVE_TAG - Options to enable/disable WLAN Power-Save.
+ * @AWAKE: Disable Power-Save.
+ * @SLEEP: Enable Power-Save.
+ *
+ * This enum represents the values that can be used to specify whether to
+ * enable/disable WLAN power-save.
+ */
+enum POWER_SAVE_TAG {
+	AWAKE = 0,
+	SLEEP
+};
+
+/**
+ * enum SCAN_TYPE_TAG - Different types of scanning operations.
+ * @PASSIVE: Passive scan.
+ * @ACTIVE: Active scan.
+ *
+ * This enum represents the different types of scanning operations.
+ */
+enum SCAN_TYPE_TAG {
+	PASSIVE = 0,
+	ACTIVE
+};
+
+/**
+ * struct hal_data - Hardware Abstraction Layer's (HAL) private data.
+ * @hal_data: This contains 8 bytes of information.
+ *
+ * Out of the 8 bytes of information contained in this structure the first 4
+ * bytes differentiate between a HAL command and UMAC command. The next 4 bytes
+ * are reserved for future use.
+ */
+struct hal_data {
+	unsigned char hal_data[HAL_PRIV_DATA_SIZE];
+} __IMG_PKD;
+
+/**
+ * struct host_rpu_msg_hdr - Header to be appended to all the Commands/Events
+ *                           between Host and Firmware.
+ * @hal_data: Hardware Abstraction Layer's (HAL) private data.
+ * @descriptor_id: The 2 LSB bytes are TX pool id, the 2 MSB bytes are queue
+ *                 number. Pool id of 0xffff indicates no TX payload.
+ * @payload_length: Payload length excluding MAC header bytes.
+ * @id: Host-FW Command/Event ID.
+ * @length: Size of Command/Event, applicable only for TX/RX.
+ *          For TX this is sizeof(cmd_tx_ctrl) and for RX this is
+ *          sizeof(wlan_rx_pkt).
+ * @more_cmd_data: The meaning of this bit depends on direction TX/RX
+ * 		   a) TX: it is used for commands whose size is greater than
+ *                    MAX_CMD_SIZE. (Set to 1, if command is split into two or
+ *                    more. Set to 0 otherwise).
+ *		   b) RX: it is used to indicated whether the incoming data is
+ *                    Qos/Non-qos, accordingly the data is processed.
+ *                    Needed for alignment of skb.
+ *
+ * This header contains control information about a Command/Event between Host
+ * and Firmware. This must be present in every Command/Event.
+ */
+struct host_rpu_msg_hdr {
+	struct hal_data hal_data;
+	unsigned int descriptor_id; /* LSB 2 bytes as pool id, MSB 2 bytes
+				     * queue num, pool ID of 0xFFFF indicates
+				     * no payload
+				     */
+	unsigned int payload_length;
+	unsigned int id;
+	unsigned int length;
+	unsigned int more_cmd_data;
+} __IMG_PKD;
+
+/**
+ * struct bgscan_params - Background Scan parameters.
+ * @enabled: Enable/Disable background scan.
+ * @channel_list: List of channels to scan.
+ * @channel_flags: Channel flags for each of the channels which are to be
+ *                 scanned.
+ * @scan_intval: Back ground scan is done at regular intervals. This
+ *               value is set to the interval value (in ms).
+ * @channel_dur: Time to be spent on each channel (in ms).
+ * @serv_channel_dur: In "Connected State" scanning, we need to share the time
+ *                    between operating channel and non-operating channels.
+ *                    After scanning each channel, the firmware spends
+ *                    "serv_channel_dur" (in ms) on the operating channel.
+ * @num_channels: Number of channels to be scanned.
+ *
+ * This structure specifies the parameters which will be used during a
+ * Background Scan.
+ */
+struct bgscan_params {
+	unsigned int enabled;
+	unsigned char channel_list[50];
+	unsigned char channel_flags[50];
+	unsigned int scan_intval;
+	unsigned int channel_dur;
+	unsigned int serv_channel_dur;
+	unsigned int num_channels;
+} __IMG_PKD;
+
+/**
+ * struct ssid - Structure to describe an SSID.
+ * @len: Length of the SSID.
+ * @ssid: SSID character buffer; according to IEEE it is of size varying
+ *        from 1- 32.
+ *
+ * This structure is used to specify an Service Set Identifier (SSID).
+ */
+struct ssid {
+	unsigned int len;
+	unsigned char ssid[MAX_SSID_LEN];
+} __IMG_PKD;
+
+
+
+/* Commands */
+
+/**
+  * struct cmd_txrx_test - Command used for tx rx stability test.
+  */
+struct cmd_txrx_test {
+	struct host_rpu_msg_hdr hdr;
+#define TXRX_TEST_START_TX 0
+#define TXRX_TEST_TX 1
+#define TXRX_TEST_START_RX 2
+	unsigned int status;
+} __IMG_PKD;
+
+struct fw_reg_info {
+	unsigned int reg;
+	unsigned int val;
+	unsigned int len;
+#define READ_REG 0
+#define WRITE_REG 1
+#define READ_REG_LPW 2
+#define WRITE_REG_LPW 3
+	unsigned int rw;
+} __IMG_PKD;
+
+enum FW_PARAM_SEQ {
+	PARAM_ECHO_MODE = 0,
+	PARAM_EJTAG_MODE,
+	PARAM_DEBUG_LEVEL,
+	PARAM_DEBUG_FLAG,
+	PARAM_DIS_WIFI_ISR_THD,
+	PARAM_EN_WIFI_ISR_THD,
+};
+
+struct fw_params {
+	unsigned int mask;
+	unsigned char echo_mode;
+	unsigned char ejtag_mode;
+	unsigned char debug_level;
+	unsigned char debug_flag;
+	unsigned char dis_wifi_isr_thd;
+	unsigned char en_wifi_isr_thd;
+} __attribute__ ((__packed__));
+
+enum fw_priv_cmd_type{
+	DUMP_TXRX_COUNT_INFO = 1,
+	DUMP_TXRX_BUF_INFO,
+	DUMP_REG_INFO,
+	DUMP_FW_LOG,
+	DUMP_TXRX_QUEUE_INFO,
+	FW_PRIV_INIT,
+	DUMP_FW_VERSION,
+	FW_SET_PARAMS,
+	FW_GET_PARAMS,
+	DUMP_MEM_INFO,
+	DUMP_IF_INFO,
+	ADC_CAPTURE,
+	DUMP_ADC_CAPTURE_DATA,
+	ENABLE_SNIFFER,
+	FORCE_ASSERT,
+	DUMP_RF_CAL_DATA,
+	ENABLE_EJTAG = 100,
+};
+
+/**
+  * struct fw_priv_cmd - Command used for fw info dump.
+  */
+struct fw_priv_cmd {
+	struct host_rpu_msg_hdr hdr;
+#define DUMP_FW_CRASH_INFO			0x70616E63
+	unsigned int type;
+	struct fw_reg_info reg_info;
+	int production_test;
+	int fw_skip_rx_pkt_submit;
+	struct fw_params params;
+	/*
+	 * Value = 0 --> normal operation 
+	 * Value > 0 --> sniffer operation 
+	 * Value = 1 --> receive all data and managment frames - both unicast and broadcast 
+	 * Value = 2 --> receive broadcast data frames only 
+	 * Value = 3 --> receive broadcast and unciast data only 
+	 */
+	 /* sniffer & 0x000F ->  Sniffer mode specified below
+	     sniffer & 0x00F0 ->  Sniffer time interval when no broadcast info received(time unit 50ms)
+	     sniffer & 0x0F00 ->  Sniffer timer interval when broadcast info received(time unit 50ms)
+	  */
+	int sniffer;
+	/*
+	 * first byte of wlan0 and p2p mac address
+	 */
+	unsigned char wlan_mac_addr;
+	unsigned char p2p_mac_addr;
+} __IMG_PKD;
+
+/**
+  * struct cmd_set_phy_thresh - set phy threshholds
+  */
+struct cmd_update_phy_thresh {
+	struct host_rpu_msg_hdr hdr;
+	unsigned char tx_boost;
+	unsigned char ssd_enable;
+	unsigned char spare[2];
+	unsigned char thresholds[14];
+} __IMG_PKD;
+
+/**
+ * struct cmd_tx_ctrl - Command used by Host to program TX control information
+ *                      for 1 (A)MPDU to the Firmware for transmission.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_TX).
+ * @if_index: Virtual interface number this packet is tied to.
+ * @queue_num: The access category to which the frame belongs.
+ * @descriptor_id: Token ID of the transmitted frame.
+ * @num_frames_per_desc: Number of MPDU's to be sent in this command.
+ * @pkt_length: Packet length(s) of each MPDU being sent as part of this
+ *              command.
+ * @more_frms: Used in AP mode operation; while transmitting a packet to a
+ *             station which is in the power save mode, if the AP has more
+ *             data in destination's station queue, this field is set to 1;
+ *             0 in all other cases.
+ * @force_tx: If this field is set for any packet, it needs to be transmitted
+ *            even though TX has been disabled. This field is only meaningful
+ *            in DFS.
+ * @tx_flags: Flags to communicate special cases regarding the frame to the
+ *            Firmware
+ * @num_rates: Used to specify the number of possible rates a TX packet can
+ *             be transmitted at (Max 4 possible rates).
+ * @rate_protection_type: Per rate protection flags (RTS/CTS, CTS2SELF) set by
+ *                        the rate control algorithm (or) /proc interface.
+ * @rate_preamble_type: Per rate usage of short preamble as dictated by the rate
+ *                      control algorithm (or) /proc interface.
+ * @rate_retries: Number of times a packet should be transmitted at each
+ *                possible rate.  Ex {(1, 3),( 5.5, 2), (36,1) }, this
+ *                example is a set of (rate, rate_retries) couple with
+ *                num_rates as 3. This means, transmit a TX packet with 3
+ *                possible rates 1, 5.5 and  36. If the first rate is not
+ *                successful after trying 3 times, try the second rate twice.
+ *                If it is still failing it will try to transmit at rate 36
+ *                once.
+ * @rate: The rate value(s), at which the packet transmission needs to be
+ *        attempted as dictated by the rate control algorithm (or) /proc
+ *        interface.
+ * 	  If the most significant bit is one it's a 11n rate.
+ * @rate_flags: Per rate flags as dictated by the rate control algorithm
+ *              (or) /proc interface.
+ * @num_spatial_streams: Number of spatial streams to be used per rate as
+ *                       dictated by the rate control algorithm (or)
+ *                       /proc interface.
+ * @stbc_enabled: STBC enabled/disabled as dictated by the rate control
+ *                algorithm (or) /proc interface.
+ * @bcc_or_ldpc: FEC type as dictated by the rate control algorithm (or)
+ *               /proc interface.
+ * @aggregate_mpdu: In 11n, this field informs firmware whether to club
+ *                  the packet with other packets or not. For management,
+ *                  control and broadcast frames this field is not set.
+ *                  Currently if num_frames > 1, then this is set by default.
+ * @encrypt: If the frame is to be encrypted by RPU this is
+ *           set to 1 else this is 0.
+ * @config_mac_hdr_len: Length of the MAC header of the first MPDU in an AMPDU.
+ * @frame_source: Is the frame residing in GRAM or Ext-RAM. For all packets from
+ *                host Ext-ram is default. GRAM is purely for testing purposes.
+ * @config_mac_header: Complete MAC header of the first MPDU in an AMPDU.
+ * @frame_ddr_pointer: Starting Physical address of each frame in Ext-RAM
+ *                     after dma_mapping.
+ * @per_pkt_crypto_params: Crypto parameters (sequence control, QoS control, IV)
+ *                         per frame. Incremental to the MAC header sent above.
+ * @gram_payload: MAC headers of all the frames transmitted using this
+ *                command. (unused currently)
+ *
+ * This command is used to transmit a TX packet. A TX packet is divided into
+ * two parts:
+ *
+ * First part consists of TX control information, this also has
+ * complete 802.11 header of first packet (config_mac_header) and incremental
+ * information (per_pkt_crypto_params) per frame. This will be used to configure
+ * different blocks in RPU.
+ *
+ * Second part is 802.11 header and payload. This will directly streamed to
+ * PHY for transmission using DMA controller within RPU.
+ *
+ * TX done event is generated after completing packet transmission.
+ */
+struct cmd_tx_ctrl {
+	struct host_rpu_msg_hdr hdr;
+
+	/* VIF number this packet belongs to */
+	unsigned char if_index;
+
+	/* Queue no will be VO, VI, BE, BK and BCN */
+	unsigned char queue_num;
+
+	unsigned int descriptor_id;
+
+	/* number of frames in tx descriptors */
+	unsigned int num_frames_per_desc;
+
+	/*packet lengths of frames*/
+	unsigned int pkt_length[MAX_TX_CMDS];
+
+	/* If more number of frames buffered at UMAC */
+	unsigned char more_frms;
+
+	/* If this field is set for any packet,
+	 * need to be transmit even though TX has been disabled
+	 */
+	unsigned int force_tx;
+
+	/* Flags to communicate special cases regarding the frame to the FW */
+	unsigned int tx_flags;
+
+	unsigned char num_rates;
+
+#define USE_PROTECTION_NONE 0
+#define USE_PROTECTION_RTS 1
+#define USE_PROTECTION_CTS2SELF 2
+	unsigned char rate_protection_type[4];
+
+#define USE_SHORT_PREAMBLE 0
+#define DONT_USE_SHORT_PREAMBLE 1
+	unsigned char rate_preamble_type[4];
+
+	unsigned char rate_retries[4];
+
+#define MARK_RATE_AS_MCS_INDEX 0x80
+#define MARK_RATE_AS_RATE 0x00
+	unsigned char rate[4];
+
+#define ENABLE_SGI 0x04
+
+	unsigned char rate_flags[4];
+	unsigned char num_spatial_streams[4];
+	unsigned char stbc_enabled;
+	unsigned char bcc_or_ldpc;
+
+#define AMPDU_AGGR_ENABLED 0x00000001
+#define AMPDU_AGGR_DISABLED 0x00000000
+	unsigned char aggregate_mpdu;
+
+#define ENCRYPT_DISABLE 0
+#define ENCRYPT_ENABLE 1
+	unsigned char encrypt;
+	unsigned int config_mac_hdr_len;
+#define PKT_SRC_GRAM 1
+#define PKT_SRC_EXTRAM 0
+	unsigned char frame_source;
+#define MAC_HDR_SIZE 52
+	unsigned char config_mac_header[MAC_HDR_SIZE];
+	unsigned int frame_ddr_pointer[MAX_TX_CMDS];
+#define PER_PKT_CRYPTO_PARAMS_SIZE 12
+#define PER_PKT_CRYPTO_PARAMS_SEQ_CTRL_OFFSET 0
+#define PER_PKT_CRYPTO_PARAMS_QOS_CTRL_OFFSET 2
+#define PER_PKT_CRYPTO_PARAMS_IV_OFFSET 4
+
+	unsigned char per_pkt_crypto_params[MAX_TX_CMDS]
+					   [PER_PKT_CRYPTO_PARAMS_SIZE];
+#ifdef TX_SG_MODE
+	unsigned char pad[59];
+#endif
+	unsigned int *p_frame_ddr_pointer[MAX_TX_CMDS];
+} __IMG_PKD;
+
+/**
+ * struct cmd_reset - Command used to (De-)initialize the Firmware.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_RESET).
+ * @type: Enable/Disable the firmware.
+ * @unused1: Unused.
+ * @unused2: Unused.
+ * @rf_params: RF calibration data derived using FTM.
+ * @unused3: Unused.
+ * @bg_scan: Background Scan parameters.
+ * @num_spatial_streams: Number of spatial streams.
+ * @system_rev: Unused.
+ * @lmac_mode: Normal/FTM mode.
+ * @antenna_sel: Antenna configuration, applicable only for 1x1.
+ *
+ * This command is used to enable/disable the WLAN. A RESET_COMPLETE
+ * event from the firmware indicates successful completion of this command.
+ * After sending the RESET, the host should not issue further commands until a
+ * RESET_COMPLETE is received.
+ */
+struct cmd_reset {
+	struct host_rpu_msg_hdr hdr;
+#define LMAC_ENABLE 0
+#define LMAC_DISABLE 1
+#define LMAC_DO_CALIB 0x0010 /* do RF calibration */
+#define LMAC_NO_SLEEP   0x0020  /* LMAC will never sleep */
+#define LOAD_FACTORY_CAL 0x0040
+	unsigned int type;
+        int unused1;
+        unsigned int unused2;
+	unsigned char rf_params[RF_PARAMS_SIZE];
+        unsigned int unused3;
+	struct bgscan_params bg_scan;
+	unsigned char num_spatial_streams;
+	unsigned int system_rev;
+#define LMAC_MODE_NORMAL 0
+#define LMAC_MODE_FTM 1
+	unsigned int lmac_mode;
+	unsigned int antenna_sel;
+	unsigned int reserv[2];
+} __IMG_PKD;
+
+/**
+ * struct cmd_scan - Command used to initiate a scan.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_SCAN).
+ * @if_index: Interface on which the scan is to be initiated.
+ * @type: Passive/Active scan.
+ * @n_channel: Total number of channels to scan; channel numbers will be
+ *             informed in the channel_list array. If n_channel value is 0, the
+ *             firmware scans all possible channels.
+ * @n_ssids: Number of SSIDs to scan; ssid information will be in the ssids
+ *           array. This should always be >= 1. In case of wild card SSID, this
+ *           value is 1 and the ssid_len of the first entry in the SSID list
+ *           should be specified as 0.
+ * @channel_list: List of channel numbers to scan. List can include from
+ *                channel number can be either 2.4GHz or 5GHz
+ * @chan_max_power: The maximum power limitation that can be used to send a
+ *                  packet in a specific channel from the channel_list array.
+ * @chan_flags: The scan type that can be used in a specific channel from the
+ *             channel_list array.
+ * @ssids: SSID list to scan.
+ * @p2p_probe: Set in case scan command is issued as part of a P2P search
+ *             operation. Unset for normal operation.
+ * @extra_ies_len: If there are any extra information elements that need to be
+ *                 part of probe request frames, extra_ies_len should be set to
+ *                 the length of those IEs.
+ * @extra_ies: As extra IEs can vary in size they are placed at the end of scan
+ *             command payload. extra_ies_len should be set to total length of
+ *             IEs contained in this field. Allocated memory should be of size
+ *             sizeof (Cmd_scan_t) + extra_ies_len.
+ *
+ * This command is used to initiate a scan. The frames received during scan
+ * are sent to UMAC (beacons (or) probe responses).
+ *
+ * RPU_EVENT_SCAN_COMPLETE event marks end of SCAN.
+ */
+struct cmd_scan {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int if_index;
+	enum SCAN_TYPE_TAG type;
+
+	/* Total number of channels to scan; channel numbers will be
+	 * informed in channel array. if n_channel value is zero,
+	 * UMAC scans all possible channels.
+	 */
+	unsigned int n_channel;
+
+	/* Number of SSIDs to scan; ssid information will be in ssid array.
+	 * This is always >= 1. In case of wild card SSID, this value is 1 and
+	 * the ssid_len of the first entry in the SSID list should be specifie
+	 * as 0
+	 */
+	unsigned int n_ssids;
+	unsigned char channel_list[50];
+	unsigned char chan_max_power[50];
+	unsigned char chan_flags[50];
+#ifdef ENABLE_SPLIT_MULT_SSID_SCAN	
+	struct ssid ssids[1];
+#else
+	struct ssid ssids[MAX_NUM_SSIDS];
+#endif
+	unsigned int p2p_probe;
+	unsigned int extra_ies_len;
+	unsigned char extra_ies[0];
+} __IMG_PKD;
+
+/**
+ * struct cmd_scan_abort - Command used to abort a scan.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_SCAN_ABORT).
+ * @if_index: Interface on which the scan is to be aborted.
+ *
+ * This command is used to abort a scan.
+ */
+struct cmd_scan_abort {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int if_index;
+} __IMG_PKD;
+
+/**
+ * struct cmd_setkey - Command used to set a security key.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_SETKEY).
+ * @if_index: Interface on which the key is to be set.
+ * @ctrl: Add/Delete the key.
+ * @key_type: Unicast/Broadcast key.
+ * @cipher_type: The cipher type for which the key is to be set.
+ * @key_id: Key index. Values (0-3) used for WEP; for other cases it can be any
+ *          value starting from zero.
+ * @key_len: Length of the key; value depends on security mechanism chosen.
+ * @rsc_len: Length of the Receive Sequence Counter value.
+ * @mac_addr: Peer station address for the respective key. In case of a group
+ *            key, it is set to a broadcast address, i.e. all 6 bytes are set
+ *            to 0xFF.
+ * @key: Encryption/Decryption key for Unicast/Multicast packets. Depends on
+ *       the key type.
+ * @rsc: Receive sequence count value.
+ *
+ * This command is used to program Pairwise/Group keys when
+ * corresponding security modes are enabled.
+ */
+struct cmd_setkey {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int if_index;
+#define KEY_CTRL_ADD 0
+#define KEY_CTRL_DEL 1
+	unsigned int ctrl;
+#define KEY_TYPE_UCAST 0
+#define KEY_TYPE_BCAST 1
+	unsigned int key_type;
+
+#define CIPHER_TYPE_WEP40 0
+#define CIPHER_TYPE_WEP104 1
+#define CIPHER_TYPE_TKIP 2
+#define CIPHER_TYPE_CCMP 3
+#define CIPHER_TYPE_WAPI 4
+	unsigned int cipher_type;
+	unsigned int key_id;
+	int key_len;
+	int rsc_len;
+	unsigned char mac_addr[ETH_ALEN];
+	unsigned char key[TOTAL_KEY_LEN];
+	unsigned char rsc[RX_SEQ_SIZE];
+} __IMG_PKD;
+
+/**
+ * struct cmd_tx_pwr - Command used to specify maximum transmit power.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_TX_POWER).
+ * @if_index: Interface on which the maximum transmit power is to be set.
+ * @tx_pwr: Maximum tranmit power value(in dBm).
+ *
+ * This command is used to specify the maximum transmit power on an interface.
+ * It takes values from 0-20 (in dBm) in the system level and any value in
+ * production tests.
+ */
+struct cmd_tx_pwr {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int if_index;
+	int tx_pwr;
+} __IMG_PKD;
+
+struct cmd_cfg_misc {
+    struct host_rpu_msg_hdr hdr;
+#define RPU_MISC_CFG_SNIFF_MODE_MASK 0x1	
+    unsigned int flags;  // set RPU_MISC_CFG_SNIFF_MODE_MASK bit
+#define RPU_MISC_CFG_SNIFF_MODE_NONE   0x0
+#define RPU_MISC_CFG_SNIFF_MODE_ALL    0x1
+#define RPU_MISC_CFG_SNIFF_MODE_BCAST  0x2
+#define RPU_MISC_CFG_SNIFF_MODE_BUCAST 0x3    
+    unsigned int sniff_mode; // set RPU_MISC_CFG_SNIFF_MODE_NONE/ALL/BCAST/BUCAST
+} __IMG_PKD;
+
+/**
+ * struct cmd_mcst_addr_cfg - Command used to add or remove a multicast address
+ *                            to the firmware.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_MCST_ADDR_CFG).
+ * @op: 0 to add a multicast address and 1 to remove it.
+ * @mac_addr: The multicast address to be added or removed.
+ *
+ * This command is used to add/remove a multicast address to the firmware. Used
+ * in conjunction wth the cmd_mcst_filter_ctrl for multicast filtering.
+ */
+struct cmd_mcst_addr_cfg {
+	struct host_rpu_msg_hdr hdr;
+	/* mcst_ctrl -
+	 * 0 -- ADD multicast address
+	 * 1 -- Remove multicast address
+	 */
+#define WLAN_MCAST_ADDR_ADD 0
+#define WLAN_MCAST_ADDR_REM 1
+	unsigned int op;
+	/* addr to add or delete..
+	 */
+	unsigned char mac_addr[6];
+} __IMG_PKD;
+
+/**
+ * struct cmd_mcst_filter_ctrl - Command used to enable/disable multicast
+ *                               filtering in the firmware.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_MCST_FLTR_CTRL).
+ * @ctrl: 0 to disable multicast filtering and 1 to enable it.
+ *
+ * This command is used to enable/disable multicast filtering in firmware. If
+ * multicast filtering is enabled, then multicast packets with MAC addresses
+ * added using RPU_CMD_MCST_ADDR_CFG are only allowed. If disabled all
+ * multicast packets are received by the host.
+ */
+struct cmd_mcst_filter_ctrl {
+	struct host_rpu_msg_hdr hdr;
+	/* ctrl -
+	 * 0 - disable multicast filtering in LMAC
+	 * 1 - enable multicast filtering in LMAC
+	 */
+#define MCAST_FILTER_DISABLE 0
+#define MCAST_FILTER_ENABLE 1
+	unsigned int ctrl;
+} __IMG_PKD;
+
+
+/**
+ * struct cmd_roc - Command used to pass the Remain-On-Channel(ROC) related
+ *                  information to firmware.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_ROC_CTRL).
+ * @roc_ctrl: Start/Stop ROC
+ * @roc_channel: The channel to be on during the ROC period.
+ * @roc_duration: Time to remain on channel during ROC.
+ * @roc_type: Normal/Offchannel-TX ROC.
+ *
+ * This command is used to start/stop a Remain-On-Channel(ROC) period. This is
+ * also used to define whether this is a normal or a offchannel-Tx type of ROC.
+ * ROC is applicable only for P2P Mode.
+ */
+struct cmd_roc {
+	struct host_rpu_msg_hdr hdr;
+#define ROC_STOP 0
+#define ROC_START 1
+	unsigned int roc_ctrl;
+	unsigned int roc_channel;
+	unsigned int roc_duration;
+#define ROC_TYPE_NORMAL 0
+#define ROC_TYPE_OFFCHANNEL_TX 1
+	unsigned int roc_type;
+} __IMG_PKD;
+
+/**
+ * struct cmd_ps - Command used to enable/disable WLAN power-save or Economy
+ *                 mode on an interface.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_PS/RPU_CMD_PS_ECON_CFG).
+ * @if_index: Interface index on which to configure the power-save.
+ * @mode: Enable/Disable power-save.
+ *
+ * This command is used to enable/disable wlan power-save on an interface.
+ * This command is only applicable for STA mode and will be ignored when not
+ * associated when it is not in an associated state.
+ */
+struct cmd_ps {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int if_index;
+	enum POWER_SAVE_TAG mode;
+} __IMG_PKD;
+
+/**
+ * struct cmd_vifctrl - Command used to add or remove a virtual interface.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_VIF_CTRL).
+ * @if_ctrl: Add/Remove interface.
+ * @if_index: Index for the interface to be added/removed.
+ * @mode: Operating mode of the interface.
+ * @mac_addr: MAC address for the interface.
+ *
+ * This command is used to add/remove a virtual interface. The number of
+ * interfaces supported is limited to MAX_VIFS.
+ */
+struct cmd_vifctrl {
+	struct host_rpu_msg_hdr hdr;
+	/* if_ctrl -
+	 * 0 - add interface address
+	 * 1 - remove interface address
+	 */
+#define IF_ADD 1
+#define IF_REM 2
+
+	unsigned int if_ctrl;
+	unsigned int if_index;
+	/* Interface mode -
+	 * 0 - STA in infrastucture mode
+	 * 1 - STA in AD-HOC mode
+	 * 2 - AP
+	 */
+#define IF_MODE_STA_BSS 0
+#define IF_MODE_STA_IBSS 1
+#define IF_MODE_AP 2
+#define IF_MODE_INVALID 3
+
+	unsigned int mode;
+	unsigned char mac_addr[ETH_ALEN];
+} __IMG_PKD;
+
+/**
+ * struct cmd_ht_ba - Command used to pass Block ACK parameters to firmware.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_BA_SESSION_INFO).
+ * @if_index: Index for the interface on which the BA parameters are to be
+ *            set.
+ * @op: BA session start/stop.
+ * @tid: BA session traffic identifier.
+ * @ssn: BA session startin sequence number.
+ * @policy: BA policy (0 - Immediate BA, 1 - Delayed BA).
+ * @vif_addr: MAC address of the virtual interface.
+ * @peer_addr: MAC address of the peer with whom the BA session is to be
+ *             established.
+ *
+ * This command is used to pass Block ACK parameters to the firmware. This is
+ * needed during the setting up of a RX A-MPDU aggregation session.
+ */
+struct cmd_ht_ba {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int if_index;
+#define BLOCK_ACK_SESSION_STOP 0
+#define BLOCK_ACK_SESSION_START 1
+	unsigned int op;
+	unsigned int tid;
+	unsigned int ssn;
+	unsigned int policy;
+	unsigned char vif_addr[ETH_ALEN];
+	unsigned char peer_addr[ETH_ALEN];
+} __IMG_PKD;
+
+/**
+ * struct cmd_channel - Command used to program a channel to the firmware.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_CHANNEL).
+ * @channel_bw: Bandwidth of the channel being configured (20/40/80/160 MHz).
+ * @primary_ch_number: Center frequency of the primary channel.
+ * @channel_number1: Center frequency of the total band, if total band is
+ *                   contiguous. For non-contiguous bands, this is the center
+ *                   frequency of the first band.
+ * @channel_number2: Center frequency of the secondary band. Valid in an 80+80
+ *                   band, to be set to 0 for other cases.
+ * @freq_band: The band (2.4/5 GHz) to which the channel belongs.
+ * @vif_index: Index of the virtual interface on which channel is to be set.
+ *
+ * This command is used to program a channel to the firmware. An
+ * RPU_EVENT_CH_PROG_DONE event from the firmware indicates completion of
+ * the channel programming.
+ */
+struct cmd_channel {
+	struct host_rpu_msg_hdr hdr;
+	enum rpu_channel_bw channel_bw;
+	unsigned int primary_ch_number;
+	/* Center frequency of total band, if total band is contiguous.
+	 * First band center frequency for non contiguous bands,
+	 */
+	unsigned int channel_number1;
+	/* center frequecny of secondary band.
+	 * This is valid in 80+80 band set to zero for other cases
+	 */
+	unsigned int channel_number2;
+	/* 0 - 2.4ghz
+	 * 1 - 5ghz
+	 */
+	unsigned int freq_band;
+} __IMG_PKD;
+
+/**
+ * struct cmd_vif_cfg - Command used to change configuration parameters for an
+ *                      interface.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_VIF_CFG).
+ * @changed_bitmap: Bitmap of the parameters that have changed.
+ * @basic_rate_set: Bitmap of supported basic rates.
+ * @use_short_slot: Set to use short slot, unset to use long slot.
+ * @atim_window: Adhoc Traffic Indication Map window.
+ * @aid: Association ID, useful in recognizing the buffered packets at AP when
+ *       station is in power save.
+ * @capability: The latest capability information to be programmed to firmware,
+ *              when capabilities have changed.
+ *
+ * @short_retry: Number of retries to be tried for "short" frames (used only
+ *               for the packets initiated by LMAC).
+ * @long_retry: Number of retries to be tried for "long" frames (used only
+ *               for the packets initiated by LMAC).
+ * @bcn_mode: Beacon filtering mode.
+ * @dtim_period: This value is in terms of multiple of beacon intervals.
+ *               A station in power save mode should wake up from sleep and
+ *               listen to DTIM beacons.
+ * @beacon_interval: This field informs the beacon sending time(in ms).
+ *                   Useful in AP /IBSS mode
+ * @if_index: Index of the interface on which the parameters are to be
+ *            configured.
+ * @vif_addr: MAC address of the interface.
+ * @bssid: BSSID of the network.
+ * @smps_info: Used to configure SMPS information (SMPS enabled/SMPS mode)
+ * @connect_state: Connection status (connected/disconnected) of the interface.
+ * @op_channel: Operating channel of the interface.
+ *
+ * This Command used to program configuration parameters like basic rate set,
+ * power save mode etc. in the firmware, for an interface. This command is
+ * issued by the Host driver, whenever configuration parameters are changed.
+ */
+struct cmd_vif_cfg {
+	struct host_rpu_msg_hdr hdr;
+
+	/* Bitmap indicating whether value is changed or not */
+#define BASICRATES_CHANGED (1<<0)
+#define SHORTSLOT_CHANGED (1<<1)
+#define POWERSAVE_CHANGED (1<<2) /* to be removed */
+#define UAPSDTYPE_CHANGED (1<<3) /* to be removed */
+#define ATIMWINDOW_CHANGED (1<<4)
+#define AID_CHANGED (1<<5)
+#define CAPABILITY_CHANGED (1<<6)
+#define SHORTRETRY_CHANGED (1<<7)
+#define LONGRETRY_CHANGED (1<<8)
+#define BSSID_CHANGED (1<<9)
+#define RCV_BCN_MODE_CHANGED (1<<10)
+#define BCN_INT_CHANGED (1<<11)
+#define DTIM_PERIOD_CHANGED (1<<12)
+#define SMPS_CHANGED (1<<13)
+#define CONNECT_STATE_CHANGED (1<<14)
+#define OP_CHAN_CHANGED (1<<15)
+
+	unsigned int changed_bitmap;
+
+	/* bitmap of supported basic rates
+	 */
+	unsigned int basic_rate_set;
+
+	/* slot type -
+	 * 0 - long slot
+	 * 1 - short slot
+	 */
+	unsigned int use_short_slot;
+
+	/* ATIM window */
+	unsigned int atim_window;
+
+	unsigned int aid;
+
+	unsigned int capability;
+
+	unsigned int short_retry;
+
+	unsigned int long_retry;
+
+#define RCV_ALL_BCNS 0
+#define RCV_ALL_NETWORK_ONLY 1
+#define RCV_NO_BCNS 2
+
+	unsigned int bcn_mode;
+
+	unsigned char dtim_period;
+
+	unsigned int beacon_interval;
+
+	/* index of the intended interface */
+	unsigned int if_index;
+	unsigned char vif_addr[ETH_ALEN];
+
+	/* bssid of interface */
+	unsigned char bssid[ETH_ALEN];
+
+	/* SMPS Info
+	 *
+	 * bit0 - 0 - Disabled, 1 - Enabled
+	 * bit1 - 0 - Static,   1 - Dynamic
+	 *
+	 */
+#define SMPS_ENABLED BIT(0)
+#define SMPS_MODE BIT(1)
+	unsigned char smps_info;
+
+#define STA_CONN 0
+#define STA_DISCONN 1
+	unsigned char connect_state;
+	unsigned char op_channel;
+} __IMG_PKD;
+
+/**
+ * struct cmd_txq_params - Command used to set transmission queue parameters.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_TXQ_PARAMS).
+ * @queue_num: The queue number for this queue.
+ * @aifsn: Arbitration inter-frame spacing number for the queue.
+ * @txop: Transmit Opportunity limit for the queue.
+ * @cwmin: Minimum size of contention window
+ * @cwmax: Maximum size of contention window
+ * @uapsd: Power save mode (0 for legacy mode and 1 for UAPSD)
+ * @if_index: Interface index.
+ * @vif_addr: MAC address of the interface.
+ *
+ * This command is used to set transmission queue parameters. There are five
+ * transmission queues; Background, Best Effort, Video, Voice and Beacon.
+ */
+struct cmd_txq_params {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int queue_num;
+	unsigned int aifsn;
+	unsigned int txop;
+	unsigned int cwmin;
+	unsigned int cwmax;
+	/* power save mode -
+	 * 0 - indicates legacy mode powersave, 1 - indicates UAPSD for the
+	 * corresponding AC.
+	 */
+	unsigned int uapsd;
+	unsigned int if_index;
+	unsigned char vif_addr[ETH_ALEN];
+} __IMG_PKD;
+
+/**
+ * struct cmd_aux_adc_chain_sel - Command used to set AUX path in the PHY.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_AUX_ADC_CHAIN_SEL).
+ * @chain_id: Aux ADC chain ID.
+ *
+ * This command is used to set the Aux path in PHY. Used to calibrate the power
+ * (to be used only in Production mode).
+ */
+struct cmd_aux_adc_chain_sel {
+	struct host_rpu_msg_hdr hdr;
+#define AUX_ADC_CHAIN1	1
+#define AUX_ADC_CHAIN2	2
+	unsigned int chain_id;
+} __IMG_PKD;
+
+/**
+ * struct cmd_cont_tx - Command used in Production mode continuous
+ *                      transmission.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_CONT_TX).
+ * @op: (0 = Stop continuous TX mode; 1 = Start continuous TX mode)
+ *
+ * This command is used in Production mode for continuously looping a tx
+ * packet.
+ */
+struct cmd_cont_tx {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int op;
+} __IMG_PKD;
+
+
+
+struct cmd_set_defaultkey {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int if_index;
+	unsigned int key_id;
+} __IMG_PKD;
+
+
+/**
+ * struct cmd_cfg_pwrmgmt- Command used to communicate information
+ *                                  about sleep control and configuration.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_CMD_CHANCTX_TIME_INFO).
+ * @config_mask: Config Mask for setting various values related to sleep
+		 controller. 
+ * This command is used to specify information about configuring various values 
+ * related to sleep controller.
+ * @pwr_on_value: UCC_SLEEP_CTRL_PWR_ON_VALUE registers
+ * @pwr_off_value: UCC_SLEEP_CTRL_PWR_OFF_VALUE registers 
+ * @ram_on_state: UCC_SLEEP_CTRL_PWR_OFF_VALUE registers
+ * @ram_off_state: UCC_SLEEP_CTRL_RAM_OFF_STATE registers
+ * @pwr_on_time: UCC_SLEEP_CTRL_PWR_ON_TIME registers
+ * @pwr_off_time: UCC_SLEEP_CTRL_PWR_OFF_TIME registers
+ * @ram_on_time: UCC_SLEEP_CTRL_RAM_ON_TIME registers
+ * @ram_off_time: UCC_SLEEP_CTRL_RAM_OFF_TIME register
+ * @sleep_timer_freq_hz: sleep timer frequency in Hz
+ *
+ * Refer LPW TRM
+ */
+struct cmd_cfg_pwrmgmt {
+	struct host_rpu_msg_hdr hdr;
+	enum RPU_SLEEP_CONFIG_CHANGED sleep_config_changed;
+	unsigned int pwr_on_value[2]; 
+	unsigned int pwr_off_value[2];
+	unsigned int ram_on_state[2];  
+	unsigned int ram_off_state[2];
+	unsigned int pwr_on_time[32];  
+	unsigned int pwr_off_time[32];
+	unsigned int ram_on_time[4];  
+	unsigned int ram_off_time[4];
+	unsigned int sleep_timer_freq_hz;
+	unsigned int wakeup_time;
+	int clk_adj_val;
+}__IMG_PKD;
+
+#define LMAC_WATCHDOG_PHY_HANG_RESET_ENABLE   0x1
+#define LMAC_FILTER_PROBE_REQ_IN_PS_ENABLE    0x2
+#define LMAC_FILTER_BCMC_DATA_IN_PS_ENABLE    0x4
+#define LMAC_NULL_FRAME_IN_PS_ENABLE          0x8
+struct cmd_patch_feature {
+    struct host_rpu_msg_hdr hdr;
+    unsigned int feature_val;
+}__IMG_PKD;
+
+struct cmd_ip_address {
+    struct host_rpu_msg_hdr hdr;
+    unsigned int addr;
+}__IMG_PKD;
+
+struct cmd_read_csr {
+    struct host_rpu_msg_hdr hdr;
+    unsigned int addr;
+}__IMG_PKD;
+
+/* Events */
+
+struct dump_info {
+	/*size of dump info*/
+	unsigned int size;
+	/*0: means this event contain only part of dump info*/
+	/*1: means this event is the end of dump info part*/
+	unsigned int end;
+	unsigned char data[1];
+}__IMG_PKD;
+
+/**
+ * struct fw_priv_cmd_done - Event used to signal the completion of info dump
+ *        
+ */
+struct fw_priv_cmd_done {
+	struct host_rpu_msg_hdr hdr;
+	struct dump_info info; // must be first item after hdr	
+}__IMG_PKD;
+
+/**
+ * struct umac_event_tx_done - Event used to signal the completion of
+ *                             a transmission request for one or more frames.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_TX_DONE).
+ * @pdout_voltage: Aux ADC reading. (Used only during FTM.)
+ * @frm_status: Status of transmitted frames.
+ * @retries_num: Number of times a frame transmission was retried.
+ * @rate: This is the rate at which TX frame was successfully transmitted.
+ *        (rate = Units of 500 Kbps or MCS index = 0 to 7).
+ * @queue: Access category of the transmitted frame.
+ * @descriptor_id: Token ID of the transmitted frame, used to match to the
+ *                 CMD_TX.
+ * @reserved: Reserved bytes for padding.
+ *
+ * This event is used by the Firmware to signal the completion of a
+ * tranmsission request of frame(s) to the Host. It also contains the
+ * transmission Success/Failure information for each frame.
+ */
+struct umac_event_tx_done {
+	struct host_rpu_msg_hdr hdr;
+
+	unsigned char pdout_voltage;
+	/* frame_status -
+	 * 0 - success
+	 * 1 - discarded due to retry limit exceeded
+	 * 2 - discarded due to msdu lifetime expiry
+	 * 3 - discarded due to encryption key not available
+	 */
+#define TX_DONE_STAT_SUCCESS (0)
+#define TX_DONE_STAT_ERR_RETRY_LIM (1)
+#define TX_DONE_STAT_MSDU_LIFETIME (2)
+#define TX_DONE_STAT_KEY_NOT_FOUND (3)
+#define TX_DONE_STAT_DISCARD (4)
+#define TX_DONE_STAT_DISCARD_BCN (5)
+#define TX_DONE_STAT_DISCARD_OP_TX (7)
+	unsigned char frm_status[MAX_TX_CMDS];
+	unsigned char retries_num[MAX_TX_CMDS];
+	/* rate = Units of 500 Kbps or mcs index = 0 to 7 */
+	unsigned char rate[MAX_TX_CMDS];
+	unsigned char queue;
+	unsigned int descriptor_id;
+	unsigned char reserved[12];
+} __IMG_PKD;
+
+/**
+ * struct wlan_rx_pkt - Event used by Firmware to indicate a RX packet to the
+ *                      host
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_RX).
+ * @pkt_length: Length of the packet; this is header length + payload
+ *              in bytes.
+ * @rate_or_mcs: Most significant bit set to 1 implies rate is MCS rate
+ *               otherwise legacy rate.
+ * @rssi: RSSI strength for this packet in dBm.
+ * @rx_pkt_status: Indicates MIC Failure status in case of TKIP/CCMP.
+ * @rate_flags: Control info related to rate at which the frame is received.
+ * @nss: Number of Spatial Streams.
+ * @num_sts: Number of Space Time Streams.
+ * @timestamp: Time at which the packet was received.
+ * @stbc_enabled: Indication of whether packet is received using STBC.
+ * @ldpc_enabled:  Indication of whether packet is received using LDPC.
+ * @unused: Unused.
+ * @channel: Channel number.
+ * @reserved: Reserved bytes for padding.
+ * @payload: 802.11 header + payload
+ *
+ * This event is used to indicate to the Host that a frame has been received,
+ * along with the control information related to the frame.
+ */
+struct wlan_rx_pkt {
+	struct host_rpu_msg_hdr hdr;
+	/* MPDU/MSDU payload in bytes */
+	unsigned int pkt_length;
+	/* bit[8] = 0 - legacy data rate
+	 *	  = 1 - MCS index
+	 */
+	unsigned char rate_or_mcs;
+	/* RSSI in dbm */
+	unsigned char rssi;
+	/* packet status
+	 * 1 - mic failed
+	 * 0 - mic succes reserved for non encryped packet\
+	 */
+#define RX_MIC_SUCCESS 0 /* No MIC error in frame */
+#define RX_MIC_FAILURE_TKIP 1 /* TKIP MIC error in frame */
+#define RX_MIC_FAILURE_CCMP 2 /* CCMP MIC error in frame */
+	unsigned char rx_pkt_status;
+#define ENABLE_11N_FORMAT 0x08
+
+	unsigned char rate_flags;
+	unsigned char nss;
+	unsigned char num_sts;
+	unsigned char timestamp[8];
+	unsigned char stbc_enabled;
+	unsigned char ldpc_enabled;
+	unsigned char unused;
+	unsigned char channel;
+	unsigned char reserved1[16];
+	/* (qos_padding = 2) */
+	unsigned char reserved2[2];
+	/* Payload bytes */
+	unsigned char payload[0];
+} __IMG_PKD;
+
+/**
+ * struct umac_event_ch_prog_complete - Event used to signal the completion of
+ *                                      channel programming command.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_CH_PROG_DONE).
+ *
+ * This event is used by the Firmware to inform the Host about the completion
+ * of the channel programming action in response to the RPU_CMD_CHANNEL
+ * command issued before. During the channel switch the Host should not issue
+ * any other commands.
+ */
+struct umac_event_ch_prog_complete {
+	struct host_rpu_msg_hdr hdr;
+} __IMG_PKD;
+
+
+/**
+ * struct umac_event_noa - Event used to notify that the P2P GO to which we are
+ *                         connected has gone into Power Save mode.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_NOA).
+ * @if_index: Virtual interface index number.
+ * @vif_addr: MAC address of the virtual interface.
+ * @noa_active: Indicates whether NOA is active or not.
+ * @ap_present: Indicates whether AP is present or not.
+ *
+ * This event is used to inform the Host about the absence of GO due to GO mode
+ * power save in P2P. After receiving this event with ap_absent true, station
+ * should refrain from transmitting frames. In this mode, a station can start
+ * TX only after NOA event with ap_absent is set to false.
+ */
+struct umac_event_noa {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int if_index;
+	unsigned char vif_addr[ETH_ALEN];
+
+	/* 1 indicates NoA feature is active
+	 * 0 indicates NoA feature is not active
+	 */
+	unsigned int noa_active;
+#define ABSENCE_START 0 /* Indicates AP is absent */
+#define ABSENCE_STOP 1 /* Indicates AP is present */
+	unsigned int ap_present;
+} __IMG_PKD;
+
+
+
+/**
+ * struct umac_event_mac_stats - Event used by Firmware to communicate MAC
+ *                               statistics to the Host.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_MAC_STATS).
+ * @roc_start: Number of ROC start commands received from the host.
+ * @roc_stop: Number of ROC stop commands received from the host.
+ * @roc_complete: Number of ROC start command completes sent to host.
+ * @roc_stop_complete: Number of ROC stop command completes sent to host.
+ * @tx_cmd_cnt: Number of TX commands received from host.
+ * @tx_done_cnt: Number of Tx done events sent to host.
+ * @tx_edca_trigger_cnt: Number of times EDCA engine was triggered.
+ * @tx_edca_isr_cnt: Number of times EDCA ISR was generated
+ *		             (indicated channel win).
+ * @tx_start_cnt: Number of TX starts to PHY.
+ * @tx_abort_cnt: Number of TX aborts detected.
+ * @tx_abort_isr_cnt: Number of TX aborts received from PHY.
+ * @tx_underrun_cnt: Number of Tx under-runs.
+ * @tx_rts_cnt: Num of RTS frames transmitted.
+ * @tx_ampdu_cnt: Num of AMPDU's transmitted, incremented by 1 for each A-MPDU
+ *                (consisting of one or more MPDUs)
+ * @tx_mpdu_cnt: Number of MPDU's transmitted, incremented by 1 for each MPDU
+ *               (1 for each A-MPDU subframe)
+ * @tx_crypto_post: Number of TX jobs posted to crypto.
+ * @tx_crypto_done: Number of TX jobs completed by crypto.
+ * @rx_pkt_to_umac: Number of packets sent to host.
+ * @rx_crypto_post: Number of RX jobs posted to crypto.
+ * @rx_crypto_done: Number of RX jobs completed by crypto.
+ * @rx_isr_cnt: Number of RX ISRs.
+ * @rx_ack_cts_to_cnt: Number of times ACK/CTS was not received within a
+ *                     expected time.
+ * @rx_cts_cnt: Number of CTS frames received.
+ * @rx_ack_resp_cnt: Number of ACK frames received.
+ * @rx_ba_resp_cnt:  Number of BA frames received.
+ * @rx_fail_in_ba_bitmap_cnt: Number of BA frames indicating at least one
+ *                            failure in the BA bitmap
+ * @rx_circular_buffer_free_cnt: Number of entries returned to RX circular
+ *                               buffers
+ * @rx_mic_fail_cnt: Number of MIC failures.
+ * @hal_cmd_cnt: Number of commands received by HAL from the host.
+ * @hal_event_cnt: Number of events sent by HAL to the host.
+ * @hal_ext_ptr_null_cnt: Number of packets dropped due to lack of Ext-Ram
+ *                        buffers from host.
+ * @csync_timeout_cntr: Number of Coarse Sync Fails after packet start is
+ *                      detected.
+ * @fsync_timeout_cntr: Number of Frame Sync Fails after AutoCorrelation Drop
+ *                      detected (in 11b) and acdrop_timeout_cntr.
+ * @acdrop_timeout_cntr: Number of Fails in AutoCorrelation Drop Detection
+ *                       after Csync detected.
+ * @csync_abort_agctrig_cntr: Number of times receiver restarts due to inband
+ *                            power change during Csync search for AGC
+ *                            triggered cases.
+ * @crc_success_cnt: FCS success count indicated by PHY.
+ * @crc_fail_cnt: FCS failure count indicated by PHY.
+ * @rpu_boot_cnt: Number of times the RPU performed warmboot.
+ * @sleep_stats[12]: Stats related to Sleep
+ *
+ * This event is used to return the MAC stats requested by the Host using the
+ * RPU_CMD_MAC_STATS command.
+ */
+struct umac_event_mac_stats {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int roc_start;
+	unsigned int roc_stop;
+	unsigned int roc_complete;
+	unsigned int roc_stop_complete;
+	unsigned int tx_cmd_cnt;
+	unsigned int tx_done_cnt;
+	unsigned int tx_edca_trigger_cnt;
+	unsigned int tx_edca_isr_cnt;
+	unsigned int tx_start_cnt;
+	unsigned int tx_abort_cnt;
+	unsigned int tx_abort_isr_cnt;
+	unsigned int tx_underrun_cnt;
+	unsigned int tx_rts_cnt;
+	unsigned int tx_ampdu_cnt;
+	unsigned int tx_mpdu_cnt;
+	unsigned int tx_crypto_post;
+	unsigned int tx_crypto_done;
+	unsigned int rx_pkt_to_umac;
+	unsigned int rx_crypto_post;
+	unsigned int rx_crypto_done;
+	unsigned int rx_isr_cnt;
+	unsigned int rx_ack_cts_to_cnt;
+	unsigned int rx_cts_cnt;
+	unsigned int rx_ack_resp_cnt;
+	unsigned int rx_ba_resp_cnt;
+	unsigned int rx_fail_in_ba_bitmap_cnt;
+	unsigned int rx_circular_buffer_free_cnt;
+	unsigned int rx_mic_fail_cnt;
+	unsigned int hal_cmd_cnt;
+	unsigned int hal_event_cnt;
+	unsigned int hal_ext_ptr_null_cnt;
+	unsigned int csync_timeout_cntr;
+	unsigned int fsync_timeout_cntr;
+	unsigned int acdrop_timeout_cntr;
+	unsigned int csync_abort_agctrig_cntr;
+	unsigned int crc_success_cnt;
+	unsigned int crc_fail_cnt;
+#ifdef RPU_SLEEP_ENABLE
+	unsigned int rpu_boot_cnt;  
+	unsigned int sleep_stats[12];
+#endif
+} __IMG_PKD;
+
+/**
+ * struct host_event_scanres - Event used to inform the Host, about completion
+ *                             of the processing of the RPU_CMD_SCAN received
+ *                             before.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_SCAN_COMPLETE).
+ * @if_index: Index of the interface on which the RPU_CMD_SCAN was processed.
+ *
+ * This event is used by the Firmware to inform the Host about the completion
+ * of the scan operation which the Host would have initiated earlier using the
+ * RPU_CMD_SCAN command.
+ */
+struct host_event_scanres {
+	struct host_rpu_msg_hdr hdr;
+	int if_index;
+} __IMG_PKD;
+
+/**
+ * struct host_event_disconnect - Event used to inform the Host, about a
+ *                                disconnection.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_DISCONNECTED).
+ * @if_index: Index of the interface on which the disconnection happened.
+ * @reason_code: Reason for disconnection.
+ * @mac_addr: MAC address of the peer which got disconnected.
+ *
+ * This event is used by the Firmware to inform the Host about the disconnection
+ * of a peer along with the reason for disconnection.
+ */
+struct host_event_disconnect {
+	struct host_rpu_msg_hdr hdr;
+	int if_index;
+#define REASON_DEAUTH 1
+#define REASON_AUTH_FAILURE 2
+#define REASON_NW_LOST 3
+#define REASON_AUTH_TIMEOUT 4
+#define REASON_TX_TOKEN_NOTAVAIL 5
+#define REASON_ASSOC_TIMEOUT 6
+	unsigned int reason_code;
+	unsigned char mac_addr[ETH_ALEN];
+} __IMG_PKD;
+
+/**
+ * struct host_event_reset_complete - Event used to inform the Host, about a
+ *                                    completion of a reset command.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_RESET_COMPLETE).
+ * @unused: Unused
+ * @version: Firmware version number.
+ *
+ * This event is used by the Firmware to inform the Host about the completion of
+ * a reset command (RPU_CMD_RESET) which the Host would have sent earlier.
+ */
+struct host_event_reset_complete {
+	struct host_rpu_msg_hdr hdr;
+#ifndef RK915	
+	unsigned int unused[16];
+#endif
+	char version[6+24]; // lmac version + FW build time
+} __IMG_PKD;
+
+
+/**
+ * struct umac_event_rf_calib_data - Event used to communicate calibration data
+ *                                   to the Host.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_RF_CALIB_DATA).
+ * @rf_calib_data_length: Size of the RF calibration data.
+ * @rf_calib_data: The RF calibration data.
+ *
+ * This event is used by the Firmware to return the RF calibration data to the
+ * Host. This is sent after every channel change, mainly to be used for debug
+ * calibration issues.
+ */
+struct umac_event_rf_calib_data {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int  rf_calib_data_length;
+	unsigned char rf_calib_data[0];
+} __IMG_PKD;
+
+/**
+ * struct umac_event_roc_status - Event used to inform host about the status of
+ *                                a Remain-On-Channel(ROC) operation.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_ROC_STATUS).
+ * @roc_status: Status of the ROC operation (Started/Stopped/Done).
+ *
+ * This event is used by the Firmware to provide the ROC related
+ * information to the Host i.e. whether ROC has been started, stopped or has
+ * completed in response to the previous RPU_CMD_ROC_CTRL command issued by the
+ * Host.
+ * ROC is applicable only for P2P Mode.
+ */
+struct umac_event_roc_status {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int roc_status;
+} __IMG_PKD;
+
+
+/**
+ * struct umac_event_ps_econ_wake - Event used by Firmware to indicate a
+ *                                  Economy mode wakeup event to the
+ *                                  host.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_PS_ECON_WAKE).
+ * @trigger: Indicates the trigger event which caused the wakeup.
+ *
+ * This event is used to indicate an Economy mode wakeup event to the Host. It
+ * also includes information about the actual trigger which caused the wakeup.
+ */
+struct umac_event_ps_econ_wake {
+	struct host_rpu_msg_hdr hdr;
+	enum UMAC_PS_ECON_WAKE_TRIG trigger;
+} __IMG_PKD;
+
+/**
+ * struct umac_event_ps_econ_cfg_complete - Event used by Firmware to indicate
+ *                                          that the firmware has finished
+ *                                          processing the RPU_CMD_PS_ECON_CFG
+ *                                          command.
+ * @hdr: Host-Firmware message header (id field needs to be set to
+ *       RPU_EVENT_PS_ECON_CFG_DONE).
+ * @status: Indicates the whether the RPU_CMD_PS_ECON_CFG was processesed
+ *          successfully or not.
+ *
+ * This event indicates that the firmware has finished processing the
+ * RPU_CMD_PS_ECON_CFG command and the driver can return control back
+ * to mac80211 to complete the suspend/resume.
+ */
+struct umac_event_ps_econ_cfg_complete {
+	struct host_rpu_msg_hdr hdr;
+	unsigned char status; /* SUCCESS/FAILURE */
+} __IMG_PKD;
+
+struct host_event_command_complete {
+	struct host_rpu_msg_hdr hdr;
+} __IMG_PKD;
+
+
+struct umac_event_ch_switch_complete {
+	struct host_rpu_msg_hdr hdr;
+	int status;
+} __IMG_PKD;
+
+struct umac_event_read_csr_complete {
+	struct host_rpu_msg_hdr hdr;
+	unsigned int value;
+} __IMG_PKD;
+
+#endif /*_HOST_RPU_IF_H_*/
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/add_license.sh b/drivers/net/wireless/rockchip_wlan/rk915/src/add_license.sh
new file mode 100755
index 000000000..6befc917c
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/add_license.sh
@@ -0,0 +1,23 @@
+#!/bin/bash
+
+read_dir(){
+    for file in `ls $1`
+    do
+        if [ -d $1"/"$file ]
+        then
+            read_dir $1"/"$file
+        else
+			file_name=$1"/"$file
+            echo $file_name
+			cat $file_name | grep "$license"
+			if [ $? -eq 0 ]; then
+				echo "skip $file_name"
+			else
+				sed -i "1i $license" $file_name
+			fi
+        fi
+    done
+}
+
+license="# SPDX-License-Identifier: GPL-2.0"
+read_dir $1
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/beacon.c b/drivers/net/wireless/rockchip_wlan/rk915/src/beacon.c
new file mode 100755
index 000000000..2f302e0a8
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/beacon.c
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include "core.h"
+
+void modify_beacon_params (struct umac_vif *uvif,
+				  struct ieee80211_bss_conf *bss_conf)
+{
+	unsigned int bcn_int = 0;
+	unsigned long bcn_tim_val = 0;
+	int ret = 0;
+
+	RPU_DEBUG_VIF("%s: enable_beacon=%d\n", __func__, uvif->vif->bss_conf.enable_beacon);
+
+	if (uvif->vif->bss_conf.enable_beacon == true) {
+
+		bcn_int = bss_conf->beacon_int;
+		bcn_tim_val =  msecs_to_jiffies(bcn_int - 10);
+
+		mod_timer(&uvif->bcn_timer,
+			  jiffies + bcn_tim_val);
+
+		CALL_RPU(rpu_prog_vif_beacon_int,
+			  uvif->vif_index,
+			  uvif->vif->addr,
+			  bcn_int);
+	} else {
+		del_timer(&uvif->bcn_timer);
+	}
+prog_rpu_fail:
+	return;
+
+}
+
+//INIT_GET_SPEND_TIME(bcn_start_time, bcn_stop_time);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+static void vif_bcn_timer_expiry(struct timer_list *t)
+{
+	struct umac_vif *uvif = from_timer(uvif, t, bcn_timer);
+#else
+static void vif_bcn_timer_expiry(unsigned long data)
+{
+	struct umac_vif *uvif = (struct umac_vif *)data;
+#endif
+	struct sk_buff *skb, *temp;
+	struct sk_buff_head bcast_frames;
+
+	RPU_DEBUG_VIF("%s: enable_beacon=%d\n", __func__, uvif->vif->bss_conf.enable_beacon);
+	/*{ // check beacon frame interval
+		unsigned long itv;
+		START_GET_SPEND_TIME(bcn_start_time, bcn_stop_time);
+		itv = GET_SPEND_TIME_US(bcn_stop_time, bcn_start_time)/1000;
+		if (itv > 120 || itv < 90)
+			RPU_ERROR_VIF("beacon interval = %ld\n", itv);
+		END_GET_SPEND_TIME(bcn_start_time, bcn_stop_time);
+	}*/
+
+	if (uvif->vif->bss_conf.enable_beacon == false)
+		return;
+
+	if (uvif->vif->type == NL80211_IFTYPE_AP) {
+		temp = skb = ieee80211_beacon_get(uvif->priv->hw, uvif->vif);
+
+		if (!skb) {
+			/* No beacon, so dont transmit braodcast frames*/
+			goto reschedule_timer;
+		}
+
+		skb_queue_head_init(&bcast_frames);
+		skb->priority = 1;
+		skb_queue_tail(&bcast_frames, skb);
+
+		skb = ieee80211_get_buffered_bc(uvif->priv->hw, uvif->vif);
+
+		while (skb) {
+			/* Hack: skb->priority is used to indicate more
+			 * frames
+			 */
+			skb->priority = 1;
+			skb_queue_tail(&bcast_frames, skb);
+			temp = skb;
+			skb = ieee80211_get_buffered_bc(uvif->priv->hw,
+							uvif->vif);
+		}
+
+		if (temp)
+			temp->priority = 0;
+
+		spin_lock_bh(&uvif->priv->bcast_lock);
+
+		while ((skb = skb_dequeue(&bcast_frames))) {
+			/* For a Beacon queue we will let the frames pass
+			 * through irrespective of the current channel context.
+			 * The FW will take care of transmitting them in the
+			 * appropriate channel. Hence pass the interfaces
+			 * channel context instead of the actual current channel
+			 * context.
+			 */
+			rpu_tx_frame(skb,
+					     NULL,
+					     uvif->priv,
+					     true);
+		}
+
+		spin_unlock_bh(&uvif->priv->bcast_lock);
+
+	} else {
+		skb = ieee80211_beacon_get(uvif->priv->hw, uvif->vif);
+
+		if (!skb)
+			goto reschedule_timer;
+
+		/* For a Beacon queue we will let the frames pass through
+		 * irrespective of the current channel context. The FW will take
+		 * care of transmitting them in the appropriate channel.  Hence
+		 * pass the interfaces channel context instead of the actual
+		 * current channel context.
+		 */
+		rpu_tx_frame(skb,
+				     NULL,
+				     uvif->priv,
+				     true);
+
+	}
+reschedule_timer:
+	return;
+
+}
+
+void init_beacon (struct umac_vif *uvif)
+{
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+	timer_setup(&uvif->bcn_timer, vif_bcn_timer_expiry, 0);
+#else
+	init_timer(&uvif->bcn_timer);
+	uvif->bcn_timer.data = (unsigned long)uvif;
+	uvif->bcn_timer.function = vif_bcn_timer_expiry;
+#endif
+}
+
+void deinit_beacon (struct umac_vif *uvif)
+{
+	del_timer(&uvif->bcn_timer);
+
+}
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/firmware.c b/drivers/net/wireless/rockchip_wlan/rk915/src/firmware.c
new file mode 100755
index 000000000..1cba350c4
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/firmware.c
@@ -0,0 +1,913 @@
+#include <linux/vmalloc.h>
+
+#include "core.h"
+#include "if_io.h"
+#include "sdio.h"
+#include "hal_io.h"
+
+#define FW_READ_BACK_CHECK
+
+struct io_cmd {
+        unsigned int id;
+        unsigned int length;
+        unsigned int addr;
+};
+
+void rk915_free_firmware_buf(struct firmware_info *fw_info)
+{
+	RPU_DEBUG_FIRMWARE("%s\n", __func__);
+
+	if (fw_info->block_data)
+		kfree(fw_info->block_data);
+	if (fw_info->fw_data)
+		vfree(fw_info->fw_data);
+	fw_info->fw_data = NULL;
+#ifdef FW_READ_BACK_CHECK
+	if (fw_info->fw_data_check)
+		vfree(fw_info->fw_data_check);
+	fw_info->fw_data_check = NULL;
+#endif
+	if (fw_info->fw_start_data)
+		kfree(fw_info->fw_start_data);
+	fw_info->fw_start_data = NULL;
+#ifdef ENABLE_FW_SPLIT	
+	if (fw_info->patch_data)
+		kfree(fw_info->patch_data);
+	fw_info->patch_data = NULL;
+#endif
+	if (fw_info->patch2_data)
+		kfree(fw_info->patch2_data);
+	fw_info->patch2_data = NULL;
+
+	if (fw_info->cal_data)
+		kfree(fw_info->cal_data);
+	fw_info->cal_data = NULL;
+
+	if (fw_info->rf_para_data)
+		kfree(fw_info->rf_para_data);
+	fw_info->rf_para_data = NULL;
+}
+
+int rk915_alloc_firmware_buf(struct firmware_info *fw_info)
+{
+	RPU_DEBUG_FIRMWARE("%s\n", __func__);
+
+    fw_info->block_data = kmalloc(MAX_BLOCK_DATA_SIZE, GFP_KERNEL);
+	if (fw_info->block_data == NULL) {
+		RPU_ERROR_FIRMWARE("alloc block_data failed\n");
+		return -1;
+	}
+
+	fw_info->fw_data = vmalloc(MAX_FW_BUF_SIZE);
+	if (fw_info->fw_data == NULL) {
+		RPU_ERROR_FIRMWARE("alloc fw_data failed\n");
+		return -1;
+	}
+#ifdef FW_READ_BACK_CHECK
+	fw_info->fw_data_check = vmalloc(MAX_FW_BUF_SIZE);
+	if (fw_info->fw_data_check == NULL) {
+		RPU_ERROR_FIRMWARE("alloc fw_data_check failed\n");
+		return -1;
+	}
+#endif	
+	fw_info->fw_start_data = kmalloc(16, GFP_KERNEL);
+	if (fw_info->fw_start_data == NULL) {
+		RPU_ERROR_FIRMWARE("alloc fw_start_data failed\n");
+		return -1;
+	}
+#ifdef ENABLE_FW_SPLIT	
+	fw_info->patch_data = kmalloc(MAX_PATCH_BUF_SIZE, GFP_KERNEL);
+	if (fw_info->patch_data == NULL) {
+		RPU_ERROR_FIRMWARE("alloc patch_data failed\n");
+		return -1;
+	}
+#endif
+	fw_info->patch2_data = kmalloc(MAX_PATCH_BUF_SIZE, GFP_KERNEL);
+	if (fw_info->patch2_data == NULL) {
+		RPU_ERROR_FIRMWARE("alloc patch2_data failed\n");
+		return -1;
+	}
+
+	fw_info->cal_data = kmalloc(RF_CAL_DATA_SIZE, GFP_KERNEL);
+	if (fw_info->cal_data == NULL) {
+		RPU_ERROR_FIRMWARE("alloc cal_data failed\n");
+		return -1;
+	}
+
+	fw_info->rf_para_data = kmalloc(RF_PARA_DATA_SIZE, GFP_KERNEL);
+	if (fw_info->rf_para_data == NULL) {
+		RPU_ERROR_FIRMWARE("alloc rf_para_data failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int rk915_copy_firmware(struct firmware_info *fw_info,
+			int fw_size, int patch_size, int patch2_size, int cal_size, int rf_para_size,
+			u8 *fw_data, u8 *patch_data, u8 *patch2_data, u8 *cal_data, u8 *rf_para_data)
+{
+	struct rf_cal_hdr *cal_hdr;
+
+	fw_info->fw_size =  ALIGN(fw_size, 4);
+#ifdef ENABLE_FW_SPLIT	
+	fw_info->patch_size = ALIGN(patch_size , 4);
+#endif
+	fw_info->patch2_size = ALIGN(patch2_size , 4);
+	/* append rf cal data before patch2 */
+	if (cal_size)
+		fw_info->patch2_size += ALIGN(sizeof(struct rf_cal_hdr) , 4);
+
+	if (fw_info->patch2_size > MAX_PATCH_BUF_SIZE) {
+		return -1;
+	}
+
+	RPU_DEBUG_FIRMWARE("%s: fw_info fw_size: %d, patch_size: %d.\n",
+				   __func__, fw_info->fw_size, fw_info->patch_size);
+	RPU_DEBUG_FIRMWARE("%s: fw_info patch2_size: %d, cal_size: %d.\n",
+				   __func__, fw_info->patch2_size, fw_info->cal_size);
+
+#if !FW_LOADER_FROM_USER_OPEN
+	if (fw_data)
+		memcpy(fw_info->fw_data, fw_data, fw_size);
+#ifdef ENABLE_FW_SPLIT
+	if (patch_data)
+		memcpy(fw_info->patch_data, patch_data, patch_size);
+#endif
+#endif
+	/* append rf cal data before patch2 */
+	if (cal_size) {
+		RPU_INFO_FIRMWARE("%s: add rf cal data\n", __func__);
+#if FW_LOADER_FROM_USER_OPEN
+		memmove(fw_info->patch2_data + ALIGN(sizeof(struct rf_cal_hdr) , 4),
+				fw_info->patch2_data, ALIGN(patch2_size , 4));
+#endif
+		cal_hdr = (struct rf_cal_hdr *)fw_info->patch2_data;
+		memcpy(cal_hdr->tag, RF_CAL_TAG, 4);
+		cal_hdr->cal_enable = 1;
+		cal_hdr->size = ALIGN(sizeof(struct rf_cal_hdr) , 4);
+		memcpy(cal_hdr->cal_data, cal_data, RF_CAL_DATA_SIZE);	
+#if FW_LOADER_FROM_USER_OPEN
+	}
+#else
+		memcpy(fw_info->patch2_data + cal_hdr->size,
+				patch2_data, patch2_size);
+	} else {
+		memcpy(fw_info->patch2_data, patch2_data, patch2_size);
+	}
+#endif
+
+	if (rf_para_size) {
+		set_rf_params(rf_para_data);
+	}
+
+	return 0;
+}
+
+#if FW_LOADER_FROM_USER_OPEN
+static const char * const fw_path[] = {
+	"/etc/firmware",
+	"/vendor/etc/firmware",
+	"/lib/firmware",
+	"/system/etc/firmware"
+};
+
+static int rk915_read_firmware_file(struct firmware_info *fw_info, char *name, u8 *buf, int *len)
+{
+	int i, find = 0;
+	char path[64];
+	struct file *file;
+	int read, size = 1024;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	loff_t pos = 0;
+#endif
+
+	for (i = 0; i < ARRAY_SIZE(fw_path); i++) {
+		if (!fw_path[i][0])
+			continue;
+
+		sprintf(path, "%s/%s", fw_path[i], name);
+
+		file = filp_open(path, O_RDONLY, 0);
+		if (IS_ERR(file))
+			continue;
+
+		find = 1;
+		break;
+	}
+
+	if (!find) {
+		RPU_ERROR_FIRMWARE("%s: failed to open %s\n", __func__, name);
+		return -1;
+	}
+
+	*len = 0;
+	while (1) {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 14, 0))
+		read = kernel_read(file, buf, size, &pos);
+#else
+		read = kernel_read(file, file->f_pos, buf, size);
+		file->f_pos += read;
+#endif
+		if (read <= 0)
+			break;
+
+		buf += read;
+		*len += read;
+	}
+
+	filp_close(file, NULL);
+
+	if (*len > MAX_FW_BUF_SIZE) {
+		RPU_ERROR_FIRMWARE("%s file exceed max size %d\n", name, *len);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int rk915_get_firmware_from_open(struct host_io_info *host, struct firmware_info *fw_info)
+{
+	int ret; 
+
+	RPU_INFO_FIRMWARE("firmware and patch file from open\n");
+
+	ret = rk915_read_firmware_file(fw_info, "rk915_fw.bin", fw_info->fw_data, &fw_info->fw_size);
+	if (ret < 0)
+		return -1;
+
+#ifdef ENABLE_FW_SPLIT
+	ret = rk915_read_firmware_file(fw_info, "rk915_patch_cal.bin", fw_info->patch_data, &fw_info->patch_size);
+	if (ret < 0)
+		return -1;
+#endif
+
+	ret = rk915_read_firmware_file(fw_info, "rk915_patch.bin", fw_info->patch2_data, &fw_info->patch2_size);
+	if (ret < 0)
+		return -1;
+
+	ret = rk915_read_firmware_file(fw_info, RF_CAL_DATA_FILE, fw_info->cal_data, &fw_info->cal_size);
+	if (ret < 0) {
+		//RPU_INFO_FIRMWARE("%s load error!\n", RF_CAL_DATA_FILE);
+		fw_info->cal_size = 0;
+	}
+
+	ret = rk915_read_firmware_file(fw_info, RF_PARA_DATA_FILE, fw_info->rf_para_data, &fw_info->rf_para_size);
+	if (ret < 0) {
+		//RPU_INFO_FIRMWARE("%s load error!\n", RF_PARA_DATA_FILE);
+		fw_info->rf_para_size = 0;
+	} else if (fw_info->rf_para_size > RF_PARA_DATA_SIZE) {
+		RPU_ERROR_FIRMWARE("%s ivalid rf para data!\n", RF_PARA_DATA_FILE);
+		fw_info->rf_para_size = 0;
+	}
+
+	ret = rk915_copy_firmware(fw_info, fw_info->fw_size, fw_info->patch_size,
+					fw_info->patch2_size, fw_info->cal_size, fw_info->rf_para_size,
+					(u8 *)fw_info->fw_data, (u8 *)fw_info->patch_data,
+					(u8 *)fw_info->patch2_data, (u8 *)fw_info->cal_data, (u8 *)fw_info->rf_para_data);
+	if (ret < 0) {
+		RPU_INFO_FIRMWARE("rk915_copy_firmware failed!\n");
+		return -1;
+	}
+
+	return 0;
+}
+#else
+static int rk915_get_firmware_from_request(struct host_io_info *host, struct firmware_info *fw_info)
+{
+	int error, ret = -1;
+
+	RPU_INFO_FIRMWARE("firmware and patch file from request\n");
+
+	error = request_firmware(&fw_info->fw_fw, "rk915_fw.bin", host->dev);
+	if (error < 0) {
+		RPU_ERROR_FIRMWARE("rk915_fw.bin load error!\n");
+		goto exit_request;
+	}
+
+#ifdef ENABLE_FW_SPLIT
+	error = request_firmware(&fw_info->patch_fw, "rk915_patch_cal.bin", host->dev);
+	if (error < 0) {
+		RPU_ERROR_FIRMWARE("rk915_patch_cal.bin load error!\n");
+		goto exit_request;
+	}
+#endif
+
+	error = request_firmware(&fw_info->patch2_fw, "rk915_patch.bin", host->dev);
+	if (error < 0) {
+		RPU_ERROR_FIRMWARE("rk915_patch.bin load error!\n");
+		goto exit_request;
+	}
+
+	error = request_firmware(&fw_info->cal_fw, RF_CAL_DATA_FILE, host->dev);
+	if (error < 0) {
+		//RPU_INFO_FIRMWARE("%s load error!\n", RF_CAL_DATA_FILE);
+		fw_info->cal_fw = NULL;
+	}
+
+	error = rk915_copy_firmware(fw_info, fw_info->fw_fw->size, fw_info->patch_fw->size,
+					fw_info->patch2_fw->size, fw_info->cal_fw?fw_info->cal_fw->size:0,
+					(u8 *)fw_info->fw_fw->data, (u8 *)fw_info->patch_fw->data,
+					(u8 *)fw_info->patch2_fw->data, fw_info->cal_fw?(u8 *)fw_info->cal_fw->data:NULL);
+	if (error < 0) {
+		RPU_INFO_FIRMWARE("rk915_copy_firmware failed!\n");
+		goto exit_request;
+	}
+
+	ret = 0;
+
+exit_request:
+	if (fw_info->fw_fw)
+		release_firmware(fw_info->fw_fw);
+#ifdef ENABLE_FW_SPLIT
+	if (fw_info->patch_fw)
+		release_firmware(fw_info->patch_fw);
+#endif
+	if (fw_info->patch2_fw)
+		release_firmware(fw_info->patch2_fw);
+	if (fw_info->cal_fw)
+		release_firmware(fw_info->cal_fw);
+
+	return ret;
+}
+#endif
+
+static int rk915_get_firmware_info(struct host_io_info *host, struct firmware_info *fw_info)
+{
+	int ret = 0;
+
+	if (fw_info->fw_saved)
+		return 0;
+
+#ifdef FW_LOADER_FROM_USER
+
+#if FW_LOADER_FROM_USER_OPEN
+	ret = rk915_get_firmware_from_open(host, fw_info);
+#else
+	ret = rk915_get_firmware_from_request(host, fw_info);
+#endif
+
+#else
+	RPU_INFO_FIRMWARE("firmware and patch buildin\n");
+	fw_info->fw_size = sizeof(fwdata);
+	fw_info->fw_data = fwdata;
+
+	fw_info->patch_size = sizeof(rom_patch);
+	fw_info->patch_data = rom_patch;
+#endif
+
+	return ret;
+}
+
+static int rk915_fw_write(struct hal_priv *priv,
+						    void *fw, size_t fw_len)
+{
+    struct firmware_info *fw_info = &priv->io_info->firmware;
+    unsigned char *src = (unsigned char *)fw;
+    int size;
+    int ret;
+    int addr = 0;
+    
+    while (fw_len) {
+        size = fw_len > MAX_BLOCK_DATA_SIZE ? MAX_BLOCK_DATA_SIZE:fw_len;
+        memcpy(fw_info->block_data, src, size);
+		ret = rk915_data_write(priv, addr, fw_info->block_data, size);
+		if (ret) {
+			RPU_ERROR_FIRMWARE("%s: write fw block(%d) failed (%d)\n",
+                        __func__, addr, ret);
+			return -1;
+		}
+        addr += size;
+        src += size;
+        fw_len -= size;
+    }
+    return 0;
+}
+
+static int rk915_fw_read(struct hal_priv *priv,
+						    void *fw, size_t fw_len)
+{
+    struct firmware_info *fw_info = &priv->io_info->firmware;
+    unsigned char *dst = (unsigned char *)fw;
+    int size;
+    int ret;
+    int addr = 0;
+    
+    while (fw_len) {
+        size = fw_len > MAX_BLOCK_DATA_SIZE ? MAX_BLOCK_DATA_SIZE:fw_len;
+		ret = rk915_data_read(priv, addr, fw_info->block_data, size);
+		if (ret) {
+			RPU_ERROR_FIRMWARE("%s: read fw block(%d) failed (%d)\n",
+                        __func__, addr, ret);
+			return -1;
+		}
+        memcpy(dst, fw_info->block_data, size);
+        addr += size;
+        dst += size;
+        fw_len -= size;
+    }
+    return 0;
+}
+
+//#define RK915_MEMORY_CHECK
+#ifdef RK915_MEMORY_CHECK
+static int err_bits[8];
+static void rk915_mem_check_init(void)
+{
+	memset(err_bits, 0, 8*sizeof(int));
+}
+
+static void rk915_mem_check_stat(u8 val, u8 magic, int result, int total)
+{
+	int i;
+	
+	if (val == magic)
+		goto print_result;
+
+	val ^= magic;
+	for (i = 0; i < 8; i++) {
+		if ((val >> i) & 0x1)
+			err_bits[i]++;
+	}
+
+print_result:	
+	if (result) {
+		RPU_ERROR_FIRMWARE("total error bytes: %d, bit %d %d %d %d %d %d %d %d\n",
+				total, err_bits[0], err_bits[1], err_bits[2], err_bits[3],
+				err_bits[4], err_bits[5], err_bits[6], err_bits[7]);
+		rk915_mem_check_init();
+	}
+}
+
+#include <linux/random.h>
+static void rk915_mem_check(struct hal_priv *priv)
+{
+	int i, j, k, ret;
+	u8 val;
+	int size = 128*1024;
+	u8 *buf_write = NULL, *buf_read = NULL;
+	int fail = 0;
+	int start_addr = 0x0000;
+	int read_size = size;
+	int block_size = 32768;
+	int block_count, block_err;
+	int randomX;
+
+	buf_write = kzalloc(size, GFP_KERNEL);
+	if (buf_write == NULL)
+		goto mem_chk_end;
+	buf_read = kzalloc(size, GFP_KERNEL);
+	if (buf_read == NULL)
+		goto mem_chk_end;
+
+	for (j = 0; j < 3; j++) {
+		if (j == 0) {
+			val = 0;
+		} else if (j == 2) {
+			val = 0xAA;
+		} else {
+			val = 0xff;
+		}
+
+		if (val == 0xAA)
+			RPU_INFO_FIRMWARE("start mem check: value(random) addr %x len %d block %d\n", start_addr, size, read_size);
+		else
+			RPU_INFO_FIRMWARE("start mem check: value(0x%02X) addr %x len %d block %d\n", val, start_addr, size, read_size);
+
+		if (val == 0xAA) {
+			u32 *fill = (u32 *)buf_write;
+			for (i = 0; i < size/4; i++) {
+				get_random_bytes(&randomX, 4);
+				*fill++ = randomX;
+			}
+		} else {
+			memset(buf_write, val, size);
+		}
+		ret = rk915_data_write(priv, start_addr, buf_write, size);
+		if (ret) {
+			RPU_ERROR_FIRMWARE("%s: download fw failed (%d)\n", __func__, ret);
+			goto mem_chk_end;
+		}
+
+		for (k = 0; k < size/read_size; k++) {
+			int offset = k * read_size;
+
+			//RPU_INFO_FIRMWARE("read offset %x\n", offset);
+			ret = rk915_data_read(priv, start_addr + offset, buf_read + offset, read_size);
+			if (ret) {
+				RPU_ERROR_FIRMWARE("%s: read fw failed (%d)\n", __func__, ret);
+				goto mem_chk_end;
+			}
+		}
+
+		fail = 0;
+		block_count = 0;
+		block_err = 0;
+		for (i = 0; i < size; i++) {
+			if ((i % block_size) == 0) {
+				block_count = 0;
+				block_err = 0;
+				RPU_INFO_FIRMWARE("==========================\n");
+			}
+			block_count++;
+			if (buf_read[i] != buf_write[i]) {
+				RPU_ERROR_FIRMWARE("addr: %x, 0x%02x,  0x%02x\n",
+							   i + start_addr, buf_write[i], buf_read[i]);
+				fail++;
+				block_err++;
+			}
+			if (val == 0xAA)
+				rk915_mem_check_stat(buf_read[i], buf_write[i], block_count==block_size, block_err);
+			else
+				rk915_mem_check_stat(buf_read[i], val, block_count==block_size, block_err);
+		}
+
+		if (fail) {
+			RPU_ERROR_FIRMWARE("%s: value(0x%02X) size(%d) failed\n", __func__, val, size);
+		} else {
+			RPU_INFO_FIRMWARE("%s: value(0x%02X) size(%d)  success\n", __func__, val, size);
+		}
+	}
+
+mem_chk_end:
+	if (buf_write)
+		kfree(buf_write);
+	if (buf_read)
+		kfree(buf_read);
+}
+#endif
+
+void rk915_mem_check2(struct hal_priv *priv, unsigned int addr, unsigned int len)
+{
+#ifdef FW_READ_BACK_CHECK 
+	struct firmware_info *fw = &priv->io_info->firmware;
+	int i, ret;
+	int fail = 0;
+
+	RPU_INFO_FIRMWARE("%s: addr %x %d\n", __func__, addr, len);
+	memset(fw->fw_data_check, 0x55, MAX_FW_BUF_SIZE);
+	ret = rk915_data_read(priv, addr, fw->fw_data_check, len);
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: read fw failed (%d)\n", __func__, ret);
+		return;
+	}
+
+#ifndef RK915
+	addr = 0;
+#endif
+
+	for (i = addr; i < len + addr; i++) {
+		if (fw->fw_data_check[i] != fw->fw_data[i]) {
+			fail++;
+			RPU_ERROR_FIRMWARE("i: %x, 0x%02x,  0x%02x\n",
+							   i, fw->fw_data[i], fw->fw_data_check[i]);
+		}
+	}
+
+	if (fail) {
+		RPU_ERROR_FIRMWARE("%s: failed %d\n", __func__, fail);
+	} else {
+		RPU_INFO_FIRMWARE("%s: success\n", __func__);
+	}
+#endif
+}
+
+extern bool m0_jtag_enable;
+
+static int rk915_download(struct hal_priv *priv)
+{
+	int ret, state;
+	struct firmware_info *fw = &priv->io_info->firmware;
+	struct io_tx_ctrl_info info;
+	int delay_ms = 10, count = 0, max_retry = 300;
+
+	priv->during_fw_download = 1;
+
+	if (likely(!m0_jtag_enable)) {
+		struct io_cmd *scmd = (struct io_cmd *)fw->fw_start_data;
+#ifdef FW_READ_BACK_CHECK  
+        int check_size;
+		int i;
+		u8 val;
+#endif
+#ifdef RK915_MEMORY_CHECK
+		rk915_mem_check(priv);
+		return -1;
+#endif
+
+		// 1. download fw first
+		RPU_INFO_FIRMWARE("%s: start download firmware size: %d\n", __func__, fw->fw_size);
+
+		ret = rk915_fw_write(priv, fw->fw_data, fw->fw_size);
+		if (ret) {
+			RPU_ERROR_FIRMWARE("%s: download fw failed (%d)\n", __func__, ret);
+			goto fail;
+		}
+#ifdef FW_READ_BACK_CHECK
+		ret = rk915_fw_read(priv, fw->fw_data_check, fw->fw_size);
+		if (ret) {
+			RPU_ERROR_FIRMWARE("%s: read fw failed (%d)\n", __func__, ret);
+			goto fail;
+		}
+
+		check_size = fw->fw_size;
+#if 0//def RK915
+		if (check_size > 32*1024)
+			check_size = 32*1024;
+#endif
+		for (i = 0; i < check_size; i++) {
+			if (fw->fw_data_check[i] != fw->fw_data[i]) {
+				RPU_ERROR_FIRMWARE("i: %x, 0x%02x,  0x%02x\n",
+							   i, fw->fw_data[i], fw->fw_data_check[i]);
+			}
+		}
+
+		val = memcmp(fw->fw_data, fw->fw_data_check, check_size);
+		if (val) {
+			RPU_ERROR_FIRMWARE("%s: check downloaded fw failed\n", __func__);
+			//ret = -1;
+			//goto fail;
+		} else {
+			RPU_INFO_FIRMWARE("%s: check downloaded fw ok.\n", __func__);
+		}
+#endif
+		scmd->id = IO_START_CMD_ID;
+		scmd->length = 4;
+		scmd->addr = 0;
+		ret = rk915_data_write(priv, IO_START_CMD_ADDR, (void *)scmd, sizeof(struct io_cmd));
+		if (ret) {
+			RPU_ERROR_FIRMWARE("%s: start fw failed (%d)\n", __func__, ret);
+			goto fail;
+		}
+
+		mdelay(20);
+	}
+
+	while (1) {
+		state = rk915_readb(priv, IO_FW_STATE);
+		if (state < 0) {
+			ret = -1;
+			goto fail;
+		}
+#ifdef SDIO_TXRX_STABILITY_TEST
+		if (state >= WAIT_PATCH)
+#else
+		if (state == WAIT_PATCH)
+#endif
+			break;
+		if (count++ > max_retry)
+			break;
+		mdelay(delay_ms);
+		//if (net_ratelimit())
+		//	RPU_INFO_FIRMWARE("wait fw ready (state = %d)\n", state);
+	};
+	if (count > max_retry) {
+		RPU_INFO_FIRMWARE("%s: download firmware failed\n", __func__);
+		ret = -1;
+		goto fail;
+	} else {
+		RPU_INFO_FIRMWARE("%s: download firmware success\n", __func__);
+	}
+
+	mdelay(50);
+
+#ifdef SDIO_TXRX_STABILITY_TEST
+	ret = 0;
+	goto fail;
+#endif
+
+#ifdef ENABLE_FW_SPLIT
+	/* 2. download patch */
+	RPU_DEBUG_FIRMWARE("%s: start download patch\n", __func__);
+
+	memset(&info, 0, sizeof(struct io_tx_ctrl_info));
+	info.type = IO_TX_PKT_PATCH;
+	info.patch_len = fw->patch_size;
+
+	ret = rk915_writeb(priv, IO_PATCH_LEN_L, (info.patch_len & 0x00ff));
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch rk915_writeb failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+	ret = rk915_writeb(priv, IO_PATCH_LEN_H, (info.patch_len & 0xff00) >> 8);
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch rk915_writeb failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+	ret = rk915_data_write(priv, IO_PATCH_ADDR, fw->patch_data, fw->patch_size);
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+	count = 0;
+	while (1) {
+		state = rk915_readb(priv, IO_FW_STATE);
+		if (state < 0) {
+			ret = -1;
+			goto fail;
+		}
+		if (state >= WAIT_PATCH2)
+			break;
+		if (count++ > max_retry)
+			break;
+		mdelay(delay_ms);
+		//if (net_ratelimit())
+		//	RPU_INFO_FIRMWARE("wait lpw ready (state = %d)\n", state);
+	};
+	if (count > max_retry) {
+		RPU_INFO_FIRMWARE("%s: download patch failed\n", __func__);
+		ret = -1;
+		goto fail;
+	} else {
+		RPU_INFO_FIRMWARE("%s: download patch success\n", __func__);
+	}
+#endif
+
+	/* 3. download patch2 */
+	RPU_DEBUG_FIRMWARE("%s: start download patch2\n", __func__);
+
+	memset(&info, 0, sizeof(struct io_tx_ctrl_info));
+	info.type = IO_TX_PKT_PATCH;
+	info.patch_len = fw->patch2_size;
+
+	ret = rk915_writeb(priv, IO_PATCH_LEN_L, (info.patch_len & 0x00ff));
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch2 rk915_writeb failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+	ret = rk915_writeb(priv, IO_PATCH_LEN_H, (info.patch_len & 0xff00) >> 8);
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch2 rk915_writeb failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+	ret = rk915_data_write(priv, IO_PATCH_ADDR, fw->patch2_data, fw->patch2_size);
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch2 failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+	count = 0;
+	while (1) {
+		state = rk915_readb(priv, IO_FW_STATE);
+		if (state < 0) {
+			ret = -1;
+			goto fail;
+		}
+		if (state >= M0_READY)
+			break;
+		if (count++ > max_retry)
+			break;
+		mdelay(delay_ms);
+		//if (net_ratelimit())
+		//	RPU_INFO_FIRMWARE("wait lpw ready (state = %d)\n", state);
+	};
+	if (count > max_retry) {
+		RPU_INFO_FIRMWARE("%s: download patch2 failed\n", __func__);
+		ret = -1;
+		goto fail;
+	} else {
+		RPU_INFO_FIRMWARE("%s: download patch2 success\n", __func__);
+	}	
+
+	// clear patch len
+	ret = rk915_writeb(priv, IO_PATCH_LEN_L, 0);
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch2 rk915_writeb failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+	ret = rk915_writeb(priv, IO_PATCH_LEN_H, 0);
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch2 rk915_writeb failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+fail:
+	priv->during_fw_download = 0;
+	return ret;
+}
+
+/* return 0 means fw download success, otherwise fail */
+int rk915_download_firmware(struct hal_priv *priv)
+{
+	struct host_io_info *host = (struct host_io_info *)priv->io_info;
+	struct firmware_info *fw_info;
+
+#ifdef SKIP_DL_FW
+	return 0;
+#endif
+
+	fw_info = &(priv->io_info->firmware);
+
+	/* get info of firmware and rompatch */
+	if (rk915_get_firmware_info(host, fw_info)) {
+		RPU_ERROR_FIRMWARE("%s: get firmeware error!.\n", __func__);
+		return -1;
+	}
+
+	fw_info->fw_saved = 1;
+
+	return rk915_download(priv);
+}
+
+#if defined(LPW_RECOVERY_FROM_RPU)
+int rk915_download_firmware_patch_only(struct hal_priv *priv)
+{
+	struct firmware_info *fw_info;
+	struct io_tx_ctrl_info info;	
+	int delay_ms = 10, count = 0, max_retry = 100;
+	int ret = 0;
+	int state;
+
+	fw_info = &(priv->io_info->firmware);
+
+	/* download patch2 */
+	RPU_DEBUG_FIRMWARE("%s: start download patch2, patch2_size = %d\n", __func__, fw_info->patch2_size);
+
+	memset(&info, 0, sizeof(struct io_tx_ctrl_info));
+	info.type = IO_TX_PKT_PATCH;
+	info.patch_len = fw_info->patch2_size;
+
+	count = 0;
+	
+	while (1) 
+	{
+		state = rk915_readb(priv, IO_FW_STATE);
+		if (state == WAIT_PATCH2)
+			break;
+		if (count++ > max_retry)
+			break;
+		mdelay(delay_ms);
+		if (net_ratelimit())
+			RPU_DEBUG_FIRMWARE("wait lpw changing state to WAIT_PATCH2 (state = %d), count=%d\n", state, count);
+	};
+
+	if (count >= max_retry) {
+		rk915_signal_io_error(FW_ERR_LPW_RECOVERY);
+		ret = -1;
+		goto fail;
+	}
+
+	mdelay(50);
+	
+	ret = rk915_writeb(priv, IO_PATCH_LEN_L, (info.patch_len & 0x00ff));
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch2 rk915_writeb failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+	ret = rk915_writeb(priv, IO_PATCH_LEN_H, (info.patch_len & 0xff00) >> 8);
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch2 rk915_writeb failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+	ret = rk915_data_write(priv, IO_PATCH_ADDR, fw_info->patch2_data, fw_info->patch2_size);
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch2 failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+	count = 0;
+	while (1) {
+		state = rk915_readb(priv, IO_FW_STATE);
+		if (state >= LPW_READY)
+			break;
+		if (count++ > max_retry)
+			break;
+		mdelay(delay_ms);
+		//if (net_ratelimit())
+		//	RPU_DEBUG_FIRMWARE("wait lpw ready (state = %d), count=%d\n", state, count);
+	};
+	if (count > max_retry) {
+		RPU_INFO_FIRMWARE("%s: download patch2 failed\n", __func__);
+		ret = -1;
+		goto fail;
+	} else {
+		RPU_INFO_FIRMWARE("%s: download patch2 success\n", __func__);
+	}		
+
+	// clear patch len
+	ret = rk915_writeb(priv, IO_PATCH_LEN_L, 0);
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch2 rk915_writeb failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+	ret = rk915_writeb(priv, IO_PATCH_LEN_H, 0);
+	if (ret) {
+		RPU_ERROR_FIRMWARE("%s: downlaod patch2 rk915_writeb failed (%d)\n", __func__, ret);
+		goto fail;
+	}
+
+fail:	
+
+	return ret;
+}
+#endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/hal.c b/drivers/net/wireless/rockchip_wlan/rk915/src/hal.c
new file mode 100755
index 000000000..020b38dde
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/hal.c
@@ -0,0 +1,1971 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <asm/unaligned.h>
+
+#include <linux/clk.h>
+#include <linux/etherdevice.h>
+#include <linux/iio/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/netdevice.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_device.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/sort.h>
+#include <linux/time.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/workqueue.h>
+#include <linux/suspend.h>
+
+
+#include "core.h"
+#include "hal.h"
+#include "hal_common.h"
+#include "soc.h"
+#include "wow.h"
+#include "hal_io.h"
+#include "if_io.h"
+#include "platform.h"
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+#include <uapi/linux/sched/types.h>
+#endif
+
+#define ENABLE_RX_WORKQ		1
+/* TODO: Remove this once we get proper register address for
+ * sleep controller
+ */
+extern unsigned long pci_bar_addr;
+#define COMMAND_START_MAGIC 0xDEAD
+
+//static int is_mem_bounce(void *virt_addr, int len);
+
+/* compliant ioremap */
+#define VIRT_TO_PHYS(addr) \
+		(HAL_HOST_RPU_RAM_START + \
+		 (addr) - \
+		 hpriv->base_addr_rpu_host_ram)
+const char *hal_name = "RPU_WIFI_HAL";
+static unsigned long shm_offset = HAL_SHARED_MEM_OFFSET;
+module_param(shm_offset, ulong, S_IRUSR|S_IWUSR);
+
+static unsigned int hal_cmd_sent = 0;
+static unsigned int hal_cmd_tx_send = 0;
+static unsigned int hal_event_recv = 0;
+static unsigned int hal_event_tx_done = 0;
+static unsigned int hal_event_cmd_proc_done = 0;
+static unsigned int hal_event_rx_recv = 0;
+static unsigned int hal_event_interrupts = 0;
+static unsigned int hal_event_rx_counts_one_interrupts[8];
+static unsigned int hal_event_rx_counts_one_packet[8];
+//static struct timer_list stats_timer;
+static unsigned int alloc_skb_failures;
+
+//static unsigned int rpu_ddr_base;
+
+
+/* for send and receive count. */
+static unsigned long tx_cnt;
+static unsigned long rx_cnt;
+/*RPU_DEBUG_HAL */
+
+bool block_rpu_comm;
+
+#ifdef RPU_SLEEP_ENABLE
+enum RPU_SLEEP_TYPE rpu_sleep_status = RPU_SLEEP;
+bool waiting_for_rpu_ready = false;
+#endif
+
+unsigned char vif_macs[2][ETH_ALEN];
+char *mac_addr;
+
+module_param(mac_addr, charp, 0000);
+MODULE_PARM_DESC(mac_addr, "Configure wifi base mac address");
+
+
+/* Range check */
+#define CHECK_EVENT_ADDR_RPU(x) ((x) >= HAL_RPU_GRAM_BASE && (x) <=\
+				  (HAL_RPU_GRAM_BASE + \
+				  hpriv->rpu_pkd_gram_len))
+
+#define CHECK_EVENT_STATUS_ADDR_RPU(x) ((x) >= HAL_RPU_GRAM_BASE && (x) <=\
+					 (HAL_RPU_GRAM_BASE + \
+					 hpriv->rpu_pkd_gram_len))
+
+#define CHECK_EVENT_LEN(x) ((x) < 0x5000)
+#define CHECK_RX_PKT_CNT(x) ((x) >= 1 && (x) <= 16)
+/* #define CHECK_SRC_PTR(x, y) ((x) >= (y) && (x) <= (y) +
+ * HAL_HOST_BOUNCE_BUF_LEN)
+ */
+#define CHECK_PKT_DESC(x) ((x) < (hpriv->rx_bufs_2k + hpriv->rx_bufs_12k))
+/* MAX_RX_BUFS */
+
+
+
+
+#ifdef RPU_SLEEP_ENABLE
+
+int check_and_wakeup_rpu_nonblocking(void)
+{
+	return true;
+}
+
+static void trigger_timed_sleep(int val)
+{
+}
+ 
+static bool get_rpu_sleep_status(void)
+{
+	return RPU_AWAKE;
+}
+
+static void trigger_wakeup(enum RPU_SLEEP_TYPE val)
+{
+	return;
+}
+#endif /* RPU_SLEEP_ENABLE */
+
+static int hal_reset_hal_params(void)
+{
+	hpriv->cmd_cnt = COMMAND_START_MAGIC;
+	hpriv->event_cnt = 0;
+	return 0;
+}
+
+
+static int hal_ready(struct hal_priv *priv)
+{
+	return 1;
+}
+
+#ifdef SDIO_TXRX_STABILITY_TEST
+void hal_send_direct(void *msg)
+{
+	int ret;
+	struct sk_buff *skb = (struct sk_buff *)msg;
+
+	ret = rk915_data_write(hpriv, 0, skb->data, skb->len);
+	if (ret)
+		RPU_ERROR_HAL("%s: ret = %d, pkt_len = %d.\n", __func__, ret, skb->len);
+
+	dev_kfree_skb_any(skb);
+}
+#endif
+
+#ifdef TX_SG_MODE
+#define ARRAYSIZE(a)		(sizeof(a) / sizeof(a[0]))
+static struct scatterlist sg_list[12];
+#endif
+
+#include <../net/mac80211/ieee80211_i.h>
+
+#define CMD_RESET_BIT           (1<<0)
+#define CMD_TX_POWER_BIT        (1<<1)
+#define CMD_VIF_CTRL_BIT        (1<<2)
+#define CMD_VIF_CFG_BIT         (1<<3)
+#define CMD_TXQ_PARAMS_BIT      (1<<4)
+#define CMD_CHANNEL_BIT         (1<<5)
+#define CMD_PS_BIT              (1<<6)
+#define CMD_MCST_ADDR_CFG_BIT   (1<<7)
+#define CMD_MCST_FLTR_CTRL_BIT  (1<<8)
+#define CMD_SETKEY_BIT          (1<<9)
+
+struct lpw_recovery_param{
+	u32                          flag;
+	//u32                          vif_count;
+	u32                          active_vifs;
+	u32							 mcst_addr_count;
+	u32                          active_keyset[MAX_VIFS];
+	u32                          vif_cfg_valid[MAX_VIFS];
+	u32                          txq_params_valid[MAX_VIFS];
+	u32                          ps_para_valid[MAX_VIFS];
+	u32                          patch_size;
+	u32                          patch_transfer;
+	#define       RECOVERY_STATUS_WAIT_RESET_COMP  1
+	#define       RECOVERY_STATUS_RESET_COMP       2
+	u32                 status;
+	u32                          latest_UMAC_cmd;
+	struct cmd_reset             reset_param;
+	struct cmd_tx_pwr            tx_pwr_param;
+	struct cmd_vifctrl           vifctrl_param[MAX_VIFS];
+	struct cmd_vif_cfg           vif_cfg_param[MAX_VIFS];
+	struct cmd_txq_params        txq_params[MAX_VIFS][4];
+	struct cmd_channel           channel_params;
+	struct cmd_ps                ps_param[MAX_VIFS];
+	struct cmd_mcst_addr_cfg     mcst_addr_cfg_param[MCST_ADDR_LIMIT];
+	struct cmd_mcst_filter_ctrl  mcst_fltr_ctrl_param;
+	struct cmd_setkey            setkey_param[MAX_VIFS][NUM_DEFAULT_KEYS+NUM_DEFAULT_MGMT_KEYS];
+};
+
+static struct lpw_recovery_param g_lpw_recovery_param;
+
+static void init_fw_recovery_cmd(void)
+{
+	RPU_DEBUG_ROCOVERY("%s\n", __func__);
+	memset(&g_lpw_recovery_param, 0, sizeof(struct lpw_recovery_param));
+}
+
+static int save_fw_recovery_cmd(void *cmd)
+{
+	struct host_rpu_msg_hdr *phdr = (struct host_rpu_msg_hdr *)cmd;
+
+    switch(phdr->id)
+	{
+		case RPU_CMD_RESET:
+		{
+			u32  counter;
+			struct cmd_reset *cmd_rst = (struct cmd_reset *)cmd;
+			/* Reset context. 
+			   UMAC_CMD_RESET should be the first or last command
+			 */
+			if (cmd_rst->type == LMAC_DISABLE)
+				break;
+
+			g_lpw_recovery_param.flag = 0;
+			g_lpw_recovery_param.active_vifs = 0;
+			g_lpw_recovery_param.mcst_addr_count = 0;
+			//g_lpw_recovery_param.vif_count = 0;
+
+			for(counter = 0; counter < MAX_VIFS; counter++)
+			{
+				g_lpw_recovery_param.vif_cfg_param[counter].changed_bitmap = 0;
+				g_lpw_recovery_param.active_keyset[counter] = 0;
+				g_lpw_recovery_param.vif_cfg_valid[counter] = 0;
+				g_lpw_recovery_param.txq_params_valid[counter] = 0;
+				g_lpw_recovery_param.ps_para_valid[counter] = 0;
+			}
+			
+			memcpy((void *)&g_lpw_recovery_param.reset_param,
+				(void *)cmd,sizeof(struct cmd_reset));
+
+			//if(g_lpw_recovery_param.reset_param.type != LMAC_DISABLE)
+			{
+				g_lpw_recovery_param.flag |= CMD_RESET_BIT;
+			}
+			break;
+		}
+		case RPU_CMD_TX_POWER:
+		{
+			memcpy((void*)&g_lpw_recovery_param.tx_pwr_param, 
+				(void *)cmd, sizeof(struct cmd_tx_pwr));
+			g_lpw_recovery_param.flag |= CMD_TX_POWER_BIT;
+			break;
+		}
+		case RPU_CMD_VIF_CTRL:
+		{
+			struct cmd_vifctrl *vifctrl;
+			u32                 vif_index;
+
+			vifctrl = (struct cmd_vifctrl *)cmd;
+			vif_index = vifctrl->if_index;
+			
+			if(vifctrl->if_ctrl == IF_ADD)
+			{
+				/*
+				for(vif_index = 0; vif_index < MAX_VIFS; vif_index ++)
+				{
+					if(!(g_lpw_recovery_param.active_vifs & (1<<vif_index)))
+						break;
+				}
+				*/
+
+				if(vif_index >= MAX_VIFS)
+				{
+					//TODO: Print Debug Info 
+					break;
+				}
+				else
+				{
+					memcpy((void *)&g_lpw_recovery_param.vifctrl_param[vif_index],
+						   (void *)vifctrl, sizeof(struct cmd_vifctrl));
+					g_lpw_recovery_param.active_vifs |= (1<<vif_index);
+					g_lpw_recovery_param.flag |= CMD_VIF_CTRL_BIT;
+				}
+			}
+			else if(vifctrl->if_ctrl == IF_REM)
+			{
+				g_lpw_recovery_param.active_vifs &= ~(1<<vif_index);
+				memset((void *)&g_lpw_recovery_param.vifctrl_param[vif_index], 
+					0, sizeof(struct cmd_vifctrl));
+				//Caution: Re-use of local variable 'vif_index'
+				for(vif_index = 0; vif_index < MAX_VIFS; vif_index++)
+				{
+					if(g_lpw_recovery_param.active_vifs & (1<<vif_index))
+						break;
+				}
+				if(vif_index == MAX_VIFS)
+					g_lpw_recovery_param.flag &= ~CMD_VIF_CTRL_BIT;
+			}
+			
+			break;
+		}
+		case RPU_CMD_VIF_CFG:
+		{
+
+			u32 vif_index;
+			u32 changed_bitmap;
+			struct cmd_vif_cfg *new_vif_cfg;
+			struct cmd_vif_cfg *old_vif_cfg;
+
+			new_vif_cfg = (struct cmd_vif_cfg *)cmd;
+
+			vif_index = new_vif_cfg->if_index;
+			changed_bitmap = new_vif_cfg->changed_bitmap;
+
+			if(vif_index >= MAX_VIFS)
+			{
+				//TODO: Print Debug Info 
+				break;
+			}
+			else
+			{
+			
+				old_vif_cfg = (struct cmd_vif_cfg *)&g_lpw_recovery_param.vif_cfg_param[vif_index];
+
+				if(g_lpw_recovery_param.vif_cfg_valid[vif_index] != 1)
+				{
+					memcpy((void *)old_vif_cfg, (void *)new_vif_cfg, sizeof(struct cmd_vif_cfg));
+					g_lpw_recovery_param.vif_cfg_valid[vif_index] = 1;
+				}
+				else
+				{
+					//TODO: Need to revise changed item, because some items are not set via VIF_CFG
+					if(changed_bitmap & BASICRATES_CHANGED)
+					{
+						old_vif_cfg->basic_rate_set = new_vif_cfg->basic_rate_set;
+					}
+					if(changed_bitmap & SHORTSLOT_CHANGED)
+					{
+						old_vif_cfg->use_short_slot = new_vif_cfg->use_short_slot;
+					}
+					if(changed_bitmap & ATIMWINDOW_CHANGED)
+					{
+						old_vif_cfg->atim_window = new_vif_cfg->atim_window;
+					}
+					if(changed_bitmap & AID_CHANGED)
+					{
+						old_vif_cfg->aid = new_vif_cfg->aid;
+					}
+					if(changed_bitmap & CAPABILITY_CHANGED)
+					{
+						old_vif_cfg->capability = new_vif_cfg->capability;
+					}
+					if(changed_bitmap & SHORTRETRY_CHANGED)
+					{
+						old_vif_cfg->short_retry = new_vif_cfg->short_retry;
+					}
+					if(changed_bitmap & LONGRETRY_CHANGED)
+					{
+						old_vif_cfg->long_retry = new_vif_cfg->long_retry;
+					}
+					if(changed_bitmap & BSSID_CHANGED)
+					{
+						memcpy((void *)&old_vif_cfg->bssid[0],
+								(void *)&new_vif_cfg->bssid[0], ETH_ALEN*sizeof(unsigned char));
+					}
+					if(changed_bitmap & RCV_BCN_MODE_CHANGED)
+					{
+						old_vif_cfg->bcn_mode = new_vif_cfg->bcn_mode;
+					}
+					if(changed_bitmap & BCN_INT_CHANGED)
+					{
+						old_vif_cfg->beacon_interval = new_vif_cfg->beacon_interval;
+					}
+					if(changed_bitmap & DTIM_PERIOD_CHANGED)
+					{
+						old_vif_cfg->dtim_period = new_vif_cfg->dtim_period;
+					}
+					if(changed_bitmap & SMPS_CHANGED)
+					{
+						old_vif_cfg->smps_info = new_vif_cfg->smps_info;
+					}
+					if(changed_bitmap & CONNECT_STATE_CHANGED)
+					{
+						old_vif_cfg->connect_state = new_vif_cfg->connect_state;
+					}
+					if(changed_bitmap & OP_CHAN_CHANGED)
+					{
+						old_vif_cfg->op_channel = new_vif_cfg->op_channel;
+					}
+					old_vif_cfg->changed_bitmap |= changed_bitmap;
+
+					//There is no vif_addr added in the RCV_BCN_MODE_CHANGED config
+					if(changed_bitmap != RCV_BCN_MODE_CHANGED)
+						memcpy((void*)&old_vif_cfg->vif_addr[0],
+							(void *)&new_vif_cfg->vif_addr[0], ETH_ALEN*sizeof(unsigned char));
+				}
+			}
+			
+			g_lpw_recovery_param.flag |= CMD_VIF_CFG_BIT;
+			break;
+		}
+
+		case RPU_CMD_TXQ_PARAMS:
+		{
+			u32 vif_index;
+			u32 queue_num;
+			struct cmd_txq_params * txq_params;
+
+			txq_params = (struct cmd_txq_params *)cmd;
+
+			vif_index = txq_params->if_index;
+			queue_num = txq_params->queue_num;
+
+			if(vif_index >= MAX_VIFS || queue_num >= 4)
+			{
+				//TODO: Print Debug Info here
+				break;
+			}
+			else
+			{
+				memcpy((void *)&g_lpw_recovery_param.txq_params[vif_index][queue_num],
+					(void *)txq_params, sizeof(struct cmd_txq_params));
+				g_lpw_recovery_param.txq_params_valid[vif_index] |= (1<<queue_num);
+				g_lpw_recovery_param.flag |= CMD_TXQ_PARAMS_BIT;
+			}
+			break;
+		}
+		case RPU_CMD_CHANNEL:
+		{
+			memcpy((void *)&g_lpw_recovery_param.channel_params,
+				(void *)cmd, sizeof(struct cmd_channel));
+			g_lpw_recovery_param.flag |= CMD_CHANNEL_BIT;
+			break;
+		}
+		case RPU_CMD_PS:
+		{
+			u32 vif_index;
+			struct cmd_ps * ps;
+
+			ps = (struct cmd_ps *)cmd;
+			vif_index = ps->if_index;
+
+			if(vif_index >= MAX_VIFS)
+			{
+				//TODO: Print Debug Info
+				break;
+			}
+			else
+			{
+				memcpy((void *)&g_lpw_recovery_param.ps_param[vif_index],
+					(void *)ps, sizeof(struct cmd_ps));
+				g_lpw_recovery_param.ps_para_valid[vif_index] = 1;
+				g_lpw_recovery_param.flag |= CMD_PS_BIT;
+			}
+			break;
+		}
+		case RPU_CMD_MCST_ADDR_CFG:
+		{
+			u32 op;
+			struct cmd_mcst_addr_cfg * mcst_addr_cfg;
+
+			mcst_addr_cfg = (struct cmd_mcst_addr_cfg *)cmd;
+
+			op = mcst_addr_cfg->op;
+
+			if(op == WLAN_MCAST_ADDR_REM)
+			{
+				/* Play a little trick here, when calling prepare_multicast() function in Host Driver,
+				   It always remove all the old mcst addresses, and config new ones
+				*/
+				g_lpw_recovery_param.mcst_addr_count = 0;
+				g_lpw_recovery_param.flag &= ~CMD_MCST_ADDR_CFG_BIT;
+			}
+			else if(op == WLAN_MCAST_ADDR_ADD)
+			{
+				if(g_lpw_recovery_param.mcst_addr_count < MCST_ADDR_LIMIT)
+				{
+					memcpy((void *)&g_lpw_recovery_param.mcst_addr_cfg_param[g_lpw_recovery_param.mcst_addr_count],
+						(void *)mcst_addr_cfg, sizeof(struct cmd_mcst_addr_cfg));
+					g_lpw_recovery_param.mcst_addr_count++;
+					g_lpw_recovery_param.flag |= CMD_MCST_ADDR_CFG_BIT;
+				}
+			}
+			break;
+		}
+		case RPU_CMD_MCST_FLTR_CTRL:
+		{
+			memcpy((void *)&g_lpw_recovery_param.mcst_fltr_ctrl_param,
+				(void *)cmd, sizeof(struct cmd_mcst_filter_ctrl));
+			g_lpw_recovery_param.flag |= CMD_MCST_FLTR_CTRL_BIT;
+			break;
+		}
+		case RPU_CMD_SETKEY:
+		{
+			u32 vif_index;
+			u32 key_id;
+			struct cmd_setkey * setkey;
+
+			setkey = (struct cmd_setkey *)cmd;
+
+			vif_index = setkey->if_index;
+			key_id = setkey->key_id;
+
+			if(vif_index < MAX_VIFS && key_id < (NUM_DEFAULT_KEYS+NUM_DEFAULT_MGMT_KEYS))
+			{
+				if(setkey->ctrl == KEY_CTRL_ADD)
+				{
+					g_lpw_recovery_param.active_keyset[vif_index] |= (1<<(key_id));
+					memcpy((void *)&g_lpw_recovery_param.setkey_param[vif_index][key_id],
+						(void *)setkey, sizeof(struct cmd_setkey));
+				}
+				else if(setkey->ctrl == KEY_CTRL_DEL)
+				{
+					g_lpw_recovery_param.active_keyset[vif_index] &= ~(1<<(key_id));
+				}
+			}
+
+			//CAUTION: Re-use vif_index
+			for(vif_index = 0; vif_index < MAX_VIFS; vif_index++)
+			{
+				if(g_lpw_recovery_param.active_keyset[vif_index] != 0)
+					break;
+			}
+			if(vif_index == MAX_VIFS)
+			{
+				//No activated key
+				g_lpw_recovery_param.flag &= ~CMD_SETKEY_BIT;
+			}
+			else
+			{
+				g_lpw_recovery_param.flag |= CMD_SETKEY_BIT;
+			}
+			break;
+		}
+		case RPU_CMD_TX:
+		{
+			struct cmd_tx_ctrl * cmd_tx;
+			struct img_priv *priv = wifi->hw->priv;
+
+			cmd_tx = (struct cmd_tx_ctrl *)cmd;
+			priv->tx.tx_desc_had_send_to_io[cmd_tx->descriptor_id] = 1;
+			break;
+		}
+		default:
+			break;
+	}
+
+	return 0;
+}
+
+static void cmd_send(u8 *cmd, int len)
+{
+	struct sk_buff *cmd_skb;
+
+	/* the address of cmd should 4bytes aligned */
+	cmd_skb = alloc_skb(len, GFP_ATOMIC);
+	if (cmd_skb) {
+		hpriv->fw_error_cmd_done = 0;
+		
+		memcpy(skb_put(cmd_skb, len), cmd, len);
+		rk915_data_write(hpriv, 0, (void *)cmd_skb->data, len);
+		dev_kfree_skb_any(cmd_skb);
+
+		wait_for_fw_error_cmd_done(NULL);
+	}
+}
+
+static void send_fw_recovery_cmd(void)
+{
+	u32 vif_index;
+
+	/* Re-set parameters */
+	if(g_lpw_recovery_param.flag & CMD_RESET_BIT)
+	{
+		//RESET CMD(LMAC_ENABLE)
+		RPU_DEBUG_ROCOVERY("send CMD_RESET\n");
+		g_lpw_recovery_param.status = RECOVERY_STATUS_WAIT_RESET_COMP;
+		cmd_send((u8 *)&g_lpw_recovery_param.reset_param, sizeof(struct cmd_reset));
+
+		//Wait for RESET COMPLETE
+		while(1)
+		{
+			//RPU_DEBUG_ROCOVERY("wait reset complet %d\n", g_lpw_recovery_param.status);
+			if(g_lpw_recovery_param.status == RECOVERY_STATUS_RESET_COMP)
+			{	
+				break;
+			}
+			msleep(50);
+		}
+
+		if (hpriv->fw_error_reason == FW_ERR_RESET_CMD ||
+			g_lpw_recovery_param.reset_param.type == LMAC_DISABLE) {
+			return;
+		}
+		
+		//TX POWER
+		if(g_lpw_recovery_param.flag & CMD_TX_POWER_BIT)
+		{
+			RPU_DEBUG_ROCOVERY("send CMD_TX_POWER\n");
+			cmd_send((u8 *)&g_lpw_recovery_param.tx_pwr_param, sizeof(struct cmd_tx_pwr));
+		}
+
+		//Add VIFs/VIF config/TXQ params/PS params/Set Key
+		if(g_lpw_recovery_param.flag & CMD_VIF_CTRL_BIT)
+		{
+			RPU_DEBUG_ROCOVERY("send CMD_VIF_CTRL\n");
+			for(vif_index = 0; vif_index < MAX_VIFS; vif_index++)
+			{
+				if(g_lpw_recovery_param.active_vifs & (1<<vif_index))
+				{
+					//Add VIF
+					cmd_send((u8 *)&g_lpw_recovery_param.vifctrl_param[vif_index], sizeof(struct cmd_vifctrl));
+
+					//VIF config
+					if((g_lpw_recovery_param.flag & CMD_VIF_CFG_BIT) && (g_lpw_recovery_param.vif_cfg_valid[vif_index] == 1))
+					{
+						cmd_send((u8 *)&g_lpw_recovery_param.vif_cfg_param[vif_index], sizeof(struct cmd_vif_cfg));
+					}
+
+					//TXQ params
+					if(g_lpw_recovery_param.flag & CMD_TXQ_PARAMS_BIT) 
+					{
+						u32 queue_num;
+						for(queue_num = 0; queue_num < 4; queue_num++)
+						{
+							if(g_lpw_recovery_param.txq_params_valid[vif_index] & (1<<queue_num))
+							{
+								cmd_send((u8 *)&g_lpw_recovery_param.txq_params[vif_index][queue_num], sizeof(struct cmd_txq_params));
+							}
+						}
+					}
+
+					//PS param
+					if((g_lpw_recovery_param.flag & CMD_PS_BIT) && (g_lpw_recovery_param.ps_para_valid[vif_index] == 1))
+					{
+						cmd_send((u8 *)&g_lpw_recovery_param.ps_param[vif_index], sizeof(struct cmd_ps));
+					}
+
+					//Set Key
+					if((g_lpw_recovery_param.flag & CMD_SETKEY_BIT) && (g_lpw_recovery_param.active_keyset[vif_index] != 0))
+					{
+						u32 key_id;
+
+						for(key_id = 0; key_id < (NUM_DEFAULT_KEYS+NUM_DEFAULT_MGMT_KEYS);key_id++)
+						{
+							if(g_lpw_recovery_param.active_keyset[vif_index] & (1<<key_id))
+							{
+								cmd_send((u8 *)&g_lpw_recovery_param.setkey_param[vif_index][key_id], sizeof(struct cmd_setkey));
+							}
+						}
+					}
+				}
+			}
+		}
+
+		//Channel
+		if(g_lpw_recovery_param.flag & CMD_CHANNEL_BIT)
+		{
+			RPU_DEBUG_ROCOVERY("send CMD_CHANNEL\n");
+			cmd_send((u8 *)&g_lpw_recovery_param.channel_params, sizeof(struct cmd_channel));
+		}
+
+		//MCST ADDR
+		if(g_lpw_recovery_param.flag & CMD_MCST_ADDR_CFG_BIT)
+		{
+			u32 counter;
+
+			RPU_DEBUG_ROCOVERY("send CMD_MCST_ADDR_CFG\n");
+			for(counter = 0; counter < g_lpw_recovery_param.mcst_addr_count; counter++)
+			{
+				cmd_send((u8 *)&g_lpw_recovery_param.mcst_addr_cfg_param[counter], sizeof(struct cmd_mcst_addr_cfg));
+			}
+		}
+
+		//MCST FLTR CTRL
+		if(g_lpw_recovery_param.flag & CMD_MCST_FLTR_CTRL_BIT)
+		{
+			RPU_DEBUG_ROCOVERY("send CMD_MCST_FLTR_CTRL\n");
+			cmd_send((u8 *)&g_lpw_recovery_param.mcst_fltr_ctrl_param, sizeof(struct cmd_mcst_filter_ctrl));
+		}
+	}    
+}
+
+extern void rpu_process_pending_operates(void);
+static void fw_err_work_fn(struct work_struct *work)
+{
+	RPU_DEBUG_ROCOVERY("%s\n", __func__);
+
+	if (hpriv->shutdown)
+		goto unlock_out;
+
+	// clear pending rx_serias info 
+	hpriv->io_info->rx_serias_count = 0;
+	hpriv->io_info->rx_next_len = 0;
+
+#if ENABLE_RX_WORKQ
+	wait_for_rxq_empty(NULL);
+#endif
+
+	// 1. reset rk915
+	RPU_DEBUG_ROCOVERY("reset\n");
+	hpriv->fw_tear_down_func((void *)hpriv);
+	hpriv->hal_disabled = 1;
+	hpriv->fw_bring_up_func((void *)hpriv);
+
+	// 2. recovery cmds
+	RPU_DEBUG_ROCOVERY("recovery cmds\n");
+	hpriv->hal_disabled = 0;
+	send_fw_recovery_cmd();
+
+	hpriv->fw_error_processing = 0;
+	hpriv->fw_error = 0;
+
+	if (hpriv->fw_error_reason != FW_ERR_RESET_CMD) {
+		// 3. process unfinished tx done
+		RPU_DEBUG_ROCOVERY("process unfinished tx done\n");
+		rpu_tx_proc_unfi_tx_done();
+	}
+
+	// 4. restore pending command in fw error.
+	RPU_DEBUG_ROCOVERY("restore pending command\n");
+	rpu_process_pending_operates();
+
+	RPU_ERROR_ROCOVERY("-------- fw error recovery end --------\n");
+
+unlock_out:
+	if (wake_lock_active(&hpriv->fw_err_lock))
+		wake_unlock(&hpriv->fw_err_lock);
+}
+
+//static void tx_tasklet_fn(unsigned long data)
+#ifdef TX_USE_THREAD
+static int tx_thread(void *data)
+#else
+static void tx_work_fn(struct work_struct *work)
+#endif
+{
+#ifdef TX_USE_THREAD
+	tsk_ctl_t *tsk = (tsk_ctl_t *)data;
+	struct hal_priv *priv = (struct hal_priv *)tsk->parent;
+	static struct sched_param param = { .sched_priority = 1 };
+#else
+	struct hal_priv *priv = container_of(work, struct hal_priv, tx_work);
+#endif
+	struct sk_buff *skb;
+	unsigned long start = 0;
+	int ret;
+#ifdef TX_SG_MODE
+	struct cmd_tx_ctrl *tx_cmd;
+	unsigned int pkt = 0;
+	unsigned int new_pkt_len, total_size = 0, align_len = 0;
+	sg_init_table(sg_list, ARRAYSIZE(sg_list));
+#endif
+	struct img_priv *imgpriv;
+	struct host_rpu_msg_hdr *phdr;
+#ifdef DUMP_MORE_DEBUG_INFO
+	char cmd_str[64];
+#endif
+
+#ifndef TX_USE_THREAD
+	if (hpriv->fw_error_processing)
+		return;
+#endif
+
+#ifdef TX_USE_THREAD
+	sched_setscheduler(current, SCHED_FIFO, &param);
+	//complete(&tsk->completed);
+#endif
+
+#ifdef TX_USE_THREAD
+    while (1) {
+    	if (down_interruptible(&tsk->sema) != 0) {
+    		break;
+    	}
+
+    	if (tsk->terminated)
+    		break;
+
+    	if (hpriv->fw_error_processing || !hpriv->hal_init)
+    		continue;
+#endif        
+    	while (1) {
+    		if (skb_peek(&priv->txq) == NULL)
+    			break;
+
+    		if (block_rpu_comm) {
+    			RPU_INFO_TX("%s: break with block_rpu_comm\n", __func__);
+    			break;
+    		}
+
+    		skb = skb_dequeue(&priv->txq);
+    		if (skb == NULL)
+    			break;
+
+    		tx_cnt++;
+#if 0//def RPU_SLEEP_ENABLE
+    		if (check_and_wakeup_rpu_nonblocking() == false) {
+    			RPU_ERROR_HAL("%s:%d Dropping CMD , qlen: %d\n",
+    				__func__,__LINE__,skb_queue_len(&priv->txq));
+    			return;
+    		}
+#endif
+    		RPU_DEBUG_HAL("%s: tx_cnt=%ld cmd_cnt=0x%X event_cnt=0x%X\n",
+    				hal_name,
+    				tx_cnt,
+    				priv->cmd_cnt,
+    				priv->event_cnt);
+    		if (DUMP_HAL) {
+    			RPU_DEBUG_HAL("%s: xmit dump\n", hal_name);
+    			RPU_DEBUG_DUMP_HAL(" ", DUMP_PREFIX_NONE, 16, 4,
+    					 skb->data, 32, 1);
+    		}
+
+    		start = jiffies;
+
+    		while (!hal_ready(priv) &&
+    		     time_before(jiffies, start + msecs_to_jiffies(1000))) {
+    			cpu_relax();
+    		}
+
+    		if (!hal_ready(priv)) {
+    			RPU_ERROR_HAL("%s: Intf not ready for 1000ms, dropping cmd\n",
+    			       hal_name);
+    			dev_kfree_skb_any(skb);
+    			skb = NULL;
+    		}
+
+    		if (!skb)
+    			continue;
+
+    		/* workaround m0 died problem during resume */
+    		phdr = (struct host_rpu_msg_hdr *)skb->data;
+    		if (phdr->id != RPU_CMD_RESET && phdr->id != RPU_CMD_PS_ECON_CFG) {
+    			imgpriv = wifi ? wifi->hw->priv:NULL;
+    			wait_for_pm_resume_done(imgpriv);
+            }
+
+#ifdef DUMP_MORE_DEBUG_INFO
+    		convert_cmd_to_str(phdr->id, cmd_str);
+    		RPU_INFO_HAL("send %s(%d)\n", cmd_str, phdr->id);
+#endif
+
+    		save_fw_recovery_cmd(skb->data);
+
+    		if (priv->hal_disabled) {
+    			dev_kfree_skb_any(skb);
+    			break;
+    		}
+
+#ifdef TXRX_DATA_LOCK
+    		/*
+    		  * when transmit tx cmd and continues tx data, it can't be interrupt by rx 
+    		  */
+    		mutex_lock(&priv->txrx_mutex);
+#endif
+
+#ifndef TX_SG_MODE
+    {
+    		//struct host_rpu_msg_hdr *tx_hdr = (struct host_rpu_msg_hdr *)skb->data;
+    		//RPU_INFO_HAL("send %d\n", tx_hdr->id);
+    }
+    		// 1. send cmd first
+    		ret = rk915_data_write(priv, 0, skb->data, skb->len);
+    		if (ret) {
+    			RPU_ERROR_HAL("%s: ret = %d, pkt_len = %d.\n",
+    						  __func__, ret, skb->len);
+    /*#ifdef TXRX_DATA_LOCK
+    			mutex_unlock(&priv->txrx_mutex);
+#endif			
+    			break;*/
+    		}
+    		// 2. if cmd has data, send data second
+    		if (rpu_is_cmd_has_data(skb->data)) {
+    			hal_cmd_tx_send++;
+#ifndef PKTGEN_MULTI_TX
+    			rpu_send_cmd_datas(skb->data, priv);
+#endif
+    		}
+#else
+    		tx_cmd = (struct cmd_tx_ctrl *)skb->data;
+
+    		if (tx_cmd->hdr.id == RPU_CMD_TX &&
+    			tx_cmd->num_frames_per_desc > 0) {
+
+    			RPU_INFO_TX("%s: num_frames_per_desc: %d, struct skb_shared_info size: %d.\n", __func__, tx_cmd->num_frames_per_desc, sizeof(struct skb_shared_info));
+
+    			BUG_ON(skb->len != 512);
+    			sg_set_buf(&sg_list[0], skb->data, skb->len);
+    			total_size += skb->len;
+    			RPU_INFO_TX("%s: ctrl frams: %p, %d\n", __func__, skb->data, skb->len);
+
+    			for (pkt = 0; pkt < tx_cmd->num_frames_per_desc; pkt++) {
+    				unsigned int pkt_len = tx_cmd->pkt_length[pkt];
+    				unsigned char *pkt_data = (unsigned char *)tx_cmd->p_frame_ddr_pointer[pkt];
+
+    				if (!pkt_data || pkt_len == 0) {
+    					RPU_ERROR_TX("%s: pkt_data(%p), pkt_len(%d)\n", __func__, pkt_data, pkt_len);
+    					continue;
+    				}
+
+    				if (pkt_len & 0x1f) {
+    					new_pkt_len = roundup(pkt_len, 32);
+    					tx_cmd->pkt_length[pkt] |= (new_pkt_len << 16);
+    					sg_set_buf(&sg_list[pkt + 1], pkt_data, new_pkt_len);
+    					total_size += new_pkt_len;
+    				} else {
+    					sg_set_buf(&sg_list[pkt + 1], pkt_data, pkt_len);
+    					total_size += pkt_len;
+    					tx_cmd->pkt_length[pkt] |= (pkt_len << 16);
+    				}
+
+    				RPU_INFO_TX("===%s: send: (pkt=%d) %p:[0x%x, 0x%x], %d, NEW: %d XLEN: 0x%x.\n",
+    							 __func__, pkt, pkt_data, pkt_data[0], pkt_data[pkt_len -1], pkt_len, new_pkt_len, tx_cmd->pkt_length[pkt]);
+
+    				if (((pkt + 1) == tx_cmd->num_frames_per_desc) && (total_size % 0x200)) {
+    					align_len = 512 - (total_size % 0x200);
+    					pr_err("align_len: %d.\n", align_len);
+    					sg_list[pkt + 1].length += align_len;
+    					tx_cmd->pkt_length[pkt] &= (0x0000ffff);
+    					tx_cmd->pkt_length[pkt] |= ((sg_list[pkt + 1].length) << 16);
+    					total_size += align_len;
+    				}
+    				pr_err("total_size: %d, pkt: %d, [%d, %d].\n", total_size, pkt, pkt + 1, total_size % 0x200);
+    			}
+
+    			pr_err("sg len: %d.\n", pkt + 1);
+    			ret = rk915_data_write_sg(priv, 0, sg_list, pkt + 1);
+    			if (ret)
+    				pr_err("%s: ret = %d\n", __func__, ret);
+
+    		} else if (tx_cmd->hdr.length > 512) {
+    			if (skb->len & 0x1ff) {
+    				new_pkt_len = roundup(skb->len, 512);
+    			}
+    			RPU_INFO_TX("%s: sdio send: %p %d, NEW: %d\n",
+    						 __func__, skb->data, skb->len, new_pkt_len);
+    			sg_set_buf(&sg_list[0], skb->data, new_pkt_len);
+    			ret = rk915_data_write_sg(priv, 0, sg_list, 1);
+    			if (ret)
+    				pr_err("%s: ret = %d\n", __func__, ret);
+    		} else {
+    			pr_err("NO TX: skb->len: %d.\n", skb->len);
+    			ret = rk915_data_write(priv, 0, skb->data, skb->len);
+    			//if (ret)
+    				RPU_ERROR_HAL("%s: ret = %d, pkt_len = %d.\n",
+    							  __func__, ret, skb->len);
+    		}
+#endif
+
+#ifdef TXRX_DATA_LOCK
+    		mutex_unlock(&priv->txrx_mutex);
+#endif
+    		
+    		priv->cmd_cnt++;
+    		hal_cmd_sent++;
+
+    		dev_kfree_skb_any(skb);
+    	}
+#ifdef TX_USE_THREAD        
+    }
+
+	complete_and_exit(&tsk->completed, 0);
+	RPU_INFO_HAL("%s exit\n", __func__);    
+#endif
+}
+
+#if ENABLE_RX_WORKQ
+static void hal_rx_queue_work(struct hal_priv  *priv)
+{
+	/*if(1) {
+		ieee80211_queue_work(hw, &priv->rx_work);
+	} else */{
+		queue_work(priv->rx_wkq, &priv->rx_work);
+	}
+}
+#endif
+
+static void hal_tx_queue_work(struct hal_priv *priv)
+{
+#ifdef TX_USE_THREAD
+	tsk_ctl_t *tsk = &priv->thr_tx_ctl;
+	if (tsk->thr_pid >= 0 && !priv->hal_disabled) {
+		up(&tsk->sema);
+	}
+#else
+	/*
+	if(1) {
+		ieee80211_queue_work(hw, &priv->tx_work);
+	} else 
+	*/
+	queue_work(priv->tx_wkq, &priv->tx_work);
+#endif
+}
+
+static void hal_rx_thread_trigger(struct hal_priv  *priv)
+{
+	tsk_ctl_t *tsk = &priv->thr_rx_ctl;
+	if (tsk->thr_pid >= 0 && !priv->hal_disabled) {
+		up(&tsk->sema);
+		hal_event_interrupts++;
+	}
+}
+
+static void _hal_send(struct hal_priv  *priv,
+			  struct sk_buff   *skb)
+{
+	skb_queue_tail(&priv->txq, skb);
+	//tasklet_schedule(&priv->tx_tasklet);
+	hal_tx_queue_work(priv);
+}
+
+#if 0
+static void _hal_send_head(struct hal_priv  *priv,
+			  struct sk_buff   *skb)
+{
+	printk("%s: qhead.\n", __func__);
+	skb_queue_head(&priv->txq, skb);
+	//tasklet_schedule(&priv->tx_tasklet);
+	hal_tx_queue_work(priv);
+}
+#endif
+
+static void hal_send(void *msg,
+		     void *payload,
+		     unsigned int descriptor_id)
+{
+
+	_hal_send(hpriv, msg);
+
+}
+
+#if ENABLE_RX_WORKQ
+static void hal_recv(struct hal_priv *priv, struct sk_buff *skb)
+{
+#define MAX_RX_QUEUE	8192
+	if (skb_queue_len(&priv->rxq) > MAX_RX_QUEUE) {
+		if (net_ratelimit()) {
+			struct host_rpu_msg_hdr *hdr = (struct host_rpu_msg_hdr *)skb->data;
+
+			RPU_ERROR_HAL("%s: rx queue large than %d, drop it(%p)(%d)!\n",
+					__func__, MAX_RX_QUEUE, skb, hdr->id);
+		}
+		dev_kfree_skb_any(skb);
+		return;
+	}
+	RPU_DEBUG_HAL("%s: rx enqueue %p\n", __func__, skb);
+	skb_queue_tail(&priv->rxq, skb);
+	if (priv->max_rxq_len < skb_queue_len(&hpriv->rxq))
+		priv->max_rxq_len = skb_queue_len(&hpriv->rxq);
+	hal_rx_queue_work(priv);
+}
+#endif
+
+#if 0
+static void recv_tasklet_fn(unsigned long data)
+{
+	struct hal_priv *priv = (struct hal_priv *)data;
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&priv->refillq))) {
+		/* As we refilled the buffers, now pass them UP */
+		priv->rcv_handler(skb);
+	}
+}
+#endif
+
+static void rx_counts_one_statistics(unsigned int count)
+{
+	// statistics how many rx data received in one interrupts
+	if (count <= 2*1024)
+		hal_event_rx_counts_one_interrupts[0]++;
+	else if (count <= 4*1024)
+		hal_event_rx_counts_one_interrupts[1]++;
+	else if (count <= 6*1024)
+		hal_event_rx_counts_one_interrupts[2]++;
+	else if (count <= 8*1024)
+		hal_event_rx_counts_one_interrupts[3]++;
+	else if (count <= 10*1024)
+		hal_event_rx_counts_one_interrupts[4]++;
+	else if (count <= 12*1024)
+		hal_event_rx_counts_one_interrupts[5]++;
+	else if (count <= 14*1024)
+		hal_event_rx_counts_one_interrupts[6]++;
+	else
+		hal_event_rx_counts_one_interrupts[7]++;
+}
+
+void rx_counts_one_packet(unsigned int count)
+{
+	// statistics how many rx data received in one packet
+	if (count <= 2*1024)
+		hal_event_rx_counts_one_packet[0]++;
+	else if (count <= 4*1024)
+		hal_event_rx_counts_one_packet[1]++;
+	else if (count <= 6*1024)
+		hal_event_rx_counts_one_packet[2]++;
+	else if (count <= 8*1024)
+		hal_event_rx_counts_one_packet[3]++;
+	else if (count <= 10*1024)
+		hal_event_rx_counts_one_packet[4]++;
+	else if (count <= 12*1024)
+		hal_event_rx_counts_one_packet[5]++;
+	else if (count <= 14*1024)
+		hal_event_rx_counts_one_packet[6]++;
+	else
+		hal_event_rx_counts_one_packet[7]++;
+}
+
+//static void rx_tasklet_fn(unsigned long data)
+#if ENABLE_RX_WORKQ
+static void rx_work_fn(struct work_struct *work)
+{
+	struct hal_priv *priv = container_of(work, struct hal_priv, rx_work);
+	struct sk_buff *skb;
+	//struct img_priv *imgpriv = wifi ? wifi->hw->priv:NULL;
+
+	while (1) {
+		if (skb_peek(&priv->rxq) == NULL)
+			break;
+
+		skb = skb_dequeue(&priv->rxq);
+		if (skb == NULL)
+			break;
+
+		RPU_DEBUG_HAL("%s: rx dequeue %p\n", __func__, skb);
+
+		priv->rcv_handler(skb);
+	}
+}
+#endif
+
+static int rx_thread(void *data)
+{
+	tsk_ctl_t *tsk = (tsk_ctl_t *)data;
+	struct hal_priv *priv = (struct hal_priv *)tsk->parent;
+	unsigned char *nbuff;
+	struct sk_buff *rx_skb;
+	struct host_rpu_msg_hdr *hdr;	
+	int data_length = 0;
+	unsigned int max_data_size = MAX_DATA_SIZE_2K;
+	unsigned int payload_length, length;
+	unsigned int event;
+	unsigned int rx_counts_one = 0;
+	static struct sched_param param = { .sched_priority = 1 };
+#ifdef DUMP_MORE_DEBUG_INFO
+	char evt_str[64];
+#endif
+
+	RPU_DEBUG_HAL("%s in\n", __func__);
+
+	memset(hal_event_rx_counts_one_interrupts, 0, 8*sizeof(unsigned int));
+	memset(hal_event_rx_counts_one_packet, 0, 8*sizeof(unsigned int));
+
+	sched_setscheduler(current, SCHED_FIFO, &param);
+	//complete(&tsk->completed);
+	while (1) {
+		if (priv->io_info->rx_serias_count == 0 &&
+			priv->io_info->rx_next_len == 0) {
+			if(rx_counts_one > 0) {
+				rx_counts_one_statistics(rx_counts_one);
+				rx_counts_one = 0;
+			}
+			if (down_interruptible(&tsk->sema) != 0) {
+				break;
+			}
+		}
+
+		if (tsk->terminated) {
+			break;
+		}
+		
+		rx_cnt++;
+		RPU_DEBUG_HAL("%s:rx_cnt=%ld cmd_cnt=0x%X event_cnt=0x%X\n",
+			 hal_name, rx_cnt, priv->cmd_cnt, priv->event_cnt);
+
+#ifdef TXRX_DATA_LOCK
+//		mutex_lock(&priv->txrx_mutex);
+#endif
+		data_length = rk915_serias_read(priv, 0, priv->io_info->rx_serias_buf,
+									  0, MAX_RX_SERIAS_BYTES);
+#ifdef TXRX_DATA_LOCK
+//		mutex_unlock(&priv->txrx_mutex);
+#endif
+		if (data_length <= 0) {
+			if (net_ratelimit())
+				RPU_ERROR_HAL("%s: error datalen: %x.\n", __func__, data_length);
+			priv->io_info->rx_serias_count = 0;
+			priv->io_info->rx_next_len = 0;
+			continue;
+		}
+		rx_counts_one += data_length;
+
+		rx_skb = alloc_skb(data_length, GFP_ATOMIC);
+		if (rx_skb) {
+			memcpy(skb_put(rx_skb, data_length),
+			       priv->io_info->rx_serias_buf_curr, data_length);
+		} else {
+			alloc_skb_failures++;
+			RPU_ERROR_HAL("%s: alloc_skb %d failed\n", __func__, data_length);
+			continue;
+		}
+		
+		nbuff = rx_skb->data;
+		hdr = (struct host_rpu_msg_hdr *)nbuff;
+		event = hdr->id & 0xffff;
+		if (event == RPU_EVENT_RX) {
+				hal_event_rx_recv++;
+				/* 802.11hdr + payload Len*/
+				payload_length = hdr->payload_length;
+				length = hdr->length;
+				/* Control Info Len*/
+				data_length = payload_length + length;
+
+				//RPU_INFO_HAL("receive %d (%d)\n", event, data_length);
+				/* Complete data length to be copied */
+				RPU_DEBUG_HAL("%s: Payload Len =%d(0x%x), \n",
+					   hal_name,
+					   payload_length,
+					   payload_length);
+
+				RPU_DEBUG_HAL("Len=%d(0x%x), \n",
+					   length,
+					   length);
+
+				RPU_DEBUG_HAL("Data Len = %d(0x%x)\n",
+					   data_length,
+					   data_length);
+				if (data_length > max_data_size) {
+					RPU_ERROR_HAL("Max length exceeded:\n");
+					RPU_ERROR_HAL(" payload_len: %d len:%d\n",
+						payload_length,
+						length);
+					continue;				
+				}
+		} else	{
+			//RPU_INFO_HAL("receive %d\n", event);
+			/* MSG from LMAC, non-data*/
+			if (event == RPU_EVENT_TX_DONE) {
+				hal_event_tx_done++;
+			} else if (event == RPU_EVENT_COMMAND_PROC_DONE) {
+				hal_event_cmd_proc_done++;
+			}
+			hal_event_recv++;
+		}
+
+		if (hpriv->fw_error_processing) {
+			RPU_DEBUG_ROCOVERY("event %d\n", event);
+			hpriv->fw_error_cmd_done = 1;
+			if (event == RPU_EVENT_RESET_COMPLETE &&
+				hdr->length == sizeof(struct host_event_reset_complete)) {
+				g_lpw_recovery_param.status = RECOVERY_STATUS_RESET_COMP;
+			}
+			dev_kfree_skb_any(rx_skb);
+			continue;
+		}
+
+		/*
+		 * we should notify ieee80211_connection_loss after device resume finished
+		 * else mac80211 will discard it
+		 */
+		if (event == RPU_EVENT_DISCONNECTED) {
+			wait_for_pm_resume_done(NULL);
+		}
+
+#ifdef DUMP_MORE_DEBUG_INFO
+		convert_event_to_str(event, evt_str);
+		RPU_INFO_HAL("receive %s(%d)\n", evt_str, event);
+#endif
+
+#if ENABLE_RX_WORKQ
+		hal_recv(priv, rx_skb);
+#else
+		priv->rcv_handler(rx_skb);
+#endif
+	}
+	complete_and_exit(&tsk->completed, 0);
+	RPU_INFO_HAL("%s exit\n", __func__);
+}
+
+
+static void hal_register_callback(msg_handler handler)
+{
+	hpriv->rcv_handler = handler;
+}
+
+
+int hal_irq_handler(struct hal_priv *p)
+{
+	struct hal_priv *priv = p;
+
+#ifdef CONFIG_PM
+	rx_interrupt_status = 1;
+#endif
+
+	hal_rx_thread_trigger(priv);
+
+	priv->event_cnt++;
+
+	return 0;
+}
+
+
+static void hal_enable_int(void)
+{
+	rk915_irq_enable(1);
+}
+
+
+static void hal_disable_int(void)
+{
+	rk915_irq_enable(0);
+}
+
+/*
+int chg_irq_register(int val)
+{
+	RPU_DEBUG_HAL("%s: change irq regist state %s.\n",
+		 hal_name, ((val == 1) ? "ON" : "OFF"));
+
+	if (val == 0) {
+		// Unregister irq handler 
+		free_irq(hpriv->irq, hpriv);
+
+	} else if (val == 1) {
+		// Register irq handler 
+		if (request_irq(hpriv->irq,
+				hal_irq_handler,
+				hpriv->irq_flags,
+				"wlan",
+				hpriv) != 0) {
+			return -1;
+		}
+	}
+
+	return 0;
+}
+*/
+
+
+static ssize_t proc_write_hal_stats(struct file *file,
+		const char __user    *buffer,
+		size_t		     count,
+		loff_t               *ppos)
+{
+	char buf[50];
+
+	if (count >= sizeof(buf))
+		count = sizeof(buf)-1;
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+	buf[count] = '\0';
+
+	return count;
+}
+
+static int proc_read_hal_stats(struct seq_file *m, void *v)
+{
+	int i=0;
+
+	seq_printf(m, "Alloc SKB Failures: %d\n",
+		   alloc_skb_failures);
+
+
+	seq_printf(m, "hal_cmd_sent_cnt: %d\n",
+		   hal_cmd_sent - hal_cmd_tx_send);
+	seq_printf(m, "hal_event_cmd_proc_done_cnt: %d\n",
+		   hal_event_cmd_proc_done);
+	seq_printf(m, "hal_cmd_tx_sent_cnt: %d\n",
+		   hal_cmd_tx_send);
+	seq_printf(m, "hal_event_tx_done_cnt: %d\n",
+		   hal_event_tx_done);
+	seq_printf(m, "hal_event_recv_cnt: %d\n",
+		   hal_event_recv);
+	seq_printf(m, "hal_event_rx_recv_cnt: %d\n",
+		   hal_event_rx_recv);
+
+	seq_printf(m, "hal_event_interrupts: %d\n",
+		   hal_event_interrupts);
+
+	for(i=0; i<8; i++) {
+		seq_printf(m, "rx_counts_one_interrupts_%dK: %d\n",
+			   2*(i+1), hal_event_rx_counts_one_interrupts[i]);
+	}
+
+	for(i=0; i<8; i++) {
+		seq_printf(m, "rx_count_one_packet_%dK: %d\n",
+			   2*(i+1), hal_event_rx_counts_one_packet[i]);
+	}
+
+	return 0;
+}
+
+
+static int proc_open_hal_stats(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_hal_stats, NULL);
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))  
+static const struct proc_ops params_fops_hal_stats = {
+    .proc_open = proc_open_hal_stats,
+    .proc_read = seq_read,
+    .proc_lseek = seq_lseek,
+    .proc_write = proc_write_hal_stats,
+    .proc_release = single_release
+};
+#else
+static const struct file_operations params_fops_hal_stats = {
+	.open = proc_open_hal_stats,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = proc_write_hal_stats,
+	.release = single_release
+};
+#endif
+
+static int hal_proc_init(struct proc_dir_entry *hal_proc_dir_entry)
+{
+	struct proc_dir_entry *entry;
+	int err = 0;
+
+	entry = proc_create("hal_stats",
+			    0444,
+			    hal_proc_dir_entry,
+			    &params_fops_hal_stats);
+
+	if (!entry) {
+		RPU_ERROR_HAL("Failed to create HAL proc entry\n");
+		err = -ENOMEM;
+	}
+
+	return err;
+}
+
+
+
+
+int hal_start(void)
+{
+	hpriv->hal_disabled = 0;
+
+	init_fw_recovery_cmd();
+
+	/* Enable host_int and rpu_int */
+	hal_enable_int();
+
+	return 0;
+}
+
+
+int hal_stop(void)
+{
+	hpriv->hal_disabled = 1;
+
+	/* Disable host_int and rpu_irq */
+	hal_disable_int();
+	return 0;
+}
+
+static int rk915_pm_notifier(struct notifier_block *nb, unsigned long action,
+                        void *data)
+{
+	switch (action) {
+		//case PM_HIBERNATION_PREPARE:
+		case PM_SUSPEND_PREPARE:
+			break;
+
+		//case PM_POST_HIBERNATION:
+		case PM_POST_SUSPEND:
+			hpriv->during_pm_resume = 0;
+			break;
+
+		case PM_POST_RESTORE:
+		case PM_RESTORE_PREPARE:
+		default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+/* Unmap and release all resoruces*/
+static int cleanup_all_resources(void)
+{
+	unregister_pm_notifier(&hpriv->pm_notifier);
+	unregister_syscore_ops(&host_syscore_ops);
+
+	/* Free private structure
+	kfree(hpriv);
+	hpriv = NULL;
+	*/
+
+	return 0;
+}
+static int hal_deinit(void *dev)
+{
+	struct sk_buff *skb;
+
+	if (!hpriv->hal_init)
+		return 0;
+
+	(void)(dev);
+
+	_rpu_umac_if_exit();
+
+#ifndef TX_USE_THREAD
+	cancel_work_sync(&hpriv->tx_work);
+	if (hpriv->tx_wkq != NULL) {
+		destroy_workqueue(hpriv->tx_wkq);
+		hpriv->tx_wkq = NULL;
+	}
+#endif    
+
+#if ENABLE_RX_WORKQ
+	cancel_work_sync(&hpriv->rx_work);
+	if (hpriv->rx_wkq != NULL) {
+		destroy_workqueue(hpriv->rx_wkq);
+		hpriv->rx_wkq = NULL;
+	}
+#endif
+
+	cancel_work_sync(&hpriv->fw_err_work);
+
+	wake_lock_destroy(&hpriv->fw_err_lock);
+
+#ifdef TX_USE_THREAD
+	PROC_STOP(&hpriv->thr_tx_ctl);
+#endif
+	PROC_STOP(&hpriv->thr_rx_ctl);
+
+	while ((skb = skb_dequeue(&hpriv->rxq)))
+		dev_kfree_skb_any(skb);
+
+	while ((skb = skb_dequeue(&hpriv->txq)))
+		dev_kfree_skb_any(skb);
+
+	cleanup_all_resources();
+
+	proc_exit();
+
+	hpriv->hal_init = 0;
+	return 0;
+}
+
+
+static int hal_init(void *dev)
+{
+	struct proc_dir_entry *main_dir_entry;
+	int err = 0;
+	(void) (dev);
+
+#ifdef TXRX_DATA_LOCK
+	mutex_init(&hpriv->txrx_mutex);
+#endif
+
+	hpriv->hal_disabled = 1;
+
+#ifdef TX_USE_THREAD
+	PROC_START(tx_thread, hpriv, &hpriv->thr_tx_ctl, 0, "rk915_tx_thr");
+#else
+	hpriv->tx_wkq = create_singlethread_workqueue("rk915_tx_wkq");
+	if (hpriv->tx_wkq == NULL) {
+		RPU_ERROR_HAL("%s: create tx wkq failed\n", hal_name);
+		err = -ENOMEM;
+		goto error;
+	}
+	INIT_WORK(&hpriv->tx_work, tx_work_fn);
+#endif    
+
+	PROC_START(rx_thread, hpriv, &hpriv->thr_rx_ctl, 0, "rk915_rx_thr");
+
+#if ENABLE_RX_WORKQ
+	hpriv->rx_wkq = create_singlethread_workqueue("rk915_rx_wkq");
+	if (hpriv->rx_wkq == NULL) {
+		RPU_ERROR_HAL("%s: create rx wkq failed\n", hal_name);
+		err = -ENOMEM;
+		goto error1;
+	}
+	INIT_WORK(&hpriv->rx_work, rx_work_fn);
+#endif
+	skb_queue_head_init(&hpriv->rxq);
+	skb_queue_head_init(&hpriv->txq);
+
+	INIT_WORK(&hpriv->fw_err_work, fw_err_work_fn);
+
+	wake_lock_init(&hpriv->fw_err_lock, WAKE_LOCK_SUSPEND, "rk915_lock");
+
+	hpriv->pm_notifier.notifier_call = rk915_pm_notifier;
+	register_pm_notifier(&hpriv->pm_notifier);
+
+	register_syscore_ops(&host_syscore_ops);
+	if (_rpu_umac_if_init(&main_dir_entry) < 0) {
+		RPU_ERROR_HAL("%s: wlan_init failed\n", hal_name);
+		err = -ENOMEM;
+		goto error2;
+	}
+
+	err = hal_proc_init(main_dir_entry);
+	if (err) {
+		goto umac_if_deinit;
+	}
+
+	hpriv->cmd_cnt = COMMAND_START_MAGIC;
+	hpriv->event_cnt = 0;
+	hpriv->hal_init = 1;
+
+	return err;
+umac_if_deinit:
+	_rpu_umac_if_exit();
+error2:
+	if (hpriv->rx_wkq != NULL)
+		destroy_workqueue(hpriv->rx_wkq);
+	unregister_syscore_ops(&host_syscore_ops);
+	unregister_pm_notifier(&hpriv->pm_notifier);
+error1:
+#ifdef TX_USE_THREAD
+    PROC_STOP(&hpriv->thr_tx_ctl);
+#else
+	if (hpriv->tx_wkq != NULL)
+		destroy_workqueue(hpriv->tx_wkq);
+#endif    
+	PROC_STOP(&hpriv->thr_rx_ctl);
+#ifndef TX_USE_THREAD
+error:
+#endif
+	return err;
+}
+
+static void hal_deinit_bufs(void)
+{
+	if (hpriv->tx_buf_info)
+		kfree(hpriv->tx_buf_info);
+	hpriv->tx_buf_info = NULL;
+	if (hpriv->rx_tmp_buf)
+		kfree(hpriv->rx_tmp_buf);
+	hpriv->rx_tmp_buf = NULL;
+}
+
+
+static int hal_init_bufs(unsigned int tx_bufs,
+			 unsigned int rx_bufs_2k,
+			 unsigned int rx_bufs_12k,
+			 unsigned int tx_max_data_size)
+{
+	hpriv->rx_tmp_buf = kzalloc(MAX_DATA_SIZE_2K, GFP_KERNEL);
+	if (!hpriv->rx_tmp_buf) {
+		RPU_ERROR_HAL("%s out of memory\n", hal_name);
+		goto err;
+	}
+	
+	return 0;
+err:
+
+	hal_deinit_bufs();
+
+	return -1;
+}
+
+
+int hal_map_tx_buf(int pkt_desc,
+		   int frame_id,
+		   unsigned char *data,
+		   int len, dma_addr_t *phy_addr)
+{
+	*phy_addr = (dma_addr_t)data;
+	return 0;
+}
+
+
+int hal_unmap_tx_buf(int pkt_desc, int frame_id)
+{
+
+	return 0;
+}
+
+#if 0
+static int is_mem_bounce(void *virt_addr, int len)
+{
+	phys_addr_t phy_addr_start = 0;
+	phys_addr_t phy_addr = 0;
+
+	phy_addr = VIRT_TO_PHYS(virt_addr);
+	phy_addr_start = VIRT_TO_PHYS(hpriv->base_addr_rpu_host_ram);
+
+	if (phy_addr >= phy_addr_start &&
+	    (phy_addr + len) < (phy_addr_start +
+				HAL_HOST_RPU_RAM_LEN))
+		return 1;
+
+	pr_info("%s: Warning: Address is out of Bounce memory region\n",
+		hal_name);
+
+	return 0;
+}
+#endif
+
+void wow_enable_irq_wake(void)
+{
+//	enable_irq_wake(hpriv->irq);
+}
+
+void wow_disable_irq_wake(void)
+{
+//	disable_irq_wake(hpriv->irq);
+}
+
+#if 0
+static enum rpu_mem_region fwldr_chk_region(unsigned int src_addr, int len)
+{
+	unsigned int dst_addr = src_addr + len;
+
+	if (((src_addr >= 0x03000000) && (src_addr <= 0x04FFFFFF))  ||
+	    ((src_addr >= 0x02009000) && (src_addr <= 0x0203BFFF))  ||
+	    ((src_addr >= 0x80000000) && (src_addr <= 0x87FFFFFF))) {
+		if (len != 0) {
+			if (((dst_addr >= 0x03000000) &&
+			     (dst_addr <= 0x04FFFFFF)) ||
+			    ((dst_addr >= 0x02009000) &&
+			     (dst_addr <= 0x0203BFFF)) ||
+			    ((dst_addr >= 0x80000000) &&
+			     (dst_addr <= 0x87FFFFFF)))
+				return RPU_MEM_CORE;
+			else
+				return RPU_MEM_ERR;
+		}
+
+		return RPU_MEM_CORE;
+	} else if ((src_addr & 0xFF000000) == 0xB0000000) {
+		return RPU_MEM_ERR;
+	} else {
+		return RPU_MEM_DIRECT;
+	}
+}
+
+
+static void dir_mem_read(unsigned int addr,
+			 unsigned int *data,
+			 unsigned int len)
+{
+	int i = 0;
+	unsigned long offset = (unsigned long)addr & RPU_OFFSET_MASK;
+	unsigned long base = ((unsigned long)addr & RPU_BASE_MASK) >> 24;
+
+	for (i = 0; i <= len / 4; i++) {
+		hal_rpu_read(hpriv, base, offset, data+i);
+		offset += 4;
+	}
+}
+
+/* 32 bit write to RPU memory location 'addr'
+ * 'addr' is always a 4 byte aligned address
+ */
+static void dir_mem_write(unsigned int addr,
+			 unsigned int data)
+{
+	unsigned long offset = (unsigned long)addr & RPU_OFFSET_MASK;
+	unsigned long base = ((unsigned long)addr & RPU_BASE_MASK) >> 24;
+
+	/* Boot Exception vector 0xBFC00000 maps to -> 0xA4000050 */
+        if (base == UCCP_BEV) {
+
+		offset = (unsigned long)addr & 0xfffff;
+
+                addr = MIPS_MCU_BOOT_EXCP_INSTR_0;
+
+		offset += ((unsigned long)addr & RPU_OFFSET_MASK);
+		base = ((unsigned long)addr & RPU_BASE_MASK) >> 24;
+	}
+
+	hal_rpu_write(hpriv, base, offset, data);
+}
+
+
+static void core_mem_set(unsigned int addr,
+			 unsigned int data,
+			 unsigned int len)
+{
+	addr = (addr & RPU_OFFSET_MASK)/4;
+
+	dir_mem_write(MIPS_MCU_SYS_CORE_MEM_CTRL, addr);
+
+	dir_mem_write(MIPS_MCU_SYS_CORE_MEM_WDATA, data);
+}
+
+static void core_mem_read(unsigned int addr,
+			  unsigned int *data,
+			  unsigned int len)
+{
+	unsigned int i = 0;
+	unsigned int val = 0;
+
+	/* Poll MSLVCTRL1 */
+	do {
+		dir_mem_read(MSLVCTRL1, &val, 1);
+	} while (!MSLAVE_READY(val));
+
+	dir_mem_write(MSLVCTRL0,
+			((addr & SLAVE_ADDR_MODE_MASK) | SLAVE_BLOCK_READ));
+
+	for (i = 0; i < len-1; i++) {
+		do {
+			dir_mem_read(MSLVCTRL1, &val, 1);
+		} while (!MSLAVE_READY(val));
+
+		dir_mem_read(MSLVDATAT, &data[i], 1);
+	}
+
+	/* Read the last word */
+	do {
+		dir_mem_read(MSLVCTRL1, &val, 1);
+	} while (!MSLAVE_READY(val));
+
+	dir_mem_read(MSLVDATAX, &data[len-1], 1);
+
+
+}
+
+static unsigned int fwldr_config_read(unsigned int dst_addr)
+{
+	int mem_region = 0;
+	int val = 0;
+
+	if (0 != (dst_addr % 4))
+		RPU_ERROR_HAL("Destination Address is not 4 - byte aligned");
+
+	mem_region = fwldr_chk_region(dst_addr, 0);
+
+	switch (mem_region) {
+	case RPU_MEM_CORE:
+		core_mem_read(dst_addr, &val, 1);
+		return val;
+
+	case RPU_MEM_DIRECT:
+		dir_mem_read(dst_addr, &val, 1);
+		return val;
+
+	default:
+		RPU_ERROR_HAL("Region unknown. Skipped reading\n");
+		return 0;
+	}
+
+	return 0;
+}
+
+
+static void fwldr_config_write(unsigned int dst_addr,
+			unsigned int val)
+{
+	int mem_region = 0;
+
+	if (0 != (dst_addr % 4))
+		RPU_ERROR_HAL("Destination Address is not 4 - byte aligned");
+
+	mem_region = fwldr_chk_region(dst_addr, 0);
+
+
+	switch (mem_region) {
+	case RPU_MEM_CORE:
+		core_mem_set(dst_addr, val, 1);
+		break;
+
+	case RPU_MEM_DIRECT:
+		dir_mem_write(dst_addr, val);
+		break;
+
+	default:
+		RPU_ERROR_HAL("Region unknown. Skipped writing\n");
+		break;
+	}
+
+}*/
+#endif
+
+
+int rpu_set_mem(unsigned int *dst,
+		     unsigned int val,
+		     unsigned int len)
+{
+	/*unsigned int index;
+
+	for (index = 0; index < len/4; index++) {
+		fwldr_config_write((unsigned int)(dst + index), val);
+	}*/
+
+	return 0;
+}
+
+int rpu_read_mem(unsigned int *src,
+		     unsigned int *dst,
+		     unsigned int len)
+{
+	/*unsigned int index;
+
+	for (index = 0; index < len/4; index++) {
+		*(src + index) = fwldr_config_read((unsigned int)(unsigned long)(dst + index));
+	}*/
+
+	return 0;
+}
+
+
+int rpu_write_mem(unsigned int *src,
+		     unsigned int *dst,
+		     unsigned int len)
+{
+	/*unsigned int index;
+
+	for (index = 0; index < len/4; index++) {
+		fwldr_config_write((unsigned int)(dst + index), *(src + index));
+	}*/
+
+	return 0;
+}
+
+void set_mem_region(unsigned int addr)
+{
+	soc_ops.set_mem_region(addr);
+}
+
+void request_mem_regions(unsigned char **gram_addr,
+			    unsigned char **sysbus_addr,
+			    unsigned char **gram_b4_addr)
+{
+
+        *gram_addr = (unsigned char *)hpriv->gram_base_addr;
+        *sysbus_addr = (unsigned char *)hpriv->rpu_sysbus_base_addr;
+        *gram_b4_addr = (unsigned char *)hpriv->gram_b4_addr;
+}
+
+struct hal_ops_tag hal_ops = {
+	.init = hal_init,
+	.deinit	= hal_deinit,
+	.start = hal_start,
+	.stop = hal_stop,
+	.register_callback = hal_register_callback,
+	.send = hal_send,
+	.init_bufs = hal_init_bufs,
+	.deinit_bufs = hal_deinit_bufs,
+	.map_tx_buf = hal_map_tx_buf,
+	.unmap_tx_buf = hal_unmap_tx_buf,
+	.reset_hal_params	= hal_reset_hal_params,
+	.get_dev = hal_get_dev,
+#ifdef CONFIG_PM
+	.enable_irq_wake = wow_enable_irq_wake,
+	.disable_irq_wake = wow_disable_irq_wake,
+#endif
+#ifdef RPU_SLEEP_ENABLE
+	.trigger_timed_sleep = trigger_timed_sleep,
+	.trigger_wakeup = trigger_wakeup,
+	.rpu_sleep_status = get_rpu_sleep_status,
+#endif
+	.rpu_set_mem = rpu_set_mem,
+	.rpu_read_mem = rpu_read_mem,
+	.rpu_write_mem = rpu_write_mem,
+	.request_mem_regions = request_mem_regions,
+	.set_mem_region = set_mem_region,
+};
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/hal_io.c b/drivers/net/wireless/rockchip_wlan/rk915/src/hal_io.c
new file mode 100755
index 000000000..33a2f08c0
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/hal_io.c
@@ -0,0 +1,324 @@
+#include <linux/types.h>
+
+#include "core.h"
+#include "if_io.h"
+#include "sdio.h"
+
+int num_streams_vpd;
+unsigned char *rf_params_vpd;
+
+extern int rk915_wait_fw_ready_to_sleep(void);
+
+static int rk915_unlock_data_read(struct hal_priv *priv, unsigned int
+									addr, unsigned char *buf, unsigned int len)
+{
+	return priv->io_info->io_ops->io_recv(priv->io_info, addr, buf, len);
+}
+
+void rk915_lock(struct hal_priv *priv)
+{
+	priv->io_info->io_ops->lock(priv->io_info);
+}
+
+void rk915_unlock(struct hal_priv *priv)
+{
+	priv->io_info->io_ops->unlock(priv->io_info);
+}
+
+int rk915_io_reset(struct hal_priv *priv)
+{
+	if (priv->during_fw_download)
+		return 0;
+	priv->io_info->io_ops->io_reset(priv->io_info);
+	return 0;
+}
+
+void rk915_notify_pm(struct hal_priv *priv, int wakeup)
+{
+	if (priv->io_info->io_ops->io_notify_pm) {
+		if (!wakeup && rk915_wait_fw_ready_to_sleep()) {
+			rk915_lock(priv);
+			priv->io_info->io_ops->io_notify_pm(priv->io_info, wakeup);
+			rk915_unlock(priv);
+		}
+		rk915_lock(priv);
+		priv->io_info->io_ops->io_notify_pm(priv->io_info, wakeup);
+		rk915_unlock(priv);
+	}
+}
+
+int rk915_writeb(struct hal_priv *priv, unsigned int addr, int val)
+{
+	int ret;
+
+	rk915_lock(priv);
+	ret = priv->io_info->io_ops->io_writeb(priv->io_info, addr, val);
+	priv->io_info->io_ops->io_writeb_comp(priv->io_info);
+	if (ret < 0)
+		rk915_io_reset(priv);
+	rk915_unlock(priv);
+
+	if (ret < 0) {
+		RPU_ERROR_SDIO("%s: addr=%d %d\n", __func__, addr, ret);
+		rk915_signal_io_error(FW_ERR_SDIO);
+	}
+
+	return ret;
+}
+
+int rk915_readb(struct hal_priv *priv, unsigned int addr)
+{
+	int val;
+
+	rk915_lock(priv);
+	val = priv->io_info->io_ops->io_readb(priv->io_info, addr);
+	if (val < 0)
+		rk915_io_reset(priv);
+	rk915_unlock(priv);
+
+	if (val < 0) {
+		RPU_ERROR_SDIO("%s: addr=%d %d\n", __func__, addr, val);
+		rk915_signal_io_error(FW_ERR_SDIO);
+	}
+
+	return val;
+}
+
+int rk915_data_read(struct hal_priv *priv, unsigned int addr,
+						    unsigned char *buf, unsigned int len)
+{
+	int ret;
+
+	rk915_lock(priv);
+	ret =  priv->io_info->io_ops->io_recv(priv->io_info, addr, buf, len);
+	if (ret < 0)
+		rk915_io_reset(priv);
+	rk915_unlock(priv);
+
+	if (ret < 0) {
+		RPU_ERROR_SDIO("%s: addr=%d len=%d %d\n", __func__, addr, len, ret);
+		rk915_signal_io_error(FW_ERR_SDIO);
+	}
+
+	return ret;
+}
+
+int rk915_data_write(struct hal_priv *priv, unsigned int addr,
+						    void *buf, size_t buf_len)
+{
+	int ret;
+	u32 len = ALIGN(buf_len, 4);
+
+	rk915_lock(priv);
+	ret = priv->io_info->io_ops->io_send(priv->io_info, addr, buf, len);
+	if (ret < 0)
+		rk915_io_reset(priv);
+	rk915_unlock(priv);
+
+	if (ret < 0) {
+		RPU_ERROR_SDIO("%s: addr=%d len=%d %d\n",
+						__func__, addr, (int)buf_len, ret);
+		rk915_signal_io_error(FW_ERR_SDIO);
+	}
+
+	return ret;
+}
+
+int rk915_data_write_sg(struct hal_priv *priv, unsigned int addr,
+							void *buf, size_t buf_len)
+{
+	int ret;
+
+	rk915_lock(priv);
+	ret = priv->io_info->io_ops->io_send_sg(priv->io_info, addr, buf, buf_len);
+	rk915_unlock(priv);
+
+	if (ret < 0) {
+		rk915_io_reset(priv);
+	}
+
+	return ret;
+}
+
+int rk915_ejtag(struct hal_priv *priv)
+{
+	int ret;
+
+	rk915_lock(priv);
+	ret = priv->io_info->io_ops->io_ejtag(priv->io_info);
+	rk915_unlock(priv);
+
+	return ret;
+}
+
+int rk915_io_init(struct hal_priv *priv)
+{
+	return priv->io_info->io_ops->io_init(priv->io_info);
+}
+
+// need lock before call
+int rk915_read_data_len(struct hal_priv *priv)
+{
+	unsigned char len[2];
+	unsigned int length;
+
+	len[0] = priv->io_info->io_ops->io_readb(priv->io_info, IO_RECV_LEN_L);
+	len[1] = priv->io_info->io_ops->io_readb(priv->io_info, IO_RECV_LEN_H);
+	length = (len[1] << 8) | len[0];
+
+	return length;
+}
+
+// need lock before call
+static int rk915_notify(struct hal_priv *priv)
+{
+	int ret;
+
+	ret = priv->io_info->io_ops->io_writeb(priv->io_info, IO_NOTIFY_ADDR, IO_NOTIFY_VAL);
+	priv->io_info->io_ops->io_writeb_comp(priv->io_info);
+	return ret;
+}
+
+// need lock before call
+int rk915_clear_irq(struct hal_priv *priv)
+{
+	int ret;
+
+	ret = priv->io_info->io_ops->io_writeb(priv->io_info, IO_INT_ADDR, IO_INT_CLR_IRQ_VAL);
+	return ret;
+}
+
+int rk915_serias_read(struct hal_priv *priv, u16 addr,
+						void *buf, size_t buf_len, u32 max_len)
+{
+	struct host_io_info *host = (struct host_io_info *)priv->io_info;
+	int length;
+	struct host_rpu_msg_hdr* mac_hdr;
+	int ret;
+
+	if (((unsigned long)buf & 0x3) || !virt_addr_valid(buf)) {
+		BUG_ON(1);
+	}
+
+	if (host->rx_serias_count > 0) {
+		host->rx_serias_buf_curr += host->rx_serias_len[host->rx_serias_idx];
+
+		++host->rx_serias_idx;
+		mac_hdr = (struct host_rpu_msg_hdr *)host->rx_serias_buf_curr;
+		host->rx_next_len = mac_hdr->length >> 16;
+		mac_hdr->length = mac_hdr->length & 0x0000FFFF;
+		length = mac_hdr->length + mac_hdr->payload_length;
+
+		RPU_DEBUG_HALIO("idx(%d) data len(%d) next_pkt(%d)\n",
+						host->rx_serias_idx, length, host->rx_next_len);
+
+		if ((host->rx_serias_idx + 1) >= host->rx_serias_count) {
+			host->rx_serias_idx = -1;
+			host->rx_serias_count = 0;
+			if (host->rx_next_len == 0) {
+				RPU_DEBUG_SDIO("End of the continuous rx 1\n");
+				rk915_lock(priv);
+				if (rk915_clear_irq(priv)) {
+					RPU_ERROR_SDIO("rk915_clear_irq error\n");
+					length = -1;
+					goto recv_exit;
+				}
+				/* notify m0 */
+				if (rk915_notify(priv)) {
+					RPU_ERROR_SDIO("rk915_notify error\n");
+					length = -1;
+					goto recv_exit;
+				}
+				rk915_unlock(priv);
+			}
+		}
+
+		/*if (length <= 0) {
+			RPU_ERROR_SDIO("%x %x %x\n", mac_hdr->length, mac_hdr->payload_length, mac_hdr->id);
+		}*/
+		return length;
+	}
+
+	rk915_lock(priv);
+
+	if (host->rx_next_len == 0) {
+		length = rk915_read_data_len(priv);
+		//RPU_INFO_SDIO("rx len1 %x\n", length);
+	} else {
+		length = host->rx_next_len;
+		//RPU_INFO_SDIO("rx len2 %x\n", length);
+	}
+
+	if ((length > max_len) || (length < 0)) {
+		RPU_ERROR_SDIO("%s: length(%d) too long error.\n", __func__, length);
+		length = 0;
+		goto recv_exit;
+	}
+
+	ret = rk915_unlock_data_read(priv, 0, buf, length);
+	if (ret) {
+		if (net_ratelimit())
+			RPU_ERROR_SDIO("%s: error %d len %x.\n", __func__, ret, length);
+		length = 0;
+		goto recv_exit;
+	}
+
+	host->rx_serias_buf_curr = buf;
+	mac_hdr = (struct host_rpu_msg_hdr*)buf;
+
+	/* it's an serias of package */
+	if (mac_hdr->id == RPU_EVENT_RX_SERIAS &&
+		*((u32*)mac_hdr->hal_data.hal_data) == 0x3412ccff) {
+		int i = 0;
+		struct cmd_rx_ctrl *prx = (struct cmd_rx_ctrl *)buf;
+		for (i = 0; i < prx->pkt_count; i++) {
+			host->rx_serias_len[i] = prx->pkt_len[i];
+		}
+		RPU_DEBUG_SDIO("in rx serias: %d\n", prx->pkt_count);
+		host->rx_serias_idx = 0;
+		host->rx_serias_count = prx->pkt_count;
+		/* skip the first pkt */
+		host->rx_serias_buf_curr += round_up(sizeof(struct cmd_rx_ctrl), 4);
+		mac_hdr = (struct host_rpu_msg_hdr *)host->rx_serias_buf_curr;
+	}
+
+	host->rx_next_len = mac_hdr->length >> 16;
+	mac_hdr->length = mac_hdr->length & 0x0000FFFF;
+	length = mac_hdr->length + mac_hdr->payload_length;
+
+	RPU_DEBUG_SDIO("idx(0) data len(%d) next_pkt(%d)\n",
+					length, host->rx_next_len);
+
+	if (host->rx_next_len == 0) {
+		RPU_DEBUG_SDIO("End of the continuous rx 2\n");
+		if (rk915_clear_irq(priv))	{
+			RPU_ERROR_SDIO("rk915_clear_irq error\n");
+			length = -1;
+			goto recv_exit;
+		}
+		/* notify m0 */
+		if (rk915_notify(priv)) {
+			RPU_ERROR_SDIO("rk915_notify error\n");
+			length = -1;
+			goto recv_exit;
+		}
+	}
+
+recv_exit:
+	rk915_unlock(priv);
+//recv_exit_unlock:
+	RPU_DEBUG_SDIO("exit %s .\n", __func__);
+
+	if (length <= 0) {
+		struct img_priv *imgpriv = wifi ? wifi->hw->priv:NULL;
+		/* sometimes wifi irq is triggered just after cmd_reset enable send to m0, but no data to read
+		 * just skip it here, do not trigger fw error recovery
+		 */
+		if (length == 0 && !imgpriv->reset_complete)
+			return length;
+		rk915_io_reset(priv);
+		rk915_signal_io_error(FW_ERR_SDIO);
+	}
+
+	return length;
+}
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/init.c b/drivers/net/wireless/rockchip_wlan/rk915/src/init.c
new file mode 100755
index 000000000..583b8912a
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/init.c
@@ -0,0 +1,288 @@
+#include <linux/module.h>
+#include <net/mac80211.h>
+#include <linux/time.h>
+#include <linux/pm.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/syscalls.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/suspend.h>
+#include <linux/of.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/delay.h>
+
+#include "core.h"
+#include "if_io.h"
+#include "soc.h"
+#include "hal.h"
+#include "utils.h"
+#include "platform.h"
+#include "hal_io.h"
+
+struct hal_priv *hpriv;
+bool m0_jtag_enable = false;
+
+static int fw_bring_up(void *p)
+{
+	struct hal_priv *priv = (struct hal_priv *)p;
+
+	if (hpriv->fw_error_processing) {
+		rk915_poweron();
+		mdelay(RK915_POWER_ON_DELAY_MS);
+		rk915_platform_bus_rec_init(priv->io_info);
+		mdelay(RK915_POWER_ON_DELAY_MS);
+	} else {
+		if (rk915_platform_bus_init(priv->io_info)) {
+			RPU_ERROR_MAIN("%s: platform_bus_init failed\n", __func__);
+			return -1;
+		}
+	}
+
+	if (rk915_download_firmware(priv)) {
+		RPU_ERROR_MAIN("%s: rk915_download_firmware failed\n", __func__);
+		return -1;
+	}
+
+	if (rk915_io_init(priv)) {
+		RPU_ERROR_MAIN("%s: rk915_io_init failed\n", __func__);
+		return -1;
+	}
+
+	if (!down_fw_in_probe && !hpriv->fw_error_processing) {
+		if (rk915_register_irq(priv->io_info)) {
+			RPU_ERROR_MAIN("%s: rk915_irq_register failed\n", __func__);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int fw_tear_down(void *p)
+{
+	if (hpriv->fw_error_processing) {
+		rk915_poweroff();
+		return 0;
+	}
+
+	rk915_platform_bus_deinit(hpriv->io_info);
+
+	return 0;
+}
+
+static void rk915_core_deinit(void)
+{
+	struct host_io_info *host;
+
+	if (!hpriv)
+		return;
+
+	host = hpriv->io_info;
+	if (host)
+		rk915_free_firmware_buf(&host->firmware);
+	if (host && host->rx_serias_buf)
+		kfree(host->rx_serias_buf);
+	if (hpriv)
+		kfree(hpriv);
+	if (host)
+		kfree(host);
+}
+
+static int rk915_core_init(void)
+{
+	struct host_io_info *host = NULL;
+	struct hal_priv *priv = NULL;
+
+	RPU_INFO_MAIN("%s.\n", __func__);
+
+	host = kzalloc(sizeof(struct host_io_info), GFP_KERNEL);
+	if (!host) {
+		RPU_ERROR_MAIN("%s: kalloc hal_priv failed\n", __func__);
+		goto err;
+	}
+
+	host->rx_serias_buf = kzalloc(MAX_RX_SERIAS_BYTES, GFP_KERNEL);
+	if (!host->rx_serias_buf) {
+		RPU_ERROR_MAIN("%s: kalloc hal_priv failed\n", __func__);
+		goto err;
+	}
+
+	host->rx_serias_idx = -1;
+	host->rx_serias_count = 0;
+	host->rx_next_len = 0;
+	host->bus_init = false;
+
+	if (rk915_alloc_firmware_buf(&host->firmware) != 0) {
+		RPU_ERROR_MAIN("%s: rk915_alloc_firmware_buf failed\n", __func__);
+		goto err;
+	}
+
+	priv = kzalloc(sizeof(struct hal_priv), GFP_KERNEL);
+	if (!priv) {
+		RPU_ERROR_MAIN("%s: kalloc hal_priv failed\n", __func__);
+		goto err;
+	}
+
+	hpriv = priv;
+	priv->io_info = host;
+
+	rk915_sdio_pre_init();
+
+	return 0;
+
+err:
+	rk915_core_deinit();
+
+	return -1;
+}
+
+int rk915_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct host_io_info *host = hpriv->io_info;
+
+	RPU_INFO_MAIN("%s\n", __func__);
+
+	hpriv->fw_bring_up_func = fw_bring_up;
+	hpriv->fw_tear_down_func = fw_tear_down;
+
+	/* Initialize the rest of the layer */
+	ret = hal_ops.init(host->dev);
+	if (ret < 0) {
+		RPU_ERROR_MAIN("%s: hal_ops.init failed\n", __func__);
+		return -1;
+	}
+
+	if (down_fw_in_probe) {
+		if (fw_bring_up(hpriv)) {
+			RPU_ERROR_MAIN("%s: fw_bring_up failed\n", __func__);
+			return -1;
+		}
+
+		if (rk915_register_irq(hpriv->io_info)) {
+			RPU_ERROR_MAIN("%s: rk915_irq_register failed\n", __func__);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+int rk915_remove(struct platform_device *pdev)
+{
+	RPU_INFO_MAIN("%s\n", __func__);
+
+	hal_ops.deinit(NULL);
+
+	rk915_free_irq(hpriv->io_info);
+
+	return 0;
+}
+
+void rk915_shutdown(struct platform_device *pdev)
+{
+	//RPU_INFO_MAIN("%s\n", __func__);
+	hpriv->shutdown = 1;
+}
+
+static const struct platform_device_id rk915_id_table[] = {
+    {
+        .name = "rk915",
+        .driver_data = 0x00,
+    },
+    {},
+};
+MODULE_DEVICE_TABLE(platform, rk915_id_table);
+
+static struct platform_driver rk915_driver =
+{
+    .probe = rk915_probe,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+    .remove = __devexit_p(rk915_remove),
+#else
+    .remove = rk915_remove,
+#endif
+    .shutdown = rk915_shutdown,
+    .id_table = rk915_id_table,
+    .driver = {
+        .name = "Rockchip rk915 wifi driver",
+        .owner = THIS_MODULE,
+    }
+};
+
+static int __init rk915_init(void)
+{
+	int ret;
+
+	RPU_INFO_MAIN("=======================================================\n");
+	RPU_INFO_MAIN("==== Launching Wi-Fi driver! (Powered by Rockchip) ====\n");
+	RPU_INFO_MAIN("=======================================================\n");
+	RPU_INFO_MAIN("RK915 WiFi Ver: %s\n", VERSION_INFO);
+	RPU_INFO_MAIN("Build time: %s %s\n", __DATE__, __TIME__);
+
+	ret = rk915_core_init();
+	if (ret) {
+		RPU_ERROR_MAIN("%s: rk915_core_init failed\n", __func__);
+		goto error;
+	}
+
+	ret = rk915_bus_register_driver();
+	if (ret) {
+		RPU_ERROR_MAIN("%s: rk915_bus_register_driver failed\n", __func__);
+		goto error;
+	}
+
+	ret = platform_driver_register(&rk915_driver);
+	if (ret) {
+		RPU_ERROR_MAIN("%s: rk915_platform_driver_register failed\n", __func__);
+		goto error1;
+	}
+
+	ret = rk915_platform_bus_init(hpriv->io_info);
+	if (ret) {
+		RPU_ERROR_MAIN("%s: platform_bus_init failed\n", __func__);
+		goto error2;
+	}
+
+	return ret;
+error2:
+	platform_driver_unregister(&rk915_driver);
+error1:
+	rk915_bus_unregister_driver();
+error:
+	return ret;
+}
+
+static void __exit rk915_exit(void)
+{
+	RPU_INFO_MAIN("==========================================================\n");
+	RPU_INFO_MAIN("==== Dislaunching Wi-Fi driver! (Powered by Rockchip) ====\n");
+	RPU_INFO_MAIN("==========================================================\n");
+
+	platform_driver_unregister(&rk915_driver);
+
+	rk915_bus_unregister_driver();
+
+	rk915_platform_bus_deinit(hpriv->io_info);
+
+	rk915_core_deinit();
+}
+
+module_init(rk915_init);
+module_exit(rk915_exit);
+
+module_param_named(jtag, m0_jtag_enable, bool, 0644);
+MODULE_AUTHOR("Rockchips");
+MODULE_DESCRIPTION("Driver for Rockchips RK915 SDIO WiFi Devices");
+MODULE_LICENSE("GPL");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/main.c b/drivers/net/wireless/rockchip_wlan/rk915/src/main.c
new file mode 100755
index 000000000..9cdbbdb5e
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/main.c
@@ -0,0 +1,397 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/proc_fs.h>
+#include "core.h"
+#include "hal_common.h"
+#include "hal_io.h"
+#include "utils.h"
+
+static int print_version = 1;
+
+int _rpu_umac_if_init(struct proc_dir_entry **main_dir_entry)
+{
+	int error;
+
+	error = proc_init(&main_dir_entry);
+	if (error)
+		return error;
+
+	error = rpu_init();
+
+	return error;
+}
+
+void _rpu_umac_if_exit(void)
+{
+	rpu_exit();
+}
+
+#if 0
+static void prog_sleep_controller_default(void)
+{
+#define PWR_ON_VALUES_SIZE 2 * sizeof(unsigned int)
+#define PWR_OFF_VALUES_SIZE 2 * sizeof(unsigned int)
+#define RAM_ON_STATES_SIZE 2 * sizeof(unsigned int)
+#define RAM_OFF_STATES_SIZE 2 * sizeof(unsigned int)
+#define PWR_ON_TIMES_SIZE 14 * sizeof(unsigned int)
+#define PWR_OFF_TIMES_SIZE 14 * sizeof(unsigned int)
+#define RAM_ON_TIMES_SIZE 4 * sizeof(unsigned int)
+#define RAM_OFF_TIMES_SIZE 4 * sizeof(unsigned int)
+
+	/* There are the LMAC defaults, change this to customize sleep 
+	 * controller configuration as per SoC.
+	 */
+	unsigned int pwr_on_values[PWR_ON_VALUES_SIZE] = {0x65FE, 0x5};
+	unsigned int pwr_off_values[PWR_OFF_VALUES_SIZE] = {0x9A01, 0x2};
+	unsigned int ram_on_states[RAM_ON_STATES_SIZE] = {0x0, 0x0};
+	unsigned int ram_off_states[RAM_OFF_STATES_SIZE] = {0x3D, 0x0};
+	unsigned int pwr_on_times[PWR_ON_TIMES_SIZE] = {3, 1, 4, 4, 64, 73, 64, 73, 69, 74, 75, 73, 73,0};
+	unsigned int pwr_off_times[PWR_OFF_TIMES_SIZE] = {12, 14, 11, 13, 2, 1, 2, 0, 10, 5, 4, 6, 6, 15};
+	unsigned int ram_on_times[RAM_ON_TIMES_SIZE] = {71, 0, 0, 0};
+	unsigned int ram_off_times[RAM_OFF_TIMES_SIZE] = {5, 0, 0, 0};
+	unsigned int sleep_freq = 32768 ;
+
+	rpu_prog_pwrmgmt_pwr_on_value(pwr_on_values, PWR_ON_VALUES_SIZE);
+	rpu_prog_pwrmgmt_pwr_off_value(pwr_off_values, PWR_OFF_VALUES_SIZE);
+	rpu_prog_pwrmgmt_ram_on_state(ram_on_states, RAM_ON_STATES_SIZE);
+	rpu_prog_pwrmgmt_ram_off_state(ram_off_states, RAM_OFF_STATES_SIZE);
+	rpu_prog_pwrmgmt_pwr_on_time(pwr_on_times, PWR_ON_TIMES_SIZE);
+	rpu_prog_pwrmgmt_pwr_off_time(pwr_off_times, PWR_OFF_TIMES_SIZE) ;
+	rpu_prog_pwrmgmt_ram_on_time(ram_on_times, RAM_ON_TIMES_SIZE);
+	rpu_prog_pwrmgmt_ram_off_time(ram_off_times, RAM_OFF_TIMES_SIZE) ;
+	rpu_prog_pwrmgmt_sleep_freq(sleep_freq);
+
+	//rpu_prog_pwrmgmt_clk_adj(-10000);
+	//rpu_prog_pwrmgmt_wakeup_time(5000);
+}
+#endif
+
+#ifdef RK915
+static int rpu_lmac_feature_init(void)
+{
+#if 0
+	unsigned int feature_val = 0;
+
+	//feature_val |= LMAC_WATCHDOG_PHY_HANG_RESET_ENABLE;
+	//feature_val |= LMAC_FILTER_PROBE_REQ_IN_PS_ENABLE;
+	feature_val |= LMAC_FILTER_BCMC_DATA_IN_PS_ENABLE;
+	feature_val |= LMAC_NULL_FRAME_IN_PS_ENABLE;
+	return rpu_prog_patch_feature(feature_val);
+#else
+	return 0;
+#endif
+}
+#endif
+
+int rpu_core_init(struct img_priv *priv, unsigned int ftm)
+{
+	int ret = 0;
+	unsigned int reset_type = LMAC_ENABLE;
+
+	if (priv->state == STARTED)
+		return ret;
+
+	RPU_DEBUG_MAIN("%s-UMAC: Init called\n", priv->name);
+	spin_lock_init(&tsf_lock);
+	rpu_if_init(priv, priv->name);
+
+	/* Enable the LMAC, set defaults and initialize TX */
+	priv->reset_complete = 0;
+
+#ifdef RPU_SLEEP_ENABLE
+	reset_type |= priv->params->rpu_sleep_type;
+#endif
+
+	RPU_INFO_MAIN("%s-UMAC: Reset (ENABLE) reset_type %x\n", priv->name, reset_type);
+
+	if (hal_ops.init_bufs(NUM_TX_DESCS,
+			      NUM_RX_BUFS_2K,
+			      NUM_RX_BUFS_12K,
+			      priv->params->max_data_size) < 0) {
+		ret = -1;
+		RPU_ERROR_MAIN("%s: init_bufs failed\n", __func__);
+		goto hal_stop;
+	}
+
+	if (hal_ops.start()) {
+		ret = -1;
+		RPU_ERROR_MAIN("%s: hal_ops.start failed\n", __func__);
+		goto rpu_if_deinit;
+	}
+
+#ifndef SDIO_TXRX_STABILITY_TEST
+	/* notify fw wakeup */
+	rk915_notify_pm(hpriv, 1);
+
+	if (ftm)
+		CALL_RPU(rpu_prog_reset,
+			  reset_type,
+			  LMAC_MODE_FTM);
+	else
+		CALL_RPU(rpu_prog_reset,
+			  reset_type,
+			  LMAC_MODE_NORMAL);
+
+	if (wait_for_reset_complete(priv, 1) < 0) {
+		ret = -1;
+		RPU_ERROR_MAIN("%s: wait_for_reset_complete failed\n", __func__);
+		goto hal_deinit_bufs;
+	}
+#endif
+
+	CALL_RPU(rpu_fw_priv_cmd, FW_PRIV_INIT, NULL);
+
+#ifdef SDIO_TXRX_STABILITY_TEST
+	priv->state = STARTED;
+	CALL_RPU(rpu_prog_txrx_test, TXRX_TEST_START_TX);
+#endif
+
+#ifdef RK915
+	rpu_lmac_feature_init();
+#endif
+
+	//prog_sleep_controller_default();
+
+	CALL_RPU(rpu_prog_txpower, priv->txpower);
+
+	rpu_tx_init(priv);
+
+#ifdef ENABLE_DAPT
+	dapt_param_init(priv);
+#endif
+
+	return 0;
+hal_deinit_bufs:
+	hal_ops.deinit_bufs();
+prog_rpu_fail:
+hal_stop:
+	hal_ops.stop();
+rpu_if_deinit:
+	rpu_if_deinit();
+	return ret;
+}
+
+
+void rpu_core_deinit(struct img_priv *priv, unsigned int ftm)
+{
+	int ret = 0;
+
+	RPU_DEBUG_MAIN("%s-UMAC: De-init called\n", priv->name);
+
+#ifdef ENABLE_DAPT
+	dapt_param_deinit(priv);
+#endif	
+
+	/* De initialize tx  and disable LMAC*/
+	rpu_tx_deinit(priv);
+
+	if (!hpriv->fw_error) {
+		/* Disable the LMAC */
+		priv->reset_complete = 0;
+		RPU_INFO_MAIN("%s-UMAC: Reset (DISABLE)\n", priv->name);
+
+		if (ftm)
+			CALL_RPU(rpu_prog_reset,
+				  LMAC_DISABLE,
+				  LMAC_MODE_FTM);
+		else
+			CALL_RPU(rpu_prog_reset,
+				  LMAC_DISABLE,
+				  LMAC_MODE_NORMAL);
+
+		if (wait_for_reset_complete(priv, 0) < 0) {
+			ret = -1;
+			RPU_ERROR_MAIN("%s: wait_for_reset_complete failed\n", __func__);
+			goto prog_rpu_fail;
+		}
+
+		/* notify fw sleep */
+		rk915_notify_pm(hpriv, 0);
+	}
+
+prog_rpu_fail:
+	wait_for_fw_error_process_complete(priv);
+
+	rpu_if_free_outstnding();
+
+	hal_ops.stop();
+	hal_ops.deinit_bufs();
+
+	rpu_if_deinit();
+
+	priv->state = STOPPED;
+}
+
+
+void rpu_reset_complete(char *lmac_version, void *context)
+{
+	struct img_priv *priv = (struct img_priv *)context;
+
+	memcpy(priv->stats->rpu_lmac_version, lmac_version, 5);
+	priv->stats->rpu_lmac_version[5] = '\0';
+	priv->reset_complete = 1;
+	if (print_version) {
+		print_version = 0;
+		memcpy(priv->stats->fw_version, lmac_version+6, 20);
+		priv->stats->fw_version[20] = '\0';
+		RPU_INFO_MAIN("%s: Patch: %s FW: %s\n", __func__,
+						priv->stats->rpu_lmac_version, priv->stats->fw_version);
+	}
+}
+
+void rpu_fw_info_dump_start(void *context, unsigned int type, unsigned int reg)
+{
+	struct img_priv *priv = (struct img_priv *)context;
+
+	priv->fw_info->finish = 0;
+	priv->fw_info->offset = 0;
+	priv->fw_info->type = type;
+	if (type == DUMP_REG_INFO)
+		priv->fw_info->reg = reg;
+}
+
+void rpu_fw_priv_cmd_done(struct fw_priv_cmd_done *event,
+			   void *context)
+{
+	struct img_priv *priv = (struct img_priv *)context;
+
+	if (priv->fw_info->offset+event->info.size >= priv->fw_info->len) {
+		RPU_ERROR_MAIN("%s: fw_info buf overflow\n", __func__);
+		return;
+	}
+
+	memcpy(priv->fw_info->info + priv->fw_info->offset,
+					event->info.data, event->info.size);
+	priv->fw_info->type = event->hdr.descriptor_id;
+	priv->fw_info->offset += event->info.size;
+	if (event->info.end) {
+		priv->fw_info->info[priv->fw_info->offset] = 0;
+		priv->fw_info->finish = 1;
+	}
+
+	if (event->hdr.descriptor_id == DUMP_FW_CRASH_INFO) {
+		RPU_ERROR_MAIN("\n%s\n", priv->fw_info->info);
+	}
+}
+
+void rpu_mac_stats(struct umac_event_mac_stats *mac_stats,
+			   void *context)
+{
+	struct img_priv *priv = (struct img_priv *)context;
+
+	/* TX related */
+	priv->stats->roc_start = mac_stats->roc_start;
+	priv->stats->roc_stop = mac_stats->roc_stop;
+	priv->stats->roc_complete = mac_stats->roc_complete;
+	priv->stats->roc_stop_complete = mac_stats->roc_stop_complete;
+	priv->stats->tx_cmd_cnt = mac_stats->tx_cmd_cnt;
+	priv->stats->tx_done_cnt = mac_stats->tx_done_cnt;
+	priv->stats->tx_edca_trigger_cnt = mac_stats->tx_edca_trigger_cnt;
+	priv->stats->tx_edca_isr_cnt = mac_stats->tx_edca_isr_cnt;
+	priv->stats->tx_start_cnt = mac_stats->tx_start_cnt;
+	priv->stats->tx_abort_cnt = mac_stats->tx_abort_cnt;
+	priv->stats->tx_abort_isr_cnt = mac_stats->tx_abort_isr_cnt;
+	priv->stats->tx_underrun_cnt = mac_stats->tx_underrun_cnt;
+	priv->stats->tx_rts_cnt = mac_stats->tx_rts_cnt;
+	priv->stats->tx_ampdu_cnt = mac_stats->tx_ampdu_cnt;
+	priv->stats->tx_mpdu_cnt = mac_stats->tx_mpdu_cnt;
+	priv->stats->tx_crypto_post = mac_stats->tx_crypto_post;
+	priv->stats->tx_crypto_done = mac_stats->tx_crypto_done;
+	priv->stats->rx_pkt_to_umac = mac_stats->rx_pkt_to_umac;
+	priv->stats->rx_crypto_post = mac_stats->rx_crypto_post;
+	priv->stats->rx_crypto_done = mac_stats->rx_crypto_done;
+	/* RX related */
+	priv->stats->rx_isr_cnt = mac_stats->rx_isr_cnt;
+	priv->stats->rx_ack_cts_to_cnt = mac_stats->rx_ack_cts_to_cnt;
+	priv->stats->rx_cts_cnt = mac_stats->rx_cts_cnt;
+	priv->stats->rx_ack_resp_cnt = mac_stats->rx_ack_resp_cnt;
+	priv->stats->rx_ba_resp_cnt = mac_stats->rx_ba_resp_cnt;
+	priv->stats->rx_fail_in_ba_bitmap_cnt =
+		mac_stats->rx_fail_in_ba_bitmap_cnt;
+	priv->stats->rx_circular_buffer_free_cnt =
+		mac_stats->rx_circular_buffer_free_cnt;
+	priv->stats->rx_mic_fail_cnt = mac_stats->rx_mic_fail_cnt;
+
+	/* HAL related */
+	priv->stats->hal_cmd_cnt = mac_stats->hal_cmd_cnt;
+	priv->stats->hal_event_cnt = mac_stats->hal_event_cnt;
+	priv->stats->hal_ext_ptr_null_cnt = mac_stats->hal_ext_ptr_null_cnt;
+
+	/* LPW PHY Related */
+	priv->stats->csync_timeout_cntr = mac_stats->csync_timeout_cntr;
+	priv->stats->fsync_timeout_cntr = mac_stats->fsync_timeout_cntr;
+	priv->stats->acdrop_timeout_cntr = mac_stats->acdrop_timeout_cntr;
+	priv->stats->csync_abort_agctrig_cntr = mac_stats->csync_abort_agctrig_cntr;
+	priv->stats->crc_success_cnt = mac_stats->crc_success_cnt;
+	priv->stats->crc_fail_cnt = mac_stats->crc_fail_cnt;
+#ifdef RPU_SLEEP_ENABLE
+	priv->stats->rpu_boot_cnt = mac_stats->rpu_boot_cnt;
+	memcpy(priv->stats->sleep_stats, mac_stats->sleep_stats,
+		sizeof(priv->stats->sleep_stats));
+#endif
+}
+void rpu_rf_calib_data(struct umac_event_rf_calib_data *rf_data,
+			       void *context)
+{
+	struct img_priv  *priv = (struct img_priv *)context;
+
+	if (rf_data->rf_calib_data_length > MAX_RF_CALIB_DATA) {
+		RPU_ERROR_MAIN("%s: RF calib data exceeded the max size: %d\n",
+			    __func__,
+			    MAX_RF_CALIB_DATA);
+		return;
+	}
+	priv->stats->rf_calib_data_length = rf_data->rf_calib_data_length;
+	memset(priv->stats->rf_calib_data, 0x00,
+	       MAX_RF_CALIB_DATA);
+	memcpy(priv->stats->rf_calib_data, rf_data->rf_calib_data,
+	       rf_data->rf_calib_data_length);
+}
+
+
+
+void rpu_ch_prog_complete(int event,
+				  struct umac_event_ch_prog_complete *prog_ch,
+				  void *context)
+{
+	struct img_priv *priv = (struct img_priv *)context;
+
+	priv->chan_prog_done = 1;
+}
+
+int rk915_wait_fw_ready_to_sleep(void)
+{
+    struct img_priv *imgpriv =
+            wifi ? wifi->hw->priv : NULL;
+
+    if (imgpriv) {
+        imgpriv->read_csr_complete = 0;
+        imgpriv->read_csr_value = 0;
+        rpu_prog_read_csr(0xbf2);
+        wait_for_read_csr_cmp(imgpriv);
+        //RPU_INFO_MAIN("read_csr_value = %x\n", imgpriv->read_csr_value);
+
+        if (imgpriv->read_csr_value & (1<<14)) {
+            imgpriv->read_csr_complete = 0;
+            imgpriv->read_csr_value = 0;
+            rpu_prog_read_csr(0xbf2);
+            wait_for_read_csr_cmp(imgpriv);
+            //RPU_INFO_MAIN("read_csr_value = %x\n", imgpriv->read_csr_value);
+        }
+
+        if (imgpriv->read_csr_value & (1<<15)) {
+            return 1;
+        }
+        return 0;
+    }
+
+    return 0;
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/p2p.c b/drivers/net/wireless/rockchip_wlan/rk915/src/p2p.c
new file mode 100755
index 000000000..55aa41eb0
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/p2p.c
@@ -0,0 +1,284 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <net/cfg80211.h>
+#include <net/mac80211.h>
+
+#include "core.h"
+#include "p2p.h"
+#include "utils.h"
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+extern void roc_timer_expiry(struct timer_list *t);
+#else
+extern void roc_timer_expiry(unsigned long data);
+#endif
+
+void init_roc_timeout_timer (struct img_priv *priv)
+{
+	RPU_DEBUG_ROC("%s: %p\n", __func__, priv);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+	timer_setup(&priv->roc_timer, roc_timer_expiry, 0);
+#else
+	init_timer(&priv->roc_timer);
+	priv->roc_timer.data = (unsigned long)NULL;
+	priv->roc_timer.function = roc_timer_expiry;
+#endif
+}
+
+void start_roc_timeout_timer(struct img_priv *priv, int timeout)
+{
+	RPU_DEBUG_ROC("%s: %p\n", __func__, priv);
+	mod_timer(&priv->roc_timer, jiffies + msecs_to_jiffies(timeout));
+}
+
+void deinit_roc_timeout_timer (struct img_priv *priv)
+{
+	RPU_DEBUG_ROC("%s: %p\n", __func__, priv);
+	del_timer(&priv->roc_timer);
+}
+
+void rpu_roc_complete_work(struct work_struct *work)
+{
+	struct delayed_work *dwork = NULL;
+	struct img_priv *priv = NULL;
+	struct tx_config *tx = NULL;
+	u32 roc_queue = 0;
+
+	dwork = container_of(work, struct delayed_work, work);
+	priv = container_of(dwork, struct img_priv, roc_complete_work);
+	tx = &priv->tx;
+
+	if (priv->roc_params.roc_in_progress == 0) {
+		priv->roc_params.roc_starting = 0;
+		return;
+	}
+
+	mutex_lock(&priv->mutex);
+
+	roc_queue = tx_queue_unmap(UMAC_ROC_AC);
+
+	/* Stop the ROC queue */
+	ieee80211_stop_queue(priv->hw, roc_queue);
+	/* Unlock RCU immediately as we are freeing off_chanctx in this funciton
+	 * only and because flush_vif_queues sleep
+	 */
+	rcu_read_lock();
+	rcu_read_unlock();
+
+	priv->roc_params.roc_in_progress = 0;
+	priv->roc_params.roc_starting = 0;
+
+	if (priv->cancel_roc == 0) {
+		ieee80211_remain_on_channel_expired(priv->hw);
+		RPU_DEBUG_ROC("%s:%d ROC STOPPED..\n", __func__, __LINE__);
+	} else {
+		priv->cancel_hw_roc_done = 1;
+		priv->cancel_roc = 0;
+		RPU_DEBUG_ROC("%s:%d ROC CANCELLED..\n", __func__, __LINE__);
+	}
+
+	/* Start the ROC queue */
+	ieee80211_wake_queue(priv->hw, roc_queue);
+	mutex_unlock(&priv->mutex);
+}
+
+int remain_on_channel(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif,
+			     struct ieee80211_channel *channel,
+			     int duration,
+			     enum ieee80211_roc_type type)
+{
+	struct img_priv *priv = (struct img_priv *)hw->priv;
+	unsigned int pri_chnl_num =
+		ieee80211_frequency_to_channel(channel->center_freq);
+	int ret = 0;
+
+	mutex_lock(&priv->mutex);
+	RPU_DEBUG_ROC("%s:%d The Params are:",
+					__func__,
+					__LINE__);
+	RPU_DEBUG_ROC(" channel:%d duration:%d type: %d\n",
+			ieee80211_frequency_to_channel(channel->center_freq),
+			duration,
+			type);
+
+	if (priv->roc_params.roc_in_progress ||
+		priv->roc_params.roc_starting || 
+	    priv->params->hw_scan_status != HW_SCAN_STATUS_NONE) {
+		RPU_INFO_ROC("%s:%d Dropping roc...Busy\n",
+				__func__,
+				__LINE__);
+		mutex_unlock(&priv->mutex);
+#if 0//def RK915
+		return 0;
+#else		
+		return -EBUSY;
+#endif
+	}
+
+#ifdef RK3036_DONGLE
+	start_roc_timeout_timer(priv, duration*3);
+#endif
+
+	priv->roc_params.roc_starting = 1;
+
+	/* Inform FW that ROC is started:
+	 * For pure TX we send OFFCHANNEL_TX so that driver can terminate ROC
+	 * For Tx + Rx we use NORMAL, FW will terminate ROC based on duration.
+	 */
+	if (duration != 10 && type == ROC_TYPE_OFFCHANNEL_TX)
+		type = ROC_TYPE_NORMAL;
+
+	CALL_RPU(rpu_prog_roc,
+		  ROC_START,
+		  pri_chnl_num,
+		  duration,
+		  type);
+
+
+prog_rpu_fail:
+	mutex_unlock(&priv->mutex);
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
+int cancel_remain_on_channel(struct ieee80211_hw *hw,
+						struct ieee80211_vif *vif)
+#else
+int cancel_remain_on_channel(struct ieee80211_hw *hw)
+#endif
+{
+	struct img_priv *priv = (struct img_priv *)hw->priv;
+	int ret = 0;
+#ifdef RK3036_DONGLE
+	int index;
+	int skip = 0;
+
+	index = find_main_iface(priv);
+	if (index != MAX_VIFS) {
+		if (priv->vifs[index] && 
+		    priv->vifs[index]->bss_conf.enable_beacon)
+			skip = 1;
+	}
+	if (skip) {
+		RPU_INFO_ROC("%s:%d Cancel HW ROC skip\n",
+			__func__, __LINE__);
+		return -1;
+	}
+#endif
+	mutex_lock(&priv->mutex);
+
+	if (priv->roc_params.roc_in_progress) {
+		priv->cancel_hw_roc_done = 0;
+		priv->cancel_roc = 1;
+		RPU_DEBUG_ROC("%s:%d Cancelling HW ROC....\n",
+				__func__, __LINE__);
+		CALL_RPU(rpu_prog_roc, ROC_STOP, 0, 0, 0);
+
+		mutex_unlock(&priv->mutex);
+
+		if (!wait_for_cancel_hw_roc(priv)) {
+			RPU_DEBUG_ROC("%s:%d Cancel HW ROC....done\n",
+							__func__,
+							__LINE__);
+			ret = 0;
+		} else {
+			RPU_ERROR_ROC("%s:%d Cancel HW ROC..timedout\n",
+							__func__,
+							__LINE__);
+			ret = -1;
+		}
+	}
+prog_rpu_fail:
+	mutex_unlock(&priv->mutex);
+	return ret;
+}
+
+
+void rpu_noa_event(int event, struct umac_event_noa *noa, void *context,
+			   struct sk_buff *skb)
+{
+	struct img_priv  *priv = (struct img_priv *)context;
+	struct ieee80211_vif *vif;
+	struct umac_vif *uvif;
+	bool transmit = false;
+
+	rcu_read_lock();
+
+	vif = (struct ieee80211_vif *)rcu_dereference(priv->vifs[noa->if_index]);
+
+	if (vif == NULL) {
+		rcu_read_unlock();
+		return;
+	}
+
+	uvif = (struct umac_vif *)vif->drv_priv;
+
+	spin_lock_bh(&uvif->noa_que.lock);
+
+	if (event == FROM_TX) {
+		if (uvif->noa_active) {
+			if (!uvif->noa_tx_allowed || skb_peek(&uvif->noa_que))
+				__skb_queue_tail(&uvif->noa_que, skb);
+			else
+				transmit = true;
+		} else
+			transmit = true;
+	} else if (event == FROM_TX_DONE) {
+		if (uvif->noa_active && uvif->noa_tx_allowed) {
+			skb = __skb_dequeue(&uvif->noa_que);
+
+			if (skb)
+				transmit = true;
+		}
+	} else { /* event = FROM_EVENT_NOA */
+
+		uvif->noa_active = noa->noa_active;
+
+		if (uvif->noa_active) {
+			RPU_DEBUG_P2P("%s: noa active = %d, ",
+					priv->name, noa->noa_active);
+			RPU_DEBUG_P2P("ap_present = %d\n",
+					noa->ap_present);
+
+			uvif->noa_tx_allowed = noa->ap_present;
+
+			if (uvif->noa_tx_allowed) {
+				skb = __skb_dequeue(&uvif->noa_que);
+				if (skb)
+					transmit = true;
+			}
+		} else {
+			RPU_DEBUG_P2P("%s: noa active = %d\n",
+				 priv->name, noa->noa_active);
+
+			uvif->noa_tx_allowed = 1;
+
+			/* Can be done in a better way. For now, just flush the
+			 * NoA Queue
+			 */
+			while ((skb = __skb_dequeue(&uvif->noa_que)))
+				dev_kfree_skb_any(skb);
+		}
+	}
+
+	spin_unlock_bh(&uvif->noa_que.lock);
+
+	rcu_read_unlock();
+
+	if (transmit) {
+		rpu_tx_frame(skb,
+				     NULL,
+				     priv,
+				     false);
+	}
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/pktgen.c b/drivers/net/wireless/rockchip_wlan/rk915/src/pktgen.c
new file mode 100755
index 000000000..fbab4bffc
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/pktgen.c
@@ -0,0 +1,643 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include "core.h"
+#include "utils.h"
+
+static int rpu_proc_tx_pending = 0;
+
+int get_rate_prod(struct cmd_tx_ctrl *txcmd,
+		     struct img_priv *priv)
+{
+	
+	unsigned int index;
+
+	if (priv->params->production_test != 1)
+		return -80;
+
+	index = 0;
+	if (priv->params->tx_fixed_mcs_indx != -1) {
+		txcmd->rate[index] = 0x80;
+		txcmd->rate[index] |=
+		    (priv->params->tx_fixed_mcs_indx);
+		txcmd->num_spatial_streams[index] =
+		    priv->params->num_spatial_streams;
+		txcmd->bcc_or_ldpc =
+		    priv->params->prod_mode_bcc_or_ldpc;
+		txcmd->stbc_enabled =
+		    priv->params->prod_mode_stbc_enabled;
+		update_mcs_packet_stat(
+		    priv->params->tx_fixed_mcs_indx,
+		    txcmd->rate_flags[index], priv);
+	} else if (priv->params->production_test == 1 &&
+		   priv->params->tx_fixed_rate != -1) {
+		txcmd->rate[index] = 0x00;
+		if (priv->params->tx_fixed_rate == 55)
+			txcmd->rate[index] |=
+			 ((priv->params->tx_fixed_rate) /
+			  5);
+		else
+			txcmd->rate[index] |=
+			  ((priv->params->tx_fixed_rate *
+			    10) / 5);
+		txcmd->num_spatial_streams[index] = 1;
+		txcmd->bcc_or_ldpc = 0;
+		txcmd->stbc_enabled = 0;
+	} else {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -90;
+	}
+	txcmd->num_rates = 1;
+	txcmd->rate_retries[index] = 1;
+	txcmd->rate_flags[index] =
+		priv->params->prod_mode_rate_flag;
+	txcmd->rate_preamble_type[index] =
+		priv->params->prod_mode_rate_preamble_type;
+
+	return 0;
+}
+
+
+unsigned char bss_addr[6] = {72, 14, 29, 35, 31, 52};
+void proc_bss_info_changed(unsigned char *mac_addr, int value)
+{
+		int temp = 0, i = 0, j = 0, ret = 0;
+
+		get_random_bytes(&j, sizeof(j));
+		for (i = 5; i > 0; i--) {
+			j = j % (i+1);
+			temp = bss_addr[i];
+			bss_addr[i] = bss_addr[j];
+			bss_addr[j] = temp;
+			}
+		CALL_RPU(rpu_prog_vif_bssid,
+			  0,
+			  mac_addr,
+			  bss_addr);
+prog_rpu_fail:
+	return;
+}
+
+void packet_generation(unsigned long data)
+{
+		struct img_priv *priv = (struct img_priv *)data;
+		unsigned char *mac_addr = priv->if_mac_addresses[0].addr;
+		struct ieee80211_hdr hdr = {0};
+		struct sk_buff *skb;
+		unsigned char broad_addr[6] = {0xff, 0xff, 0xff,
+					       0xff, 0xff, 0xff};
+		u16 hdrlen = 26;
+		static unsigned char fill_data = 0;
+		int token_id = 0;
+		int queue = WLAN_AC_BE;
+#ifdef PKTGEN_MULTI_TX
+		queue = WLAN_AC_BK;
+#endif
+		rpu_proc_tx_pending = 1;
+
+#ifdef PKTGEN_MULTI_TX
+	while (1) {
+		token_id = get_token(priv, queue);
+		if (token_id == NUM_TX_DESCS) {
+			queue++;
+			if (queue == WLAN_AC_BCN)
+				break;
+			continue;
+		}
+#endif
+		/*LOOP_START*/
+		/*PREPARE_SKB_LIST and SEND*/
+
+		skb = alloc_skb(priv->params->payload_length + hdrlen,
+				GFP_ATOMIC);
+		img_ether_addr_copy(hdr.addr1, broad_addr);
+		img_ether_addr_copy(hdr.addr2, mac_addr);
+		img_ether_addr_copy(hdr.addr3, bss_addr);
+		hdr.frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
+						IEEE80211_STYPE_QOS_DATA);
+		memcpy(skb_put(skb, hdrlen), &hdr, hdrlen);
+		memset(skb_put(skb, priv->params->payload_length),
+			priv->params->echo_mode?fill_data++:0xAB,
+			priv->params->payload_length);
+
+		/*LOOP_END*/
+#ifdef PKTGEN_MULTI_TX
+		skb_queue_tail(&priv->tx.proc_tx_list[token_id], skb);
+#else
+		skb_queue_tail(&priv->tx.proc_tx_list[0], skb);
+#endif
+		rpu_proc_tx(priv, token_id, queue);
+#ifdef PKTGEN_MULTI_TX
+	}
+#endif
+}
+
+int rpu_proc_tx(struct img_priv *priv, int descriptor_id, int queue)
+{
+	struct cmd_tx_ctrl *tx_cmd;
+	struct sk_buff *tmp, *skb, *skb_first, *tx_cmd_skb;
+	struct sk_buff_head *skb_list;
+	struct ieee80211_hdr *mac_hdr;
+	unsigned int pkt = 0;
+	u16 hdrlen = 26;
+	dma_addr_t phy_addr;
+	unsigned int cmd_tx_size;
+
+	//pr_info("%s: desc_id %d queue %d\n", __func__, descriptor_id, queue);
+
+	if (!priv->params->start_prod_mode) {
+		return -1;
+	}
+
+	spin_lock_bh(&priv->tx.lock);
+
+	skb_list = &priv->tx.proc_tx_list[descriptor_id];
+
+	skb_first = skb_peek(skb_list);
+	if (!skb_first) {
+		spin_unlock_bh(&priv->tx.lock);
+		return -10;
+	}
+
+	cmd_tx_size = sizeof(struct cmd_tx_ctrl);
+
+	tx_cmd_skb = alloc_skb(cmd_tx_size, GFP_KERNEL);
+
+	if (!tx_cmd_skb) {
+		spin_unlock_bh(&priv->tx.lock);
+		rcu_read_unlock();
+		return -ENOMEM;
+	}
+
+	skb_put(tx_cmd_skb, cmd_tx_size);
+	
+	tx_cmd = kzalloc(cmd_tx_size, GFP_KERNEL);
+
+	if (!tx_cmd) {
+		spin_unlock_bh(&priv->tx.lock);
+		rcu_read_unlock();
+		kfree(tx_cmd_skb);
+		return -ENOMEM;
+	}
+
+	/* HAL UMAC-LMAC HDR*/
+	tx_cmd->hdr.id = RPU_CMD_TX;
+	/* Keep the queue num and pool id in descriptor id */
+	tx_cmd->hdr.descriptor_id = 0;
+	tx_cmd->hdr.descriptor_id |= ((queue & 0x0000FFFF) << 16);
+	tx_cmd->hdr.descriptor_id |= (descriptor_id & 0x0000FFFF);
+	/* Not used anywhere currently */
+	tx_cmd->hdr.length = sizeof(struct cmd_tx_ctrl);
+
+	/* RPU_CMD_TX*/
+	tx_cmd->if_index = 0;
+	tx_cmd->queue_num = queue;
+	tx_cmd->more_frms = 0;
+	tx_cmd->descriptor_id = descriptor_id;
+	tx_cmd->num_frames_per_desc = skb_queue_len(skb_list); 
+	tx_cmd->aggregate_mpdu = AMPDU_AGGR_DISABLED;
+
+	memcpy(tx_cmd->config_mac_header, skb_first->data,
+	      hdrlen);
+	tx_cmd->config_mac_hdr_len = hdrlen;
+
+	get_rate_prod(tx_cmd, priv);
+
+	pkt = 0;
+	skb_queue_walk_safe(skb_list, skb, tmp) {
+		struct ieee80211_tx_info *tx_info;
+		unsigned char *crypto_params;
+		unsigned int mac_hdr_len;
+
+		if (!skb || (pkt > tx_cmd->num_frames_per_desc))
+			break;
+
+		tx_info = IEEE80211_SKB_CB(skb_first);
+		mac_hdr = (struct ieee80211_hdr *)skb->data;
+		/* Complete packet length*/
+		tx_cmd->pkt_length[pkt] = skb->len;
+
+		if (hal_ops.map_tx_buf(descriptor_id, pkt,
+				       skb->data, skb->len, &phy_addr)) {
+			spin_unlock_bh(&priv->tx.lock);
+			kfree(tx_cmd_skb);
+			kfree(tx_cmd);
+			return -30;
+		}
+		tx_cmd->p_frame_ddr_pointer[pkt] = (unsigned int *)phy_addr;
+		crypto_params = tx_cmd->per_pkt_crypto_params[pkt];
+		memset(crypto_params, 0, PER_PKT_CRYPTO_PARAMS_SIZE);
+
+		memcpy(crypto_params + PER_PKT_CRYPTO_PARAMS_SEQ_CTRL_OFFSET,
+		       &mac_hdr->seq_ctrl,
+		       2);
+
+		if (ieee80211_is_data_qos(mac_hdr->frame_control)) {
+			struct ieee80211_qos_hdr *qos_mac_hdr;
+			unsigned char *iv_offset;
+
+			iv_offset = crypto_params +
+				    PER_PKT_CRYPTO_PARAMS_QOS_CTRL_OFFSET;
+			qos_mac_hdr = (struct ieee80211_qos_hdr *) skb->data;
+			memcpy(iv_offset,
+			       &qos_mac_hdr->qos_ctrl,
+			       2);
+		}
+
+		mac_hdr_len =  ieee80211_hdrlen(mac_hdr->frame_control);
+		if (tx_cmd->encrypt == ENCRYPT_ENABLE) {
+			unsigned char *iv_offset;
+
+			iv_offset = crypto_params +
+				    PER_PKT_CRYPTO_PARAMS_IV_OFFSET;
+
+			memcpy(iv_offset,
+			       skb->data + mac_hdr_len,
+			       tx_info->control.hw_key->iv_len);
+		}
+		pkt++;
+	}
+	memcpy(tx_cmd_skb->data, tx_cmd, cmd_tx_size);
+		hal_ops.send((void *)tx_cmd_skb,
+			     NULL,
+			     0);
+	/* increment tx_cmd_send_count to keep track of number of
+	 * tx_cmd send
+	 */
+	if (skb_queue_len(skb_list) == 1)
+		priv->stats->tx_cmd_send_count_single++;
+	else if (skb_queue_len(skb_list) > 1)
+		priv->stats->tx_cmd_send_count_multi++;
+
+	spin_unlock_bh(&priv->tx.lock);
+	kfree(tx_cmd);
+	return 0;
+}
+
+int start_prod_mode(struct img_priv *priv, unsigned int val)
+{
+
+	unsigned int pri_chnl_num = 0;
+	unsigned int freq_band = IEEE80211_BAND_5GHZ;
+	int center_freq = 0;
+	int ret = -1;
+#ifdef PKTGEN_MULTI_TX
+	int i;
+#endif
+
+	rpu_proc_tx_pending = 0;
+
+	if (priv->params->production_test != 1) {
+		pr_err("start_prod_mode: Can be set in only in production mode.\n");
+		goto error;
+	}
+
+	if (!priv->params->init_prod) {
+		tasklet_init(&priv->proc_tx_tasklet, packet_generation,
+		     (unsigned long)priv);
+	}
+
+	pri_chnl_num = val;
+	priv->params->start_prod_mode = val;
+	if (pri_chnl_num < 15)
+		freq_band = IEEE80211_BAND_2GHZ;
+	else
+		freq_band = IEEE80211_BAND_5GHZ;
+
+	center_freq =
+	ieee80211_channel_to_frequency(pri_chnl_num,
+				       freq_band);
+
+	if (priv->params->init_prod) {
+		rpu_prog_channel(pri_chnl_num,
+					center_freq,
+					 0,
+					 0,
+			/*It will be overwritten anyway*/
+					 freq_band);
+		return 0;
+	}
+
+	if (!rpu_core_init(priv, ftm)) {
+		rpu_prog_vif_ctrl(0,
+				priv->if_mac_addresses[0].addr,
+				IF_MODE_STA_IBSS,
+				IF_ADD);
+
+		proc_bss_info_changed(
+				priv->if_mac_addresses[0].addr,
+				val);
+
+		rpu_prog_channel(pri_chnl_num,
+					center_freq,
+					 0,
+					 0,
+			/*It will be overwritten anyway*/
+					 freq_band);
+#ifdef PKTGEN_MULTI_TX
+		for (i = 0; i < NUM_TX_DESCS; i++)
+		    skb_queue_head_init(&priv->tx.proc_tx_list[i]);
+#else
+		skb_queue_head_init(&priv->tx.proc_tx_list[0]);
+#endif
+		priv->params->init_prod = 1;
+		priv->state = STARTED;
+		uccp_reinit = 0;
+	 } else {
+		pr_err("RPU Initialization Failed\n");
+		priv->params->init_prod = 0;
+	}
+	ret = 0;
+error:
+	return ret;
+}
+
+int stop_prod_mode(struct img_priv *priv, unsigned int val)
+{
+	int ret = -1;
+	if (!priv->params->init_prod) {
+		pr_err("Prod mode is not initialized\n");
+		goto error;
+	}
+
+	tasklet_kill(&priv->proc_tx_tasklet);
+
+	priv->params->start_prod_mode = 0;
+	priv->params->pkt_gen_val = 1;
+	priv->params->init_prod = 0;
+	priv->params->init_pkt_gen = 0;
+	while (rpu_proc_tx_pending) {
+		msleep(1);
+	}
+
+	if (!uccp_reinit)
+		//stop(priv->hw);
+		rpu_core_deinit(priv, ftm);
+
+	ret = 0;
+error:
+	return -1;
+}
+
+int start_prod_rx_mode(struct img_priv *priv, unsigned int val,
+					unsigned char *bssid, unsigned char *mac_addr)
+{
+
+	unsigned int pri_chnl_num = 0;
+	unsigned int freq_band = IEEE80211_BAND_5GHZ;
+	int center_freq = 0;
+	int ret = -1;
+	int cw_mode = 0;
+	/*unsigned char */mac_addr = priv->if_mac_addresses[0].addr;
+	bssid = priv->if_mac_addresses[0].addr;
+
+	bssid[0] = 0;
+
+	if (priv->params->production_test != 1) {
+		pr_err("start_prod_mode: Can be set in only in production mode.\n");
+		goto error;
+	}
+
+	cw_mode = val & 0x80;
+	val &= 0x7f;
+	pr_info("%s: channel = %d, cw_mode %x, bssid = %pM\n",
+                    __func__, val, cw_mode, bssid);
+
+	pri_chnl_num = val;
+	priv->params->start_prod_mode = val;
+	if (pri_chnl_num < 15)
+		freq_band = IEEE80211_BAND_2GHZ;
+	else
+		freq_band = IEEE80211_BAND_5GHZ;
+
+	center_freq =
+	ieee80211_channel_to_frequency(pri_chnl_num,
+				       freq_band);
+
+	if (priv->params->init_prod) {
+		rpu_prog_channel(pri_chnl_num,
+					center_freq,
+					 0,
+					 0,
+			/*It will be overwritten anyway*/
+					 freq_band);		
+		return 0;
+	}
+
+	if (!rpu_core_init(priv, ftm)) {
+		rpu_prog_vif_ctrl(0,
+				mac_addr,
+				IF_MODE_STA_IBSS,
+				IF_ADD);
+
+		rpu_prog_vif_bssid(0,
+			  mac_addr,
+			  bssid);
+
+		pri_chnl_num |= cw_mode;
+		rpu_prog_channel(pri_chnl_num,
+					center_freq,
+					 0,
+					 0,
+			/*It will be overwritten anyway*/
+					 freq_band);
+		
+		priv->params->init_prod = 1;
+		priv->state = STARTED;
+		uccp_reinit = 0;
+	 } else {
+		pr_err("RPU Initialization Failed\n");
+		priv->params->init_prod = 0;
+	}
+	ret = 0;
+error:
+	return ret;
+}
+
+int start_prod_echo_mode(struct img_priv *priv, unsigned int val)
+{
+	int ret = -1;
+#ifdef PKTGEN_MULTI_TX
+	int i;
+#endif
+
+	if (priv->params->production_test != 1) {
+		pr_err("start_prod_mode: Can be set in only in production mode.\n");
+		goto error;
+	}
+
+	if (priv->params->init_prod) {
+		pr_err("Production Test is already initialized.\n");
+		goto error;
+	}
+
+	priv->params->start_prod_mode = val;
+	tasklet_init(&priv->proc_tx_tasklet, packet_generation,
+		     (unsigned long)priv);
+
+	if (!rpu_core_init(priv, ftm)) {
+		// notify FW into tx echo mode
+		struct fw_params params;
+		memset(&params, 0, sizeof(struct fw_params));
+		params.mask |= 1<<PARAM_ECHO_MODE;
+		params.echo_mode=1;
+		msleep(200);
+		if (rpu_fw_priv_cmd_sync(FW_SET_PARAMS, &params) != 0) {
+			goto error;
+		}
+		priv->params->echo_mode = params.echo_mode;
+#ifdef PKTGEN_MULTI_TX
+		for (i = 0; i < NUM_TX_DESCS; i++)
+		    skb_queue_head_init(&priv->tx.proc_tx_list[i]);
+#else
+		skb_queue_head_init(&priv->tx.proc_tx_list[0]);
+#endif
+		priv->params->init_prod = 1;
+		priv->state = STARTED;
+		uccp_reinit = 0;
+	 } else {
+		pr_err("RPU Initialization Failed\n");
+		priv->params->init_prod = 0;
+	}
+	ret = 0;
+error:
+	return ret;
+}
+
+int start_packet_gen(struct img_priv *priv, int sval)
+{
+	int ret = -1;
+
+	if (!priv->params->init_prod) {
+		pr_err("NEW Production Mode is not Initialized\n");
+		goto error;
+	}
+
+	if (priv->params->init_pkt_gen) {
+		pr_err("packet gen is already running\n");
+		goto error;
+	}
+
+	if (priv->params->tx_fixed_mcs_indx == -1 &&
+		priv->params->tx_fixed_rate == -1) {
+		pr_err("Either tx_fixed_mcs_index Or tx_fixed_rate should be set, both can't be NULL.\n");
+		goto error;
+	}
+
+	priv->params->init_pkt_gen = 1;
+
+	priv->params->pkt_gen_val = sval;
+
+	if (sval != 0)
+		tasklet_schedule(&priv->proc_tx_tasklet);
+	ret = 0;
+error:
+	return -1;
+}
+
+int stop_packet_gen(struct img_priv *priv, int sval)
+{
+	int ret = -1;
+
+	if (!priv->params->init_prod) {
+		pr_err("NEW Production Mode is not Initialized\n");
+		goto error;
+	}
+
+	priv->params->pkt_gen_val = 1;
+	priv->params->init_pkt_gen = 0;
+	tasklet_kill(&priv->proc_tx_tasklet);
+	ret = 0;
+error:
+	return -1;
+
+}
+
+static struct sk_buff *s_tmp_skb = NULL;
+
+void rpu_proc_tx_complete(struct umac_event_tx_done *tx_done,
+			     void *context)
+{
+
+	struct img_priv *priv = (struct img_priv *)context;
+	struct sk_buff *skb, *tmp;
+	struct sk_buff_head *tx_done_list;
+	unsigned int pkt = 0;
+
+//	pr_info("%s: desc_id %d queue %d\n", __func__,
+//            tx_done->descriptor_id, tx_done->queue);
+
+#ifdef PKTGEN_MULTI_TX
+	free_token(priv, tx_done->descriptor_id, tx_done->queue);
+#endif
+	tx_done_list = &priv->tx.proc_tx_list[tx_done->descriptor_id];
+	priv->stats->tx_done_recv_count++;
+	update_aux_adc_voltage(priv, tx_done->pdout_voltage);
+	skb_queue_walk_safe(tx_done_list, skb, tmp) {
+		__skb_unlink(skb, tx_done_list);
+		if (!skb)
+			continue;
+		hal_ops.unmap_tx_buf(tx_done->descriptor_id, pkt);
+		if (priv->params->echo_mode && s_tmp_skb!=NULL) {
+			if (memcmp(skb->data+26, s_tmp_skb->data+94, s_tmp_skb->len-94) != 0) {
+				pr_err("packet compare fail!\n");
+				//dump
+				print_hex_dump(KERN_DEBUG, "tx ", DUMP_PREFIX_NONE,
+						16,
+						  1,
+						  skb->data,
+						  skb->len,
+						  1);
+				print_hex_dump(KERN_DEBUG, "rx ", DUMP_PREFIX_NONE,
+						16,
+						  1,
+						  s_tmp_skb->data,
+						  s_tmp_skb->len,
+						  1);
+			} else {
+				pr_info("echo pass\n");
+			}
+			// free
+			dev_kfree_skb_any(s_tmp_skb);
+			s_tmp_skb = NULL;
+		}
+		dev_kfree_skb_any(skb);
+		pkt++;
+	}
+
+#ifdef PKTGEN_MULTI_TX
+    if (!priv->tx.buf_pool_bmp[0])
+        rpu_proc_tx_pending = 0;
+#else
+    rpu_proc_tx_pending = 0;
+#endif
+
+	/*send NEXT packet list*/
+	if ((priv->params->pkt_gen_val == -1) ||
+	    (--priv->params->pkt_gen_val > 0)) {
+	    if (priv->params->start_prod_mode)
+		    tasklet_schedule(&priv->proc_tx_tasklet);
+    }
+}
+
+void rpu_proc_rx_event(void *nbuff, void *context)
+{
+	struct sk_buff *skb = (struct sk_buff *)nbuff;
+	struct img_priv *priv = (struct img_priv *)context;
+
+	priv->stats->rx_packet_data_count++;
+	dump_ieee80211_hdr_info(skb->data, skb->len, 0);
+	if (priv->params->echo_mode) {
+		s_tmp_skb = skb;
+	} else {
+		dev_kfree_skb_any(skb);
+	}
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/platform.c b/drivers/net/wireless/rockchip_wlan/rk915/src/platform.c
new file mode 100755
index 000000000..b7ad2e3f4
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/platform.c
@@ -0,0 +1,95 @@
+#include <linux/rfkill-wlan.h>
+
+#include "core.h"
+#include "if_io.h"
+#include "platform.h"
+
+extern int hal_irq_handler(struct hal_priv *p);
+
+void rk915_rescan_card(unsigned insert)
+{
+    rockchip_wifi_set_carddetect(insert);
+}
+
+void rk915_poweron(void)
+{
+	rockchip_wifi_power(0);
+	mdelay(RK915_POWER_ON_DELAY_MS);
+	rockchip_wifi_power(1);
+}
+
+void rk915_poweroff(void)
+{
+	rockchip_wifi_power(0);
+}
+
+static irqreturn_t hal_interrupt(int irq, void *dev_id)
+{
+	hal_irq_handler(hpriv);
+	return IRQ_HANDLED;
+}
+
+void rk915_irq_enable(int enable)
+{
+	/*if (enable) {
+		enable_irq(hpriv->io_info->irq);
+	} else {
+		disable_irq(hpriv->io_info->irq);
+	}*/
+}
+
+int rk915_register_irq(struct host_io_info *host)
+{
+	int ret;
+	
+	ret = devm_request_irq(host->dev, host->irq, hal_interrupt,
+				IRQF_TRIGGER_RISING|IRQF_NO_SUSPEND, "rk915", hpriv);
+	if (ret == 0) {
+		ret = enable_irq_wake(host->irq);
+		rk915_irq_enable(0);
+		host->irq_request = true;
+	}
+
+	return ret;
+}
+
+int rk915_free_irq(struct host_io_info *host)
+{
+	if (host->irq_request) {
+		devm_free_irq(host->dev, host->irq, hpriv);
+		host->irq_request = false;
+	}
+
+	return 0;
+}
+
+int rk915_bus_register_driver(void)
+{
+	return rk915_sdio_register_driver();
+}
+
+void rk915_bus_unregister_driver(void)
+{
+	rk915_sdio_unregister_driver();
+}
+
+int rk915_platform_bus_init(struct host_io_info *phost)
+{
+	if (!phost->bus_init)
+		return rk915_sdio_init(phost);
+	else
+		return 0;
+}
+
+int rk915_platform_bus_rec_init(struct host_io_info *phost)
+{
+	return rk915_sdio_recovery_init(phost);
+}
+
+int rk915_platform_bus_deinit(struct host_io_info *phost)
+{
+	if (phost->bus_init)
+		return rk915_sdio_deinit(phost);
+	else
+		return 0;
+}
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/procfs.c b/drivers/net/wireless/rockchip_wlan/rk915/src/procfs.c
new file mode 100755
index 000000000..b492c6c40
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/procfs.c
@@ -0,0 +1,2148 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/proc_fs.h>
+#include <linux/moduleparam.h>
+
+#include "core.h"
+#include "utils.h"
+#include "version.h"
+#include "hal_io.h"
+
+unsigned int lpw_no_sleep = 0;
+module_param(lpw_no_sleep, int, 0);
+MODULE_PARM_DESC(lpw_no_sleep, "lpw sleep or not");
+
+unsigned int default_phy_threshold = DAPT_DEFAULT_PHY_THRESH;
+module_param(default_phy_threshold, int, 0);
+MODULE_PARM_DESC(default_phy_threshold, "default phy threshold");
+
+struct wifi_dev *wifi;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
+#undef IEEE80211_BAND_2GHZ
+#define IEEE80211_BAND_2GHZ NL80211_BAND_2GHZ
+#endif
+
+#ifdef RPU_SLEEP_ENABLE
+#include "sdio.h"
+static int proc_read_sleep_stats(struct seq_file *m, void *v)
+{
+	int i;
+	for(i=0;i<12;i++)
+		seq_printf(m, "stats[%d] = %d\n", i,
+			wifi->stats.sleep_stats[i]);
+	seq_printf(m, "rpu_boot_cnt=%d\n",
+		   wifi->stats.rpu_boot_cnt);
+	seq_printf(m, "fw state: %d\n", rk915_readb(hpriv, IO_FW_STATE));
+
+	return 0;
+}
+
+static int proc_open_sleep_stats(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_sleep_stats, NULL);
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
+static const struct proc_ops params_fops_sleep_stats = {
+    .proc_open = proc_open_sleep_stats,
+    .proc_read = seq_read,
+    .proc_lseek = seq_lseek,
+    .proc_write = NULL,
+    .proc_release = single_release
+};
+#else
+static const struct file_operations params_fops_sleep_stats = {
+	.open = proc_open_sleep_stats,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = NULL,
+	.release = single_release
+};
+#endif
+#endif
+
+static int proc_read_config(struct seq_file *m, void *v)
+{
+	int i = 0;
+	int rf_params_size = sizeof(wifi->params.rf_params) /
+			     sizeof(wifi->params.rf_params[0]);
+	struct img_priv *priv;
+        unsigned int nss, flags;
+        int mcs;
+	
+	if (!wifi->hw)
+		return -ENODEV;
+
+	priv = ((struct img_priv *)(wifi->hw->priv));
+
+#ifdef HAL_PCIE
+	seq_puts(m, "*********read pci_mem_region************\n");
+	seq_printf(m,"pci_base_addr= %x\n",wifi->params.pci_base_addr);
+	seq_printf(m,"num_words=%d\n",wifi->params.no_words);
+#endif
+	seq_puts(m, "************* Configurable Parameters ***********\n");
+	seq_printf(m, "sensitivity = %d\n", wifi->params.ed_sensitivity);
+	seq_printf(m, "auto_sensitivity = %d\n", wifi->params.auto_sensitivity);
+	/*RF Input params*/
+	seq_puts(m, "rf_params =");
+	for (i = 0; i < rf_params_size; i++)
+		seq_printf(m, " %02X", wifi->params.rf_params[i]);
+
+	seq_puts(m, "\n");
+
+	seq_puts(m, "rf_params_vpd =");
+	for (i = 0; i < rf_params_size; i++)
+		seq_printf(m, " %02X", wifi->params.rf_params_vpd[i]);
+
+	seq_puts(m, "\n");
+	seq_printf(m, "bypass_vpd = %d\n", wifi->params.bypass_vpd);
+	seq_printf(m, "production_test = %d\n", wifi->params.production_test);
+	seq_printf(m, "enable_early_agg_checks = %d\n",
+		   wifi->params.enable_early_agg_checks);
+	seq_printf(m, "antenna_sel (RPU Init) = %d\n",
+		   wifi->params.antenna_sel);
+	seq_printf(m, "max_data_size = %d (%dK)\n",
+		   wifi->params.max_data_size,
+		   wifi->params.max_data_size/1024);
+	seq_printf(m, "max_tx_cmds = %d\n",
+		   wifi->params.max_tx_cmds);
+	seq_printf(m, "disable_power_save (Disables all power save's) = %d\n",
+		   wifi->params.disable_power_save);
+	seq_printf(m, "disable_sm_power_save (Disables MIMO PS only) = %d\n",
+		   wifi->params.disable_sm_power_save);
+
+	seq_printf(m, "num_vifs = %d\n",
+		   wifi->params.num_vifs);
+
+	seq_printf(m, "chnl_bw = %d\n",
+		   wifi->params.chnl_bw);
+
+	seq_printf(m, "rate_protection_type = %d (0: Disable, 1: Enable)\n",
+		   wifi->params.rate_protection_type);
+	if (wifi->params.production_test) {
+		mcs = wifi->params.tx_fixed_mcs_indx;
+		flags = wifi->params.prod_mode_rate_flag;
+		seq_puts(m, "***Production Mode Rate config options\n");
+		seq_printf(m, "tx_fixed_mcs_indx = %d (%s)\n",
+			   mcs, get_string_from_rate(mcs, flags));
+		if (wifi->params.tx_fixed_rate > -1) {
+			if (wifi->params.tx_fixed_rate == 55)
+				seq_puts(m, "tx_fixed_rate = 5.5\n");
+			else
+				seq_printf(m, "tx_fixed_rate = %d\n",
+					   wifi->params.tx_fixed_rate);
+		} else
+			seq_printf(m, "tx_fixed_rate = %d\n",
+				   wifi->params.tx_fixed_rate);
+	} else {
+		seq_puts(m, "***Unicast Fixed rate config options\n");
+		mcs = wifi->params.mgd_mode_tx_fixed_mcs_indx;
+		flags = wifi->params.prod_mode_rate_flag;
+		seq_printf(m, "mgd_mode_tx_fixed_mcs_indx = %d (%s)\n",
+			   mcs, get_string_from_rate(mcs, flags));
+		if (wifi->params.mgd_mode_tx_fixed_rate > -1) {
+			if (wifi->params.mgd_mode_tx_fixed_rate == 55)
+				seq_puts(m, "mgd_mode_tx_fixed_rate = 5.5\n");
+			else
+				seq_printf(m, "mgd_mode_tx_fixed_rate = %d\n",
+					   wifi->params.mgd_mode_tx_fixed_rate);
+		} else
+			seq_printf(m, "mgd_mode_tx_fixed_rate = %d\n",
+				   wifi->params.mgd_mode_tx_fixed_rate);
+	}
+
+	if (wifi->params.prod_mode_rate_flag & ENABLE_11N_FORMAT)
+		nss = wifi->params.mgd_mode_tx_fixed_mcs_indx/8 + 1;
+	else
+		nss = wifi->params.num_spatial_streams;
+
+	seq_puts(m, "Bits:11N-NA-NA-NA\n");
+	seq_printf(m, "prod_mode_rate_flag = %d\n",
+		   wifi->params.prod_mode_rate_flag);
+	seq_printf(m, "prod_mode_rate_preamble_type (0: Short, 1: Long) = %d\n",
+		   wifi->params.prod_mode_rate_preamble_type);
+
+	seq_puts(m, "***Multicast Fixed rate config options\n");
+
+	mcs = wifi->params.mgd_mode_mcast_fixed_data_rate;
+	flags = wifi->params.mgd_mode_mcast_fixed_rate_flags;
+	if ((mcs != -1) && (mcs & 0x80))
+		mcs = mcs & 0x7F;
+
+	if (flags & ENABLE_11N_FORMAT)
+		nss = mcs/8 + 1;
+	else
+		nss = wifi->params.mgd_mode_mcast_fixed_nss;
+
+
+	seq_printf(m, "mgd_mode_mcast_fixed_data_rate = %d (%s)\n",
+		   mcs, get_string_from_rate(mcs, flags));
+	seq_puts(m, "Bits:11N-NA-NA-NA\n");
+	seq_printf(m, "mgd_mode_mcast_fixed_rate_flags = %d\n",
+		   wifi->params.mgd_mode_mcast_fixed_rate_flags);
+	seq_printf(m, "mgd_mode_mcast_fixed_preamble = %d\n",
+		   wifi->params.mgd_mode_mcast_fixed_preamble);
+	seq_printf(m, "bg_scan_enable = %d\n",
+		   wifi->params.bg_scan_enable);
+	seq_puts(m, "bg_scan_channel_list =");
+
+	for (i = 0; i < wifi->params.bg_scan_num_channels;  i++) {
+		if (wifi->params.bg_scan_channel_list[i])
+			seq_printf(m, " %d",
+				   wifi->params.bg_scan_channel_list[i]);
+	}
+
+	seq_puts(m, "\n");
+	seq_puts(m, "bg_scan_channel_flags =");
+
+	for (i = 0; i < wifi->params.bg_scan_num_channels;  i++) {
+		if (wifi->params.bg_scan_channel_flags[i])
+			seq_printf(m, " %d",
+				   wifi->params.bg_scan_channel_flags[i]);
+	}
+
+	seq_puts(m, "\n");
+	seq_printf(m, "bg_scan_intval = %dms\n",
+		   wifi->params.bg_scan_intval/1000);
+	seq_printf(m, "bg_scan_num_channels = %d\n",
+		   wifi->params.bg_scan_num_channels);
+	seq_printf(m, "scan_type = %d (PASSIVE: 0, ACTIVE: 1)\n",
+		   wifi->params.scan_type);
+ 	seq_printf(m, "fw_loaded = %d\n", wifi->params.fw_loaded);
+
+
+	seq_puts(m, "****** Production Test (or) FTM Parameters *******\n");
+	seq_printf(m, "start_packet_gen = %d (-1: Infinite loop)\n",
+		   wifi->params.pkt_gen_val);
+	seq_printf(m, "payload_length = %d bytes\n",
+		   wifi->params.payload_length);
+	seq_printf(m, "start_prod_mode = channel: %d\n",
+		   wifi->params.start_prod_mode);
+	seq_printf(m, "fw_skip_rx_pkt_submit = %d\n",
+		   wifi->params.fw_skip_rx_pkt_submit);	
+
+	if (ftm || wifi->params.production_test)
+		seq_printf(m, "set_tx_power = %d dB\n",
+			   wifi->params.set_tx_power);
+
+	seq_printf(m, "center_frequency = %d\n",
+		   ieee80211_frequency_to_channel(priv->cur_chan.center_freq1));
+
+	if (ftm)
+		seq_printf(m, "aux_adc_chain_id = %d\n",
+			   wifi->params.aux_adc_chain_id);
+#ifdef RPU_SLEEP_ENABLE
+	seq_printf(m, "sleep_status=%x\n", hal_ops.rpu_sleep_status());
+	seq_puts(m, "RPU Sleep Type 0: Sleep Enabled, 32: Sleep Disabled)\n");
+	seq_printf(m, "rpu_sleep_type= %d\n", wifi->params.rpu_sleep_type);
+#endif
+	seq_puts(m, "RPU Runtime Debug Support Configuration.\n");
+	seq_printf(m, "rpu_debug = %d.\n", rpu_debug);
+#define PRINT_DEBUG_MOD(MOD_NAME, MOD_ID) \
+	do {\
+		seq_printf(m, "***rpu_debug: %s: val= %d, status= %s\n", MOD_NAME, MOD_ID, rpu_debug & MOD_ID ? "ENABLED": "DISABLED");\
+	} while(0);\
+
+	PRINT_DEBUG_MOD("SCAN", RPU_DEBUG_SCAN);
+	PRINT_DEBUG_MOD("ROC", RPU_DEBUG_ROC);
+	PRINT_DEBUG_MOD("TX", RPU_DEBUG_TX);
+	PRINT_DEBUG_MOD("MAIN", RPU_DEBUG_MAIN);
+	PRINT_DEBUG_MOD("RPU_IF", RPU_DEBUG_IF);
+	PRINT_DEBUG_MOD("UMACIF", RPU_DEBUG_UMACIF);
+	PRINT_DEBUG_MOD("RX", RPU_DEBUG_RX);
+	PRINT_DEBUG_MOD("HAL", RPU_DEBUG_HAL);
+	PRINT_DEBUG_MOD("CRYPTO", RPU_DEBUG_CRYPTO);
+	PRINT_DEBUG_MOD("TX_DUMP", RPU_DEBUG_DUMP_TX);
+	PRINT_DEBUG_MOD("RX_DUMP", RPU_DEBUG_DUMP_RX);
+	PRINT_DEBUG_MOD("HAL_DUMP", RPU_DEBUG_DUMP_HAL);
+
+	seq_puts(m, "HELP: Add the values beside each module and\n");
+	seq_puts(m, " echo rpu_debug=<SUM> to enable logging\n");
+	seq_puts(m, " for those modules.\n");
+
+	seq_puts(m, "To see the updated stats\n");
+	seq_puts(m, "please run: echo get_stats=1 > /proc/rpu/params\n");
+	seq_puts(m, "To read/write fw register\n");
+	seq_puts(m, "for example: read  reg 0x42000000, len is 4 bytes (max len is 1024 bytes)\n");
+	seq_puts(m, "for example: write val 0x10101010 to reg 0x42000000\n");
+	seq_puts(m, "please run for read  : echo read_fw_reg =0x42000000,0x4 > /proc/rpu/params\n");
+	seq_puts(m, "please run for wirete: echo write_fw_reg=0x42000000,0x10101010 > /proc/rpu/params\n");
+	seq_puts(m, "************* VERSION ***********\n");
+	seq_printf(m, "RPU_DRIVER_VERSION = %s\n", RPU_DRIVER_VERSION);
+
+	if (wifi->hw &&
+	    (((struct img_priv *)(wifi->hw->priv))->state != STARTED)) {
+		seq_printf(m, "LMAC_VERSION = %s\n", "UNKNOWN");
+		seq_printf(m, "Firmware version = %s\n", "UNKNOWN");
+	} else {
+		seq_printf(m, "LMAC_VERSION = %s\n",
+			   wifi->stats.rpu_lmac_version);
+		seq_printf(m, "Firmware version= %d.%d\n",
+			   (wifi->stats.rpu_lmac_version[0] - '0'),
+			   (wifi->stats.rpu_lmac_version[2] - '0'));
+		seq_printf(m, "FW version= %s\n", wifi->stats.fw_version);
+	}
+
+	return 0;
+}
+
+
+static int proc_read_phy_stats(struct seq_file *m, void *v)
+{
+	int i = 0;
+
+	seq_puts(m, "************* BB Stats ***********\n");
+
+	seq_printf(m, "csync_timeout_cntr  =%x\n",
+		   wifi->stats.csync_timeout_cntr);
+	seq_printf(m, "fsync_timeout_cntr  =%x\n",
+		   wifi->stats.fsync_timeout_cntr);
+	seq_printf(m, "acdrop_timeout_cntr  =%x\n",
+		   wifi->stats.acdrop_timeout_cntr);
+	seq_printf(m, "csync_abort_agctrig_cntr  =%x\n",
+		   wifi->stats.csync_abort_agctrig_cntr);
+	seq_printf(m, "crc_success_cnt  =%d\n",
+		   wifi->stats.crc_success_cnt);
+	seq_printf(m, "crc_fail_cnt  =%d\n",
+		   wifi->stats.crc_fail_cnt);
+
+	seq_puts(m, "************* RF Stats ***********\n");
+	/*RF output data*/
+	seq_puts(m, "rf_calib_data =");
+	for (i = 0; i < wifi->stats.rf_calib_data_length; i++)
+		seq_printf(m, "%02X", wifi->stats.rf_calib_data[i]);
+
+	seq_puts(m, "\n");
+	return 0;
+}
+
+static void dump_tx_buff_info(struct seq_file *m, struct tx_config *tx)
+{
+	int i, j;
+	struct sk_buff_head *pend_pkt_q;
+
+	seq_printf(m, "tx_buff_pool_map (LE) = \n\t");
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		if (test_bit(i, &tx->buf_pool_bmp[0]))
+			seq_printf(m, "1 ");
+		else
+			seq_printf(m, "0 ");
+		if (((i+1)%5) == 0)
+			seq_printf(m, ", ");
+	}
+	seq_printf(m, "\n");
+
+	seq_printf(m, "outstanding_pkts = \n\t");
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		seq_printf(m, "%d ", tx->outstanding_pkts[i]);
+		if (((i+1)%5) == 0)
+			seq_printf(m, ", ");
+	}
+	seq_printf(m, "\n");	
+
+	seq_printf(m, "outstanding_tokens = \n\t");
+	for (i = 0; i < NUM_ACS; i++) {
+		seq_printf(m, "%d ", tx->outstanding_tokens[i]);
+	}
+	seq_printf(m, "\n");
+
+	seq_printf(m, "curr_peer_opp = \n\t");
+	for (i = 0; i < NUM_ACS; i++) {
+		seq_printf(m, "%d ", tx->curr_peer_opp[i]);
+	}
+	seq_printf(m, "\n");
+
+	seq_printf(m, "queue_stopped_bmp = \n\t");
+	for (i = 0; i < NUM_ACS; i++) {
+		if (tx->queue_stopped_bmp & (1 << i))
+			seq_printf(m, "1 ");
+		else
+			seq_printf(m, "0 ");
+	}
+	seq_printf(m, "\n");
+
+	seq_printf(m, "pending_pkt = \n");
+	for (j = 0; j < MAX_PEND_Q_PER_AC; j++) {
+		seq_printf(m, "\t");
+		for (i = 0; i < NUM_ACS; i++) {
+			pend_pkt_q = &tx->pending_pkt[j][i];
+			seq_printf(m, "%03d ", skb_queue_len(pend_pkt_q));
+		}
+		seq_printf(m, "\n");
+	}
+}
+
+static int proc_read_mac_stats(struct seq_file *m, void *v)
+{
+	unsigned int index;
+	unsigned int total_samples = 0;
+	unsigned int total_value = 0;
+	int total_rssi_samples = 0;
+	int total_rssi_value = 0;
+	struct img_priv *priv = NULL;
+
+	if (!wifi->hw)
+		return -ENODEV;
+
+	priv= (struct img_priv *)(wifi->hw->priv);
+
+	if (ftm) {
+		for (index = 0; index < MAX_AUX_ADC_SAMPLES; index++) {
+			if (!wifi->params.pdout_voltage[index])
+				continue;
+
+			total_value += wifi->params.pdout_voltage[index];
+			total_samples++;
+		}
+	}
+
+	for (index = 0; index < MAX_RSSI_SAMPLES; index++) {
+
+		if (!wifi->params.production_test)
+			break;
+
+		if (!wifi->params.rssi_average[index])
+			continue;
+
+		total_rssi_value += wifi->params.rssi_average[index];
+		total_rssi_samples++;
+	}
+
+	seq_puts(m, "************* UMAC STATS ***********\n");
+	seq_printf(m, "rx_packet_mgmt_count = %d\n",
+		   wifi->stats.rx_packet_mgmt_count);
+	seq_printf(m, "rx_packet_data_count = %d\n",
+		   wifi->stats.rx_packet_data_count);
+	seq_printf(m, "tx_packet_count(HT MCS0) = %d\n",
+		   wifi->stats.ht_tx_mcs0_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS1) = %d\n",
+		   wifi->stats.ht_tx_mcs1_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS2) = %d\n",
+		   wifi->stats.ht_tx_mcs2_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS3) = %d\n",
+		   wifi->stats.ht_tx_mcs3_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS4) = %d\n",
+		   wifi->stats.ht_tx_mcs4_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS5) = %d\n",
+		   wifi->stats.ht_tx_mcs5_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS6) = %d\n",
+		   wifi->stats.ht_tx_mcs6_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS7) = %d\n",
+		   wifi->stats.ht_tx_mcs7_packet_count);
+
+	if (wifi->params.uccp_num_spatial_streams == 2) {
+		seq_printf(m, "tx_packet_count(HT MCS8) = %d\n",
+			   wifi->stats.ht_tx_mcs8_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS9) = %d\n",
+			   wifi->stats.ht_tx_mcs9_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS10) = %d\n",
+			   wifi->stats.ht_tx_mcs10_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS11) = %d\n",
+			   wifi->stats.ht_tx_mcs11_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS12) = %d\n",
+			   wifi->stats.ht_tx_mcs12_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS13) = %d\n",
+			   wifi->stats.ht_tx_mcs13_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS14) = %d\n",
+			   wifi->stats.ht_tx_mcs14_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS15) = %d\n",
+			   wifi->stats.ht_tx_mcs15_packet_count);
+	}
+	seq_printf(m, "tx_cmds_from_stack= %d\n",
+		   wifi->stats.tx_cmds_from_stack);
+	seq_printf(m, "tx_dones_to_stack= %d\n",
+		   wifi->stats.tx_dones_to_stack);
+	seq_printf(m, "tx_noagg_not_addr= %d\n",
+		   wifi->stats.tx_noagg_not_addr);
+	seq_printf(m, "tx_noagg_not_ampdu= %d\n",
+		   wifi->stats.tx_noagg_not_ampdu);
+	seq_printf(m, "tx_noagg_not_qos= %d\n",
+		   wifi->stats.tx_noagg_not_qos);
+	seq_printf(m, "outstanding_cmd_cnt = %d (%d %d)\n",
+		   wifi->stats.outstanding_cmd_cnt, skb_queue_len(&cmd_info.outstanding_cmd),
+		   priv->stats->max_outstanding_cmd_queue_cnt);
+	seq_printf(m, "gen_cmd_send_count = %d\n",
+		   wifi->stats.gen_cmd_send_count);
+	seq_printf(m, "umac_scan_req = %d\n",
+		   wifi->stats.umac_scan_req);
+	seq_printf(m, "umac_scan_complete = %d\n",
+		   wifi->stats.umac_scan_complete);
+	seq_printf(m, "hw_scan_status = %d\n",
+		   wifi->params.hw_scan_status);
+	seq_printf(m, "roc_in_progress = %d\n",
+			priv->roc_params.roc_in_progress);
+	seq_printf(m, "roc_starting = %d\n",
+			priv->roc_params.roc_starting);
+	seq_printf(m, "tx_cmd_send_count_single = %d\n",
+		   wifi->stats.tx_cmd_send_count_single);
+	seq_printf(m, "tx_cmd_send_count_multi = %d\n",
+		   wifi->stats.tx_cmd_send_count_multi);
+	seq_printf(m, "tx_cmd_send_count_beacon_q = %d\n",
+		   wifi->stats.tx_cmd_send_count_beaconq);
+	seq_printf(m, "tx_done_recv_count = %d\n",
+		   wifi->stats.tx_done_recv_count);
+
+	seq_printf(m, "tx_buff_pool_map = %x\n",
+		   (unsigned int)priv->tx.buf_pool_bmp[0]);
+	dump_tx_buff_info(m, &priv->tx);
+
+	if (ftm)
+		seq_printf(m, "pdout_val = %d (total samples: %d)\n",
+			   total_samples ? (total_value/total_samples) : 0,
+			   total_samples);
+	if (wifi->params.production_test)
+		seq_printf(m,
+			   "rssi_average = %d dBm (total rssi samples: %d)\n",
+			   total_rssi_samples ?
+			   (total_rssi_value/total_rssi_samples) : 0,
+			   total_rssi_samples);
+
+	seq_puts(m, "************* LMAC STATS ***********\n");
+	seq_printf(m, "roc_start =%d\n",
+		   wifi->stats.roc_start);
+	seq_printf(m, "roc_stop =%d\n",
+		   wifi->stats.roc_stop);
+	seq_printf(m, "roc_complete =%d\n",
+		   wifi->stats.roc_complete);
+	seq_printf(m, "roc_stop_complete =%d\n",
+		   wifi->stats.roc_stop_complete);
+	/* TX related */
+	seq_printf(m, "tx_cmd_cnt =%d\n",
+		   wifi->stats.tx_cmd_cnt);
+	seq_printf(m, "tx_done_cnt =%d\n",
+		   wifi->stats.tx_done_cnt);
+	seq_printf(m, "tx_edca_trigger_cnt =%d\n",
+		   wifi->stats.tx_edca_trigger_cnt);
+	seq_printf(m, "tx_edca_isr_cnt =%d\n",
+		   wifi->stats.tx_edca_isr_cnt);
+	seq_printf(m, "tx_start_cnt =%d\n",
+		   wifi->stats.tx_start_cnt);
+	seq_printf(m, "tx_abort_cnt =%d\n",
+		   wifi->stats.tx_abort_cnt);
+	seq_printf(m, "tx_abort_isr_cnt =%d\n",
+		   wifi->stats.tx_abort_isr_cnt);
+	seq_printf(m, "tx_underrun_cnt =%d\n",
+		   wifi->stats.tx_underrun_cnt);
+	seq_printf(m, "tx_rts_cnt =%d\n",
+		   wifi->stats.tx_rts_cnt);
+	seq_printf(m, "tx_ampdu_cnt =%d\n",
+		   wifi->stats.tx_ampdu_cnt);
+	seq_printf(m, "tx_mpdu_cnt =%d\n",
+		   wifi->stats.tx_mpdu_cnt);
+	seq_printf(m, "tx_crypto_post =%d\n",
+		   wifi->stats.tx_crypto_post);
+	seq_printf(m, "tx_crypto_done =%d\n",
+		   wifi->stats.tx_crypto_done);
+	seq_printf(m, "rx_pkt_to_umac =%d\n",
+		   wifi->stats.rx_pkt_to_umac);
+	seq_printf(m, "rx_crypto_post =%d\n",
+		   wifi->stats.rx_crypto_post);
+	seq_printf(m, "rx_crypto_done =%d\n",
+		   wifi->stats.rx_crypto_done);
+	/* RX related */
+	seq_printf(m, "rx_isr_cnt  =%d\n",
+		   wifi->stats.rx_isr_cnt);
+	seq_printf(m, "rx_ack_cts_to_cnt =%d\n",
+		   wifi->stats.rx_ack_cts_to_cnt);
+	seq_printf(m, "rx_cts_cnt =%d\n",
+		   wifi->stats.rx_cts_cnt);
+	seq_printf(m, "rx_ack_resp_cnt =%d\n",
+		   wifi->stats.rx_ack_resp_cnt);
+	seq_printf(m, "rx_ba_resp_cnt =%d\n",
+		   wifi->stats.rx_ba_resp_cnt);
+	seq_printf(m, "rx_fail_in_ba_bitmap_cnt =%d\n",
+		   wifi->stats.rx_fail_in_ba_bitmap_cnt);
+	seq_printf(m, "rx_circular_buffer_free_cnt =%d\n",
+		   wifi->stats.rx_circular_buffer_free_cnt);
+	seq_printf(m, "rx_mic_fail_cnt =%d\n",
+		   wifi->stats.rx_mic_fail_cnt);
+
+	/* HAL related */
+	seq_printf(m, "hal_cmd_cnt  =%d\n",
+		   wifi->stats.hal_cmd_cnt);
+	seq_printf(m, "hal_event_cnt =%d\n",
+		   wifi->stats.hal_event_cnt);
+	seq_printf(m, "hal_ext_ptr_null_cnt =%d\n",
+		   wifi->stats.hal_ext_ptr_null_cnt);
+	seq_printf(m, "fw_error_counter = %d\n",
+			hpriv->fw_error_counter);
+	seq_printf(m, "fw_error_counter_scan = %d\n",
+			hpriv->fw_error_counter_scan);
+	seq_printf(m, "lpw_error_counter = %d\n",
+			hpriv->lpw_error_counter);
+
+	/* power save */
+	seq_printf(m, "wifi power save (%s)\n",
+			priv->power_save ? "AWAKE":"SLEEP");
+
+	/* interface info */
+	seq_printf(m, "current_vif_count = %d\n", priv->current_vif_count);
+	seq_printf(m, "active_vifs = %d\n", priv->active_vifs);
+	for (index = 0; index < MAX_VIFS; index++) {
+		struct ieee80211_vif *vif = priv->vifs[index];
+		struct umac_vif *uvif;
+
+		if (!vif)
+			break;
+		uvif = (struct umac_vif *)&vif->drv_priv;
+		if (!uvif)
+			break;
+		seq_printf(m, "\tvif_index %d\n", uvif->vif_index);
+		seq_printf(m, "\ttype = %d\n", vif->type);
+		seq_printf(m, "\taddr %pM\n", vif->addr);
+		seq_printf(m, "\tbssid %pM\n", uvif->bssid);
+		/*seq_printf(m, "atim_window = %d, aid = %d\n",
+				uvif->config.atim_window, uvif->config.aid);*/
+	}
+
+#ifdef ENABLE_DAPT
+	/*dapt info */
+	seq_printf(m, "dapt info:\n");
+	seq_printf(m, "main_index = %d\n", priv->dapt_params.main_index);
+	seq_printf(m, "p2p_index = %d\n", priv->dapt_params.p2p_index);
+	seq_printf(m, "conn_state[0] = %d, conn_state[1] = %d\n",
+				priv->dapt_params.conn_state[0], priv->dapt_params.conn_state[1]);
+	seq_printf(m, "iftype = %d\n", priv->iftype);
+	seq_printf(m, "dapt_thresh_offset = %d\n", priv->params->dapt_thresh_offset);
+	seq_printf(m, "dapt_thresh_exponent = %d\n", priv->params->dapt_thresh_exponent);
+	seq_printf(m, "dapt_thresh_min = %d\n", priv->params->dapt_thresh_min);
+	seq_printf(m, "dapt_thresh_max = %d\n", priv->params->dapt_thresh_max);
+	for (index = 0; index < MAX_VIFS; index++) {
+		seq_printf(m, "\tvif_addr = %pM, bssid = %pM, conn_state = %d\n",
+					priv->dapt_params.vif_addr[index],
+					priv->dapt_params.bssid[index],
+					priv->dapt_params.conn_state[index]);
+		seq_printf(m, "thresh_accum = %d\n", priv->dapt_params.thresh_accum[index]);
+		seq_printf(m, "avg_thresh = %d\n", priv->dapt_params.avg_thresh[index]);
+		seq_printf(m, "new_thresh = %d\n", priv->dapt_params.new_thresh[index]);
+	}
+	seq_printf(m, "cur_seted_thresh:\n\t");
+	for (index = 0; index < 14; index++) {
+		seq_printf(m, "%03d ", priv->dapt_params.cur_seted_thresh[index]);
+	}
+
+	seq_printf(m, "\nthreld history:\n");
+	for (index = 0; index < 14; index++) {
+		int s;
+
+		if (ieee80211_frequency_to_channel(priv->cur_chan.center_freq1) == index + 1) {
+			seq_printf(m, "\t ***channel %02d: offset %02d: ", index + 1, priv->dapt_params.cur_thr_offset[index]);
+		} else {
+			seq_printf(m, "\t channel %02d: offset %02d: ", index + 1, priv->dapt_params.cur_thr_offset[index]);
+		}
+		for (s = 0; s < DAPT_SETED_PHY_THRESH_COUNT; s++) {
+			if (priv->dapt_params.cur_thr_offset[index] == s + 1) {
+				seq_printf(m, "***");
+			} else if (priv->dapt_params.cur_thr_offset[index] == 0) {
+				if (s == DAPT_SETED_PHY_THRESH_COUNT - 1)
+					seq_printf(m, "***");
+			}
+			seq_printf(m, "%03d ", priv->dapt_params.thr_history[index][s]);
+		}
+		seq_printf(m, "\n");
+	}
+#endif
+
+	seq_printf(m, "rxq len = %d\n", skb_queue_len(&hpriv->rxq));
+	seq_printf(m, "max_rxq len = %d\n", hpriv->max_rxq_len);
+	seq_printf(m, "txq len = %d\n", skb_queue_len(&hpriv->txq));
+
+	seq_printf(m, "cmd_reset_count = %d\n", priv->cmd_reset_count);
+
+	seq_printf(m, "null_frame_send_count = %d\n", priv->null_frame_send_count);
+
+	seq_printf(m, "tx_retry_frm_cnt: %d\n", priv->tx_retry_frm_cnt);
+	return 0;
+
+}
+
+struct time_info {
+	unsigned int count;
+	unsigned int max_time;
+	unsigned long long total_time;
+};
+
+struct vif_info {
+	int if_ctrl;
+	int if_idx;
+	int if_mode;
+	int if_conn_sta;
+	unsigned char if_addr[6];
+	unsigned char bssid[6];
+	int key_ctrl;
+	int key_type;
+};
+
+#define MAX_IF 2
+struct if_info {
+	int num;
+	struct vif_info vif_info[MAX_IF];
+};
+
+struct filter_pkt_info {
+	unsigned int total_pkt;	
+	unsigned int probe_req_pkt;
+	unsigned int bcast_pkt;
+	unsigned int mcast_pkt;	
+};
+
+struct tx_rx_count_info {
+	unsigned int cmd_tx_send;
+	unsigned int cmd_send;
+	unsigned int event_recv;
+	unsigned int event_rx_recv;
+	unsigned int event_rx_pkt_recv;
+	unsigned int event_rx_pkt_crc_ok;
+	unsigned int event_rx_pkt_crc_err;
+	unsigned int event_tx_done_recv;
+	unsigned int event_rx_serias;
+	unsigned short err_desc_id_lmac;
+	unsigned short err_desc_id_host;
+	unsigned short lpw_hang;
+	unsigned short lpw_hang_cnt;
+	unsigned short cmd_cnt_dur_lpw_hang;
+	unsigned short cmd_txcnt_dur_lpw_hang;
+	unsigned short cmd_rxcnt_dur_lpw_hang;
+	struct time_info wifi_isr_info;
+	struct time_info sdio_isr_info[4];
+	struct time_info cmd_send_info;
+	unsigned int cmd_id;
+	unsigned long long total_tick;
+
+	struct time_info rx_notify;
+	struct time_info rx_begin;
+	struct time_info rx_end;
+	struct time_info rx_interval;
+	int lpw_rx_q_min;
+	short wifi_int_disabled;
+
+	struct time_info tx_done;
+	struct time_info scan_hang;
+
+	struct filter_pkt_info filter_info;
+};
+
+static void dump_time_info(struct seq_file *m,
+					struct time_info *info, char *str)
+{
+	unsigned long long value;
+
+	/* total_time from fw unit is 25ns, so need to div 40 (convert to us) */
+	value = info->total_time>>2;
+	if (info->count != 0)
+		do_div(value, info->count);
+	seq_printf(m, "%s:\n"
+				"\ttotal_time = %lld\b us\n"
+				"\tmax_time = %d us\n"
+				"\tcount = %d\n"
+				"\tavg = %d us\n",
+				str,
+				info->total_time>>2,
+				info->max_time/40,
+				info->count,
+				(unsigned int)value/10);
+}
+
+static void dump_if_info(struct seq_file *m,
+					struct if_info *info)
+{
+	int i;
+
+	for (i = 0; i < MAX_IF; i++) {
+		seq_printf(m, "if_idx %d:\n", info->vif_info[i].if_idx);
+		seq_printf(m, "\tif_ctrl=%s\n", info->vif_info[i].if_ctrl==IF_ADD ? "ADD":"DEL");
+		switch (info->vif_info[i].if_mode) {
+		case IF_MODE_STA_BSS:
+			seq_printf(m, "\tif_mode=IF_MODE_STA_BSS\n");
+			break;
+		case IF_MODE_STA_IBSS:
+			seq_printf(m, "\tif_mode=IF_MODE_STA_IBSS\n");
+			break;
+		case IF_MODE_AP:
+			seq_printf(m, "\tif_mode=IF_MODE_AP\n");
+			break;
+		default:
+			seq_printf(m, "\tif_mode=UNKNOW\n");
+			break;
+		}
+		seq_printf(m, "\tif_conn_sta=%s\n", info->vif_info[i].if_conn_sta==STA_CONN ? "STA_CONN":"STA_DISCONN");
+		seq_printf(m, "\tif_addr=%pM\n", info->vif_info[i].if_addr);
+		seq_printf(m, "\tbssid=%pM\n", info->vif_info[i].bssid);
+		seq_printf(m, "\tkey_ctrl=%s\n", info->vif_info[i].key_ctrl==KEY_CTRL_ADD ? "ADD":"DEL");
+		seq_printf(m, "\tkey_type=%d\n", info->vif_info[i].key_type);
+	}
+}
+
+static void* fw_log_seq_start(struct seq_file *s, loff_t *pos)
+{
+	static int read_finish = 0;
+	struct img_priv *priv;
+	struct fw_info_dump *fw_info = &wifi->fw_info;
+
+	pr_debug("%s: %d\n", __func__, read_finish);
+
+	if (read_finish == 1) {
+		read_finish = 0;
+		return NULL;// no more data to read, exit
+	}
+
+	if (!wifi->hw)
+		return NULL;
+
+	priv = (struct img_priv *)(wifi->hw->priv);
+	if (priv->state != STARTED) {
+		pr_err("Interface is not initialized\n");
+		return NULL;
+	}
+
+	if (rpu_fw_priv_cmd_sync(DUMP_FW_LOG, NULL) != 0) {
+		pr_err("%s: send cmd failed\n", __func__);
+		return NULL;
+	}
+	pr_debug("%s: read log %d\n", __func__, fw_info->offset);
+
+	fw_info->finish = 0;
+
+#define PRIV_CMD_DONE_EVENT_HEADER_SIZE (sizeof(struct host_rpu_msg_hdr) + sizeof(struct dump_info) - 1)
+
+	read_finish = (fw_info->offset<(128-PRIV_CMD_DONE_EVENT_HEADER_SIZE))?1:0;
+
+	return fw_info->info;
+}
+
+static void* fw_log_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	return NULL;
+}
+
+static void fw_log_seq_stop(struct seq_file *s, void *v)
+{
+}
+
+static int fw_log_seq_show(struct seq_file *s, void *v)
+{
+	seq_printf(s, "%s", (char*)v);
+	return 0;
+}
+
+static struct seq_operations fw_log_seq_ops = {
+	.start = fw_log_seq_start,
+	.next  = fw_log_seq_next,
+	.stop  = fw_log_seq_stop,
+	.show  = fw_log_seq_show
+};
+
+static void dump_txrx_count_info(struct seq_file *m, struct fw_info_dump *fw_info)
+{
+	unsigned long long result = 0, delta1, delta2;
+	struct tx_rx_count_info *info = (struct tx_rx_count_info*)fw_info->info;
+	
+	seq_printf(m, "cmd_tx_send = %d\n"
+				 "cmd_send = %d\n"
+				 "event_recv = %d\n"
+				 "event_rx_recv = %d\n"
+				 "event_rx_pkt_recv = %d\n"
+				 "event_rx_pkt_crc_ok = %d\n"
+				 "event_rx_pkt_crc_err = %d\n"
+				 "event_tx_done_recv = %d\n"
+				 "event_rx_serias = %d\n"
+				 "err_desc_id_lmac = %d\n"
+				 "err_desc_id_host = %d\n"
+				 "lpw_hang = %d\n"
+				 "lpw_hang_cnt = %d\n"
+				 "cmd_cnt_dur_lpw_hang = %d\n"
+				 "cmd_txcnt_dur_lpw_hang = %d\n"
+				 "cmd_rxcnt_dur_lpw_hang = %d\n",
+				 info->cmd_tx_send,
+				 info->cmd_send,
+				 info->event_recv,
+				 info->event_rx_recv,
+				 info->event_rx_pkt_recv,
+				 info->event_rx_pkt_crc_ok,
+				 info->event_rx_pkt_crc_err,
+				 info->event_tx_done_recv,
+				 info->event_rx_serias,
+				 info->err_desc_id_lmac,
+				 info->err_desc_id_host,
+				 info->lpw_hang,
+				 info->lpw_hang_cnt,
+				 info->cmd_cnt_dur_lpw_hang,
+				 info->cmd_txcnt_dur_lpw_hang,
+				 info->cmd_rxcnt_dur_lpw_hang);
+	
+	dump_time_info(m, &info->wifi_isr_info, "wifi isr info");
+	result += info->wifi_isr_info.total_time;
+	
+	dump_time_info(m, &info->sdio_isr_info[0], "sdio isr (COMP)");
+	result += info->sdio_isr_info[0].total_time;
+	dump_time_info(m, &info->sdio_isr_info[1], "sdio isr (DMA)");
+	result += info->sdio_isr_info[1].total_time;
+	dump_time_info(m, &info->sdio_isr_info[2], "sdio isr (WR)");
+	result += info->sdio_isr_info[2].total_time;
+	dump_time_info(m, &info->sdio_isr_info[3], "sdio isr (RD)");
+	result += info->sdio_isr_info[3].total_time;
+	
+	delta1 = result - fw_info->last_total_isr_tick;
+	delta2 = info->total_tick - fw_info->last_total_tick;
+	do_div(delta1, 40*1000);
+	do_div(delta2, 40*1000);
+	seq_printf(m, "isr/total tick (%lld/%lld ms)\n",
+			delta1, delta2);
+	fw_info->last_total_isr_tick = result;
+	fw_info->last_total_tick = info->total_tick;
+	
+	dump_time_info(m, &info->cmd_send_info, "cmd send info");
+	seq_printf(m, "cmd id: %d\n", info->cmd_id);
+	
+	dump_time_info(m, &info->rx_notify, "rx_notify");
+	dump_time_info(m, &info->rx_begin, "rx_begin");
+	dump_time_info(m, &info->rx_end, "rx_end");
+	dump_time_info(m, &info->rx_interval, "rx_interval");
+	
+	seq_printf(m, "min lpw q: %d\n", info->lpw_rx_q_min);
+	
+	dump_time_info(m, &info->tx_done, "tx_done");
+	
+	dump_time_info(m, &info->scan_hang, "scan_hang");
+	
+	seq_printf(m, "wifi_int_disabled: %d\n", info->wifi_int_disabled);
+
+	seq_printf(m, "dump filter info: \n");
+	seq_printf(m, "\ttotal_pkt: %d\n", info->filter_info.total_pkt);
+	seq_printf(m, "\tprobe_req_pkt: %d\n", info->filter_info.probe_req_pkt);
+	seq_printf(m, "\tbcast_pkt: %d\n", info->filter_info.bcast_pkt);
+	seq_printf(m, "\tmcast_pkt: %d\n", info->filter_info.mcast_pkt);
+}
+
+static void* fw_info_seq_start(struct seq_file *s, loff_t *pos)
+{
+	static int read_finish = 0;
+	struct img_priv *priv;
+	struct fw_info_dump *fw_info = &wifi->fw_info;
+
+	pr_debug("%s: %d\n", __func__, read_finish);
+
+	if (read_finish == 1) {
+		read_finish = 0;
+		return NULL;// no more data to read, exit
+	}
+
+	if (!wifi->hw)
+		return NULL;
+
+	priv = (struct img_priv *)(wifi->hw->priv);
+	if (priv->state != STARTED) {
+		pr_err("Interface is not initialized\n");
+		return NULL;
+	}
+
+	if (fw_info->type == ADC_CAPTURE || fw_info->type == DUMP_ADC_CAPTURE_DATA) {
+		if (rpu_fw_priv_cmd_sync(DUMP_ADC_CAPTURE_DATA, NULL) != 0) {
+			pr_err("%s: send cmd failed\n", __func__);
+			return NULL;
+		}
+#define PRIV_CMD_DONE_EVENT_HEADER_SIZE (sizeof(struct host_rpu_msg_hdr) + sizeof(struct dump_info) - 1)
+		read_finish = (fw_info->offset<(128-PRIV_CMD_DONE_EVENT_HEADER_SIZE))?1:0;
+	} else {
+		if (!fw_info->finish)
+			return NULL;
+		read_finish = 1;
+	}
+	pr_debug("%s: read %d\n", __func__, fw_info->offset);
+
+	fw_info->finish = 0;
+
+
+	return (void*)fw_info;
+}
+
+static void dump_bytes(struct seq_file *s, struct fw_info_dump *info, int word)
+{
+	int i, j, line;
+	u8 *buf_byte = (u8 *)info->info;
+	u32 *buf_word = (u32 *)info->info;
+
+	if (word)
+		line = 4;
+	else
+		line = 16;
+
+	for (i = 0; i < round_up(info->offset, 16)/16; i++) {
+		for (j = 0; j < line; j++) {
+			if (word)
+				seq_printf(s, "%08x ", *buf_word++);
+			else
+				seq_printf(s, "%02x ", *buf_byte++);
+		}
+		seq_printf(s, "\n");
+	}
+	seq_printf(s, "\n");
+}
+
+#define RF_CAL_DATA_DIR		"/data"
+static void save_rf_cal_data(struct fw_info_dump *info)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0))
+	struct file *fp;
+	loff_t pos;
+    mm_segment_t fs;
+	u8 path[64];
+
+	sprintf(path, "%s/%s", RF_CAL_DATA_DIR, RF_CAL_DATA_FILE);
+	fp = filp_open(path, O_RDWR | O_CREAT, 0644);
+	if (fp == NULL || IS_ERR(fp)) {
+		pr_err("%s: create %s failed\n", __func__, path);
+		return;
+	}
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	pos = 0;
+	vfs_write(fp, info->info, info->offset, &pos);
+
+	filp_close(fp, NULL);
+#endif
+}
+
+static int fw_info_seq_show(struct seq_file *s, void *v)
+{
+	struct fw_info_dump *fw_info = (struct fw_info_dump*)v;
+
+	if (fw_info->type == DUMP_REG_INFO) {
+		int i;
+		unsigned int *buf = (unsigned int *)fw_info->info;
+
+		for (i = 0; i < fw_info->offset/4; i++) {
+			if ((i%4) == 0) {
+				seq_printf(s, "\n%08x: ", fw_info->reg);
+			}
+			seq_printf(s, "%08x ", *buf++);
+			fw_info->reg += 4;
+		}
+		seq_printf(s, "\n");
+	} else if (fw_info->type == DUMP_TXRX_COUNT_INFO) {
+		dump_txrx_count_info(s, fw_info);
+	} else if (fw_info->type == DUMP_IF_INFO) {
+		dump_if_info(s, (struct if_info *)fw_info->info);
+	} else if (fw_info->type == DUMP_ADC_CAPTURE_DATA) {
+		unsigned int len = fw_info->offset;
+		unsigned int *pt = (unsigned int *)fw_info->info;
+		while (len > 0) {
+			seq_printf(s, "%08x\n", *pt);
+			len -= 4;
+			pt++;
+		}
+	} else if (fw_info->type == DUMP_RF_CAL_DATA) {
+		dump_bytes(s, fw_info, 1);
+		save_rf_cal_data(fw_info);
+	} else {
+		seq_printf(s, "%s", (char*)fw_info->info);
+	}
+
+	return 0;
+}
+static void* fw_info_seq_next(struct seq_file *s, void *v, loff_t *pos){return NULL;}
+static void fw_info_seq_stop(struct seq_file *s, void *v){}
+
+static struct seq_operations fw_info_seq_ops = {
+	.start = fw_info_seq_start,
+	.next  = fw_info_seq_next,
+	.stop  = fw_info_seq_stop,
+	.show  = fw_info_seq_show
+};
+
+void rpu_reinit(void)
+{
+
+	if (wifi->hw)
+		rpu_exit();
+	rpu_init();
+	uccp_reinit = 1;
+}
+
+static int hex2num(char c)
+{
+        if (c >= '0' && c <= '9')
+                return c - '0';
+        if (c >= 'a' && c <= 'f')
+                return c - 'a' + 10;
+        if (c >= 'A' && c <= 'F')
+                return c - 'A' + 10;
+        return -1;
+}
+
+/**
+ * hwaddr_aton - Convert ASCII string to MAC address (colon-delimited format)
+ * @txt: MAC address as a string (e.g., "00:11:22:33:44:55")
+ * @addr: Buffer for the MAC address (ETH_ALEN = 6 bytes)
+ * Returns: 0 on success, -1 on failure (e.g., string not a MAC address)
+ */
+static int hwaddr_aton(const char *txt, unsigned char *addr)
+{
+        int i;
+
+        for (i = 0; i < 6; i++) {
+                int a, b;
+
+                a = hex2num(*txt++);
+                if (a < 0)
+                        return -1;
+                b = hex2num(*txt++);
+                if (b < 0)
+                        return -1;
+                *addr++ = (a << 4) | b;
+                if (i < 5 && *txt++ != ':')
+                        return -1;
+        }
+
+        return 0;
+}
+
+static ssize_t proc_write_config(struct file *file,
+				 const char __user *buffer,
+				 size_t count,
+				 loff_t *ppos)
+{
+	char buf[(RF_PARAMS_SIZE * 2) + 50];
+	unsigned long val = 0, val2 = 0;
+	long sval;
+	struct img_priv *priv;
+	int ret = 0;
+	static unsigned char bssid[6], mac_addr[6];
+
+	if (!wifi->hw)
+		return -ENODEV;
+
+	priv = (struct img_priv *)(wifi->hw->priv);
+
+	if (count >= sizeof(buf))
+		count = sizeof(buf) - 1;
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	buf[count] = '\0';
+
+	pr_info("%s: %s\n", __func__, buf);
+	if (0) {
+#ifdef HAL_PCIE
+	} else if(param_get_val(buf,"pci_mem_addr=",&val)) {
+		wifi->params.pci_base_addr=val;
+	} else if(param_get_val(buf,"no_words=",&val)){
+		wifi->params.no_words=val;
+		read_mem_region(wifi->params.pci_base_addr,
+				wifi->params.no_words);
+#endif
+	} else if (param_get_val(buf, "production_test=", &val)) {
+		if ((val == 0) || (val == 1)) {
+			if (wifi->params.production_test != val) {
+				if (wifi->params.production_test)
+					wifi->params.num_vifs = 1;
+
+				wifi->params.production_test = val;
+
+				//rpu_reinit();
+				//pr_err("Re-initializing UMAC ..\n");
+			}
+		} else
+			pr_err("Invalid parameter value\n");
+	} else if (param_get_val(buf, "bypass_vpd=", &val)) {
+		if ((val == 0) || (val == 1)) {
+			if (wifi->params.bypass_vpd != val)
+				wifi->params.bypass_vpd = val;
+		} else
+			pr_err("Invalid parameter value\n");
+	} else if (param_get_val(buf, "num_vifs=", &val)) {
+		if (val > 0 && val <= MAX_VIFS) {
+			if (wifi->params.num_vifs != val) {
+				rpu_reinit();
+				pr_err("Re-initializing UMAC ..\n");
+				wifi->params.num_vifs = val;
+			}
+		}
+	} else if (param_get_match(buf, "rf_params=")) {
+		conv_str_to_byte(wifi->params.rf_params,
+				strstr(buf, "=") + 1,
+				RF_PARAMS_SIZE);
+	} else if (param_get_val(buf, "rx_packet_mgmt_count=", &val)) {
+		wifi->stats.rx_packet_mgmt_count = val;
+	} else if (param_get_val(buf, "rx_packet_data_count=", &val)) {
+		wifi->stats.rx_packet_data_count = val;
+	} else if (param_get_val(buf, "pdout_val=", &val)) {
+		wifi->stats.pdout_val = val;
+	} else if (param_get_val(buf, "get_stats=", &val)) {
+		if (priv->state != STARTED) {
+			pr_err("Interface is not initialized\n");
+			goto error;
+		}
+		CALL_RPU(rpu_prog_mib_stats);
+	} else if (param_get_val2(buf, "read_fw_reg=", &val, &val2)) {
+		struct fw_reg_info reg;
+
+		reg.reg = val;
+		reg.len = val2==0 ? 4:val2;
+		reg.rw = READ_REG;
+		pr_info("read_fw_reg=0x%x,0x%x\n", reg.reg, reg.len);
+		CALL_RPU(rpu_fw_priv_cmd, DUMP_REG_INFO, (void *)&reg);
+	} else if (param_get_val2(buf, "read_lpw_reg=", &val, &val2)) {
+		struct fw_reg_info reg;
+
+		reg.reg = val;
+		reg.len = val2==0 ? 4:val2;
+		reg.rw = READ_REG_LPW;
+		pr_info("read_lpw_reg=0x%x,0x%x\n", reg.reg, reg.len);
+		CALL_RPU(rpu_fw_priv_cmd, DUMP_REG_INFO, (void *)&reg);		
+	} else if (param_get_val2(buf, "write_fw_reg=", &val, &val2)) {
+		struct fw_reg_info reg;
+	
+		reg.reg = val;
+		reg.val = val2;
+		reg.rw = WRITE_REG;
+		pr_info("write_fw_reg=0x%x,0x%x\n", reg.reg, reg.val);
+		CALL_RPU(rpu_fw_priv_cmd, DUMP_REG_INFO, &reg);
+	} else if (param_get_val2(buf, "write_lpw_reg=", &val, &val2)) {
+		struct fw_reg_info reg;
+	
+		reg.reg = val;
+		reg.val = val2;
+		reg.rw = WRITE_REG_LPW;
+		pr_info("write_fw_reg=0x%x,0x%x\n", reg.reg, reg.val);
+		CALL_RPU(rpu_fw_priv_cmd, DUMP_REG_INFO, &reg);
+	} else if (param_get_val(buf, "set_channel=", &val)) {
+		unsigned int pri_chnl_num = val;
+		unsigned int freq_band = IEEE80211_BAND_2GHZ;
+		int center_freq = ieee80211_channel_to_frequency(pri_chnl_num,
+					       freq_band);
+		pr_info("set channel: %d %d %d\n", pri_chnl_num, center_freq, freq_band);
+		CALL_RPU(rpu_prog_channel, pri_chnl_num, center_freq, 0, 0, freq_band);
+		pr_info("set channel success.\n");
+	} else if (strstr(buf, "fw_txrx_count_info")) {
+		if (priv->state != STARTED) {
+			pr_err("Interface is not initialized\n");
+			goto error;
+		}
+		CALL_RPU(rpu_fw_priv_cmd, DUMP_TXRX_COUNT_INFO, NULL);
+	} else if (strstr(buf, "adc_capture")) {
+		if (priv->state != STARTED) {
+			pr_err("Interface is not initialized\n");
+			goto error;
+		}
+		CALL_RPU(rpu_fw_priv_cmd, ADC_CAPTURE, NULL);
+	} else if (strstr(buf, "fw_txrx_queue_info")) {
+		if (priv->state != STARTED) {
+			pr_err("Interface is not initialized\n");
+			goto error;
+		}
+		CALL_RPU(rpu_fw_priv_cmd, DUMP_TXRX_QUEUE_INFO, NULL);
+	} else if (strstr(buf, "fw_version_info")) {
+		if (priv->state != STARTED) {
+			pr_err("Interface is not initialized\n");
+			goto error;
+		}
+		CALL_RPU(rpu_fw_priv_cmd, DUMP_FW_VERSION, NULL);
+	} else if (strstr(buf, "fw_enable_ejtag")) {
+		/*if (priv->state != STARTED) {
+			pr_err("Interface is not initialized\n");
+			goto error;
+		}*/
+		rk915_ejtag(hpriv);
+		CALL_RPU(rpu_fw_priv_cmd, ENABLE_EJTAG, NULL);
+	} else if (strstr(buf, "fw_if_info")) {
+		if (priv->state != STARTED) {
+			pr_err("Interface is not initialized\n");
+			goto error;
+		}
+		CALL_RPU(rpu_fw_priv_cmd, DUMP_IF_INFO, NULL);
+	} else if (strstr(buf, "rf_cal_data")) {
+		CALL_RPU(rpu_fw_priv_cmd, DUMP_RF_CAL_DATA, NULL);
+	} else if (param_get_val(buf, "sniffer=", &val)) {
+		/*
+		 * Value = 0 --> normal operation 
+		 * Value > 0 --> sniffer operation 
+		 * Value = 1 --> receive all data and managment frames - both unicast and broadcast 
+		 * Value = 2 --> receive broadcast data frames only 
+		 * Value = 3 --> receive broadcast and unciast data only 
+		 */
+		if (priv->state != STARTED) {
+			pr_err("Interface is not initialized\n");
+			goto error;
+		}
+		priv->sniffer = val;
+		CALL_RPU(rpu_fw_priv_cmd, ENABLE_SNIFFER, (void *)&val);
+		CALL_RPU(rpu_prog_cfgmisc, priv->sniffer);
+	} else if (param_get_val(buf, "max_data_size=", &val)) {
+		if (wifi->params.max_data_size != val) {
+			if ((wifi->params.max_data_size >= 2 * 1024) &&
+			    (wifi->params.max_data_size <= (12 * 1024))) {
+				wifi->params.max_data_size = val;
+
+				rpu_reinit();
+				pr_err("Re-initalizing RPU with %ld as max data size\n",
+				       val);
+
+			} else
+				pr_err("Invalid Value for max data size: should be (2K-12K)\n");
+		}
+	} else if (param_get_val(buf, "max_tx_cmds=", &val)) {
+		int max_tx_cmd_limit = MAX_SUBFRAMES_IN_AMPDU_HT;
+
+		if (val >= 1 && val <= max_tx_cmd_limit)
+			wifi->params.max_tx_cmds = val;
+		else
+			pr_err("Please enter value between 1 and %d\n",
+			       max_tx_cmd_limit);
+	} else if (param_get_val(buf, "disable_power_save=", &val)) {
+		if ((val == 0) || (val == 1)) {
+			if (val != wifi->params.disable_power_save) {
+				wifi->params.disable_power_save = val;
+
+				rpu_reinit();
+				pr_err("Re-initalizing RPU with global powerave %s\n",
+				       val ? "DISABLED" : "ENABLED");
+			}
+		}
+	} else if (param_get_val(buf, "disable_sm_power_save=", &val)) {
+		if ((val == 0) || (val == 1)) {
+			if (val != wifi->params.disable_sm_power_save) {
+				wifi->params.disable_sm_power_save = val;
+
+				rpu_reinit();
+				pr_err("Re-initalizing RPU with smps %s\n",
+				       val ? "DISABLED" : "ENABLED");
+
+			}
+		}
+	} else if (param_get_val(buf, "uccp_num_spatial_streams=", &val)) {
+		if (val > 0 && val <= min(MAX_TX_STREAMS, MAX_RX_STREAMS)) {
+			if (val != wifi->params.uccp_num_spatial_streams) {
+				wifi->params.uccp_num_spatial_streams = val;
+				wifi->params.num_spatial_streams = val;
+				wifi->params.max_tx_streams = val;
+				wifi->params.max_rx_streams = val;
+				rpu_reinit();
+				pr_err("Re-initalizing RPU with %ld spatial streams\n",
+				       val);
+			}
+		} else
+			pr_err("Invalid parameter value: Allowed Range: 1 to %d\n",
+			       min(MAX_TX_STREAMS, MAX_RX_STREAMS));
+	} else if (param_get_val(buf, "enable_early_agg_checks=", &val)) {
+		if ((val == 0) || (val == 1)) {
+			if (val != wifi->params.enable_early_agg_checks)
+				wifi->params.enable_early_agg_checks = val;
+		} else
+			pr_err("Invalid parameter value: Allowed: 0/1\n");
+	} else if (param_get_val(buf, "antenna_sel=", &val)) {
+		if (val == 1 || val == 2) {
+			if (val != wifi->params.antenna_sel) {
+				wifi->params.antenna_sel = val;
+				rpu_reinit();
+				pr_err("Re-initalizing RPU with %ld antenna selection\n",
+				       val);
+			}
+		} else
+			pr_err("Invalid parameter value: Allowed Values: 1 or 2\n");
+	} else if (param_get_val(buf, "num_spatial_streams=", &val)) {
+		if (val > 0 && val <= wifi->params.uccp_num_spatial_streams)
+			wifi->params.num_spatial_streams = val;
+		else
+			pr_err("Invalid parameter value, should be less than or equal to uccp_num_spatial_streams\n");
+	} else if (param_get_sval(buf, "mgd_mode_tx_fixed_mcs_indx=", &sval)) {
+		if (wifi->params.mgd_mode_tx_fixed_rate == -1) {
+			if (check_valid_data_rate(priv, sval | 0x80, UCAST))
+				wifi->params.mgd_mode_tx_fixed_mcs_indx = sval;
+		} else
+			pr_err("Fixed rate other than MCS index is currently set\n");
+	} else if (param_get_sval(buf, "mgd_mode_tx_fixed_rate=", &sval)) {
+		if (wifi->params.mgd_mode_tx_fixed_mcs_indx == -1) {
+			if (check_valid_data_rate(priv, sval, UCAST))
+				wifi->params.mgd_mode_tx_fixed_rate = sval;
+		} else
+			pr_err("MCS data rate(index) is currently set\n");
+	/* Multicast Rate configuration options.
+	 */
+	} else if (param_get_sval(buf, "mgd_mode_mcast_fixed_data_rate=",
+		   &sval)) {
+		if (check_valid_data_rate(priv, sval, MCAST))
+			wifi->params.mgd_mode_mcast_fixed_data_rate = sval;
+	} else if (param_get_val(buf, "mgd_mode_mcast_fixed_rate_flags=",
+		   &val)) {
+		if (check_valid_rate_flags(priv, val))
+			wifi->params.mgd_mode_mcast_fixed_rate_flags = val;
+	} else if (param_get_val(buf, "mgd_mode_mcast_fixed_bcc_or_ldpc=",
+		   &val)) {
+		wifi->params.mgd_mode_mcast_fixed_bcc_or_ldpc = val;
+	} else if (param_get_val(buf, "mgd_mode_mcast_fixed_stbc_enabled=",
+		   &val)) {
+		wifi->params.mgd_mode_mcast_fixed_stbc_enabled = val;
+	} else if (param_get_val(buf, "mgd_mode_mcast_fixed_preamble=",
+		   &val)) {
+		wifi->params.mgd_mode_mcast_fixed_preamble = val;
+	} else if (param_get_val(buf, "mgd_mode_mcast_fixed_nss=", &val)) {
+		wifi->params.mgd_mode_mcast_fixed_nss = val;
+
+	/* Production mode rate configuration
+	 */
+	} else if (param_get_sval(buf, "tx_fixed_mcs_indx=", &sval)) {
+		if (wifi->params.production_test != 1) {
+			pr_err("Only can be set in production mode.\n");
+			goto error;
+		}
+
+		if (sval == -1) {
+			wifi->params.tx_fixed_mcs_indx = -1;
+			goto error;
+		}
+
+		if (wifi->params.tx_fixed_rate != -1) {
+			pr_err("Fixed rate other than MCS index is currently set\n");
+			goto error;
+		}
+
+		if (check_valid_data_rate(priv, sval | 0x80, UCAST))
+			wifi->params.tx_fixed_mcs_indx = sval;
+
+
+	} else if (param_get_sval(buf, "tx_fixed_rate=", &sval)) {
+		if (wifi->params.production_test != 1) {
+			pr_err("Only can be set in production mode.\n");
+			goto error;
+		}
+
+		if (sval == -1) {
+			wifi->params.tx_fixed_rate = -1;
+			goto error;
+		}
+		if (wifi->params.tx_fixed_mcs_indx != -1) {
+			pr_err("MCS Index is currently set.\n");
+			goto error;
+		}
+
+		if (check_valid_data_rate(priv, sval, UCAST))
+			wifi->params.tx_fixed_rate = sval;
+
+	} else if (param_get_val(buf, "chnl_bw=", &val)) {
+		if (((val == 0) ||
+		     (val == 1))) {
+			wifi->params.chnl_bw = val;
+
+			rpu_reinit();
+			pr_err("Re-initializing UMAC ..\n");
+		} else
+			pr_err("Invalid parameter value.\n");
+	} else if (param_get_val(buf, "prod_mode_chnl_bw_40_mhz=", &val)) {
+
+		do {
+			if (wifi->params.production_test != 1) {
+				pr_err("Can be set in only in production mode.\n");
+				break;
+			}
+
+			if (!((val == 0) || (val == 1))) {
+				pr_err("Invalid parameter value.\n");
+				break;
+			}
+
+			wifi->params.prod_mode_chnl_bw_40_mhz = val;
+
+
+		} while (0);
+	} else if (param_get_val(buf, "prod_mode_rate_flag=", &val)) {
+		if (check_valid_rate_flags(priv, val))
+			wifi->params.prod_mode_rate_flag = val;
+	} else if (param_get_val(buf, "rate_protection_type=", &val)) {
+		/* 0 is None, 1 is RTS/CTS, 2 is for CTS2SELF */
+		if ((val == 0) || (val == 1) /*|| (val == 2)*/)
+			wifi->params.rate_protection_type = val;
+		else
+			pr_err("Invalid parameter value");
+	} else if (param_get_val(buf, "prod_mode_rate_preamble_type=", &val)) {
+		/*0 is short, 1 is Long*/
+		if ((val == 0) || (val == 1))
+			wifi->params.prod_mode_rate_preamble_type = val;
+		else
+			pr_err("Invalid parameter value");
+	} else if (param_get_val(buf, "prod_mode_stbc_enabled=", &val)) {
+		if (val <= 1)
+			wifi->params.prod_mode_stbc_enabled = val;
+		else
+			pr_err("Invalid parameter value\n");
+	} else if (param_get_val(buf, "prod_mode_bcc_or_ldpc=", &val)) {
+		if (val <= 1)
+			wifi->params.prod_mode_bcc_or_ldpc = val;
+		else
+			pr_err("Invalid parameter value\n");
+	} else if (param_get_val(buf, "reset_hal_params=", &val)) {
+		if (priv->state != STARTED) {
+			if (val != 1)
+				pr_err("Invalid parameter value\n");
+			else
+				hal_ops.reset_hal_params();
+		} else
+			pr_err("HAL parameters reset can be done only when all interface are down\n");
+	} else if (param_get_val(buf, "scan_type=", &val)) {
+		if ((val == 0) || (val == 1))
+			wifi->params.scan_type = val;
+		else
+			pr_err("Invalid scan type value %d, should be 0 or 1\n",
+			       (unsigned int)val);
+	} else if (param_get_val(buf, "start_prod_mode=", &val)) {
+		start_prod_mode(priv, val);
+	} else if (param_get_sval(buf, "stop_prod_mode=", &sval)) {
+		stop_prod_mode(priv, sval);
+	} else if (strstr(buf, "set_rx_bssid=")) {
+		hwaddr_aton(strstr(buf, "=") + 1, bssid);
+		pr_info("bssid = %pM\n", bssid);
+	} else if (strstr(buf, "set_rx_mac_addr=")) {
+		hwaddr_aton(strstr(buf, "=") + 1, mac_addr);
+		pr_info("mac_addr = %pM\n", mac_addr);
+	} else if (param_get_val(buf, "fw_skip_rx_pkt_submit=", &val)) {
+		wifi->params.fw_skip_rx_pkt_submit = val;
+	} else if (param_get_val(buf, "start_prod_rx_mode=", &val)) {
+		start_prod_rx_mode(priv, val, bssid, mac_addr);
+	} else if (param_get_val(buf, "start_prod_cw_mode=", &val)) {
+		start_prod_rx_mode(priv, val|0x80, bssid, mac_addr);
+	} else if (param_get_val(buf, "start_prod_echo_mode=", &val)) {
+		start_prod_echo_mode(priv, val);
+	} else if (param_get_sval(buf, "start_packet_gen=", &sval)) {
+		start_packet_gen(priv, sval);
+	} else if (param_get_sval(buf, "stop_packet_gen=", &sval)) {
+		stop_packet_gen(priv, sval);
+	} else if (param_get_val(buf, "payload_length=", &val)) {
+#ifdef PKTGEN_MULTI_TX
+		if (val > 2317)
+		    val = 2317;
+		pr_info("payload_length = %d\n", (int)val);
+#endif
+		wifi->params.payload_length = val;
+	} else if (param_get_sval(buf, "set_tx_power=", &sval)) {
+		if (wifi->params.production_test != 1 && !ftm) {
+			pr_err("set_tx_power: Can be set in only in FTM/production mode.\n");
+			goto error;
+		}
+
+		if (!wifi->params.init_prod) {
+			pr_err("NEW Production Mode is not Initialized\n");
+			goto error;
+		}
+
+		memset(wifi->params.pdout_voltage, 0,
+		       sizeof(char) * MAX_AUX_ADC_SAMPLES);
+		wifi->params.set_tx_power = sval;
+		CALL_RPU(rpu_prog_txpower, sval);
+ 	} else if (param_get_val(buf, "fw_loaded=", &val)) {
+ 		wifi->params.fw_loaded = val;
+	} else if (param_get_val(buf, "disable_beacon_ibss=", &val)) {
+		if ((val == 1) || (val == 0))
+			wifi->params.disable_beacon_ibss = val;
+		else
+			pr_err("Invalid driver_tput value should be 1 or 0\n");
+	} else if (param_get_val(buf, "rpu_debug=", &val)) {
+		rpu_debug = val;
+	} else if (param_get_val(buf, "rpu_debug_level=", &val)) {
+		rpu_debug_level = val;
+#ifdef RPU_SLEEP_ENABLE
+	} else if (param_get_val(buf, "sleep=", &val)) {
+			hal_ops.trigger_timed_sleep(val);
+	} else if (param_get_val(buf, "wakeup=", &val)) {
+			hal_ops.trigger_wakeup(val);
+	} else if (param_get_val(buf, "ps=", &val)) {
+		trigger_wifi_power_save(val);
+	} else if (param_get_val(buf, "scan_abort=", &val)) {
+		trigger_wifi_scan_abort(val);
+	} else if (param_get_val(buf, "rpu_sleep_type=", &val)) {
+		wifi->params.rpu_sleep_type = val;
+#endif
+#ifdef ENABLE_DAPT
+	} else if (param_get_val(buf, "dapt_thresh_offset=", &val)) {
+		wifi->params.dapt_thresh_offset = val;
+	} else if (param_get_val(buf, "dapt_thresh_exponent=", &val)) {
+		wifi->params.dapt_thresh_exponent = val;
+	} else if (param_get_val(buf, "dapt_thresh_min=", &val)) {
+		wifi->params.dapt_thresh_min = val;
+	} else if (param_get_val(buf, "dapt_thresh_max=", &val)) {
+		wifi->params.dapt_thresh_max = val;
+	} else if (param_get_val(buf, "dapt_disable=", &val)) {
+		dapt_disable(priv, val);
+#endif		
+	} else if (param_get_val(buf, "dapt_set_phy_thresh=", &val)) {
+		int c;
+		unsigned int thresh[14]; 
+
+		//dapt_set_phy_thresh(priv, val);
+		for (c = 0; c < 14; c++)
+			thresh[c] = val;
+		rpu_prog_phy_thresh(thresh);
+	} else if (param_get_val(buf, "prog_channel=", &val)) {
+		int freq = ieee80211_channel_to_frequency(val, IEEE80211_BAND_2GHZ);
+
+		rpu_prog_channel(val, freq, 0, 1, 0);
+	} else if (param_get_val(buf, "dtim=", &val)) {
+		wifi->params.min_dtim_peroid = val;
+	} else if (param_get_val2(buf, "mem_read=", &val, &val2)) {
+		pr_info("mem_read=0x%x,0x%x\n", (unsigned int)val, (unsigned int)val2);
+		rk915_mem_check2(hpriv, val, val2);
+	} else if (param_get_val(buf, "disconnect=", &val)) {
+		struct ieee80211_vif *vif = NULL;
+		int i = 0;
+
+		if (val == 1) {
+			for (i = 0; i < MAX_VIFS; i++) {
+				if (!(priv->active_vifs & (1 << i)))
+					continue;
+
+				vif = rcu_dereference(priv->vifs[i]);
+
+				if (ether_addr_equal(vif->addr,
+						     vif_macs[0])) {
+					ieee80211_connection_loss(vif);
+					break;
+				}
+			}
+		}
+	} else
+		pr_err("Invalid parameter name: %s\n", buf);
+error:
+	return count;
+prog_rpu_fail:
+	return ret;
+}
+
+
+static int proc_open_config(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_config, NULL);
+}
+
+
+static int proc_open_phy_stats(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_phy_stats, NULL);
+}
+
+static int proc_open_mac_stats(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_mac_stats, NULL);
+}
+
+static int proc_open_fw_info(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &fw_info_seq_ops);
+}
+
+static int proc_open_fw_log(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &fw_log_seq_ops);
+}
+
+static int proc_read_fw_params(struct seq_file *m, void *v)
+{
+	struct fw_info_dump *fw_info = &wifi->fw_info;
+	struct fw_params *params;
+	struct img_priv *priv;
+
+	priv = (struct img_priv *)(wifi->hw->priv);
+	if (priv->state != STARTED) {
+		pr_err("Interface is not initialized\n");
+		goto exit;
+	}
+
+	if (rpu_fw_priv_cmd_sync(FW_GET_PARAMS, NULL) != 0) {
+		goto exit;
+	}
+
+	params = (struct fw_params*)fw_info->info;
+	seq_printf(m, "firmware params:\n"
+				 "\techo_mode=%d\n"
+				 "\tejtag_mode=%d\n"
+				 "\tdebug_level=%d\n"
+				 "\tdebug_flag=0x%x\n"
+				 "\tdis_wifi_isr_thd=%d\n"
+				 "\ten_wifi_isr_thd=%d\n",
+				 params->echo_mode,
+				 params->ejtag_mode,
+				 params->debug_level,
+				 params->debug_flag,
+				 params->dis_wifi_isr_thd,
+				 params->en_wifi_isr_thd);
+
+	seq_printf(m, "\nfirmware command:\n"
+				"\tread_fw_reg=0xb000c800,0x4\n"
+				"\twrite_fw_reg=0xb000c800,0x80000000\n"
+				"\tfw_txrx_count_info\n"
+				"\tfw_txrx_queue_info\n"
+				"\tfw_version_info\n"
+				"\tfw_enable_ejtag\n");
+	seq_printf(m, "\tdebug_level=n, n is: 0(close) 1(err) 2(info) 3(debug)\n"
+			"\tdebug_flag=n, n is: 1(rx) 2(tx) 4(sdio) 8(memory)\n"
+			"\techo_mode=n, n is: 0(disable) 1(enable)\n"
+			"\tejtag_mode=n, n is: 0(disable) 1(enable), not available now\n"
+			"\tdump_mem_info, dump firmware memory information.\n"
+			);
+
+exit:
+	fw_info->finish = 0;
+	return 0;
+}
+
+static ssize_t proc_write_fw_params(struct file *file,
+				 const char __user *buffer,
+				 size_t count,
+				 loff_t *ppos)
+{
+	char buf[128];
+	unsigned long val = 0;
+	struct img_priv *priv;
+	int ret = 0;
+	struct fw_params params;
+	int cmd = 0;
+
+	if (!wifi->hw)
+		return -ENODEV;
+
+	priv = (struct img_priv *)(wifi->hw->priv);
+
+	if (priv->state != STARTED) {
+		pr_err("Interface is not initialized\n");
+		return count;
+	}
+
+	if (count >= sizeof(buf))
+		count = sizeof(buf) - 1;
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	memset(&params, 0, sizeof(struct fw_params));
+	buf[count] = '\0';
+
+	pr_info("%s: %s\n", __func__, buf);
+
+	memset(&params, 0, sizeof(struct fw_params));
+	if(param_get_val(buf,"echo_mode=", &val)) {
+		params.mask |= 1<<PARAM_ECHO_MODE;
+		params.echo_mode=val;
+	} else if(param_get_val(buf,"ejtag_mode=", &val)){
+		params.mask |= 1<<PARAM_EJTAG_MODE;
+		params.ejtag_mode=val;
+	} else if(param_get_val(buf,"debug_level=", &val)){
+		params.mask |= 1<<PARAM_DEBUG_LEVEL;
+		params.debug_level=val;
+	} else if(param_get_val(buf,"debug_flag=", &val)){
+		params.mask |= 1<<PARAM_DEBUG_FLAG;
+		params.debug_flag=val;
+	} else if(param_get_val(buf,"dis_wifi_isr_thd=", &val)){
+		params.mask |= 1<<PARAM_DIS_WIFI_ISR_THD;
+		params.dis_wifi_isr_thd=val;
+	} else if(param_get_val(buf,"en_wifi_isr_thd=", &val)){
+		params.mask |= 1<<PARAM_EN_WIFI_ISR_THD;
+		params.en_wifi_isr_thd=val;
+	} else if (strstr(buf, "dump_mem_info")) {
+		cmd = DUMP_MEM_INFO;
+	} else
+		pr_err("Invalid parameter name: %s\n", buf);
+
+	if (params.mask)
+		ret = rpu_fw_priv_cmd_sync(FW_SET_PARAMS, &params);
+	else
+		ret = rpu_fw_priv_cmd(cmd, NULL);
+
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static int proc_open_fw_params(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_fw_params, NULL);
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
+static const struct proc_ops params_fops_config = {
+	.proc_open = proc_open_config,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_write = proc_write_config,
+	.proc_release = single_release
+};
+#else
+static const struct file_operations params_fops_config = {
+	.open = proc_open_config,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = proc_write_config,
+	.release = single_release
+};
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
+static const struct proc_ops params_fops_phy_stats = {
+    .proc_open = proc_open_phy_stats,
+    .proc_read = seq_read,
+    .proc_lseek = seq_lseek,
+    .proc_write = NULL,
+    .proc_release = single_release
+};
+#else
+static const struct file_operations params_fops_phy_stats = {
+	.open = proc_open_phy_stats,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = NULL,
+	.release = single_release
+};
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
+static const struct proc_ops params_fops_mac_stats = {
+    .proc_open = proc_open_mac_stats,
+    .proc_read = seq_read,
+    .proc_lseek = seq_lseek,
+    .proc_write = NULL,
+    .proc_release = single_release
+};
+#else
+static const struct file_operations params_fops_mac_stats = {
+	.open = proc_open_mac_stats,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = NULL,
+	.release = single_release
+};
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
+static const struct proc_ops params_fops_fw_info = {
+    .proc_open = proc_open_fw_info,
+    .proc_read = seq_read,
+    .proc_lseek = seq_lseek,
+    .proc_write = NULL,
+    .proc_release = seq_release
+};
+#else
+static const struct file_operations params_fops_fw_info = {
+	.open = proc_open_fw_info,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = NULL,
+	.release = seq_release
+};
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
+static const struct proc_ops params_fops_fw_log = {
+    .proc_open = proc_open_fw_log,
+    .proc_read = seq_read,
+    .proc_lseek = seq_lseek,
+    .proc_write = NULL,
+    .proc_release = seq_release
+};
+#else
+static const struct file_operations params_fops_fw_log = {
+	.open = proc_open_fw_log,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = NULL,
+	.release = seq_release
+};
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
+static const struct proc_ops params_fops_fw_params = {
+    .proc_open = proc_open_fw_params,
+    .proc_read = seq_read,
+    .proc_lseek = seq_lseek,
+    .proc_write = proc_write_fw_params,
+    .proc_release = single_release
+};
+#else
+static const struct file_operations params_fops_fw_params = {
+	.open = proc_open_fw_params,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = proc_write_fw_params,
+	.release = single_release
+};
+#endif
+
+static void set_default_phy_thresh(unsigned char *rf_params, int len)
+{
+	int i;
+	unsigned char def[3];
+
+	sprintf(def, "%02x", default_phy_threshold);
+
+	for (i = 0; i < 14; i++) {
+		strncpy(&rf_params[(len - i)*2 - 2], def, 2);
+	}
+}
+
+void set_rf_params(unsigned char *rf_params)
+{
+	set_default_phy_thresh(rf_params, 94);
+
+	/* TODO: Make this a struct */
+	memset(wifi->params.rf_params, 0xFF, sizeof(wifi->params.rf_params));
+	conv_str_to_byte(wifi->params.rf_params, rf_params, RF_PARAMS_SIZE);
+
+	memcpy(wifi->params.rf_params_vpd, wifi->params.rf_params, RF_PARAMS_SIZE);
+}
+
+int proc_init(struct proc_dir_entry ***main_dir_entry)
+{
+	struct proc_dir_entry *entry;
+	int err = 0;
+	unsigned int i = 0;
+	/*2.4GHz and 5 GHz PD and TX-PWR calibration params*/
+	unsigned char rf_params[RF_PARAMS_SIZE * 2];
+
+	//strncpy(rf_params,
+	//	"1E00000000002426292A2C2E3237393F454A52576066000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F00000000002426292A2C2E3237393F454A52576066000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F0808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808",
+	//	(RF_PARAMS_SIZE * 2));
+	
+	//From above check PHY Start Thresholds in the last 14 bytes (corerspond to all 14 channels). Each value specifies the threshold in half-dBm units without the negative sign.
+	//The default is 0xB4 = 180, which represents -90 dBm.
+	//strncpy(rf_params,"00204000240210020403040404050406040704080409040A040B040C040CF80C0C04FEF8F0E80000000000000000000000000000040403030201000001020303040405050505050505050505050505058C8C8C8C8C8C8C8C8C8C8C8C8C8C",
+	//	(94 * 2));
+	//strncpy(rf_params,"00204000240210020403040404050406040704080409040A040B040C040CF80b0C04FEF8ECEC0000000000000000000000000000000000000000000000000000000008080808080808080808080808088C8C8C8C8C8C8C8C8C8C8C8C8C8C",
+	//	(94 * 2));
+        strncpy(rf_params,"00204000240210020403040404050406040704080409040A040B040C040CF80B0C04FFFAF2EC0000000000000000000000000000000000000000000000000000000008080808080808080808080808088C8C8C8C8C8C8C8C8C8C8C8C8C8C",
+                (94 * 2)); 
+	set_default_phy_thresh(rf_params, 94);
+
+	wifi = kzalloc(sizeof(struct wifi_dev), GFP_KERNEL);
+	if (!wifi) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	wifi->umac_proc_dir_entry = proc_mkdir("rk915", init_net.proc_net);
+	if (!wifi->umac_proc_dir_entry) {
+		pr_err("Failed to create proc dir\n");
+		err = -ENOMEM;
+		goto  proc_dir_fail;
+	}
+
+	entry = proc_create("params", 0644, wifi->umac_proc_dir_entry,
+			    &params_fops_config);
+	if (!entry) {
+		pr_err("Failed to create proc entry\n");
+		err = -ENOMEM;
+		goto  proc_entry1_fail;
+	}
+
+	entry = proc_create("phy_stats", 0444, wifi->umac_proc_dir_entry,
+			    &params_fops_phy_stats);
+	if (!entry) {
+		pr_err("Failed to create proc entry\n");
+		err = -ENOMEM;
+		goto  proc_entry2_fail;
+	}
+
+	entry = proc_create("mac_stats", 0444, wifi->umac_proc_dir_entry,
+			    &params_fops_mac_stats);
+	if (!entry) {
+		pr_err("Failed to create proc entry\n");
+		err = -ENOMEM;
+		goto  proc_entry3_fail;
+	}
+#ifdef RPU_SLEEP_ENABLE
+	entry = proc_create("sleep_stats", 0444, wifi->umac_proc_dir_entry,
+			    &params_fops_sleep_stats);
+	if (!entry) {
+		pr_err("Failed to create proc entry\n");
+		err = -ENOMEM;
+		goto  proc_entry4_fail;
+	}
+#endif
+
+	entry = proc_create("fw_info", 0444, wifi->umac_proc_dir_entry,
+			    &params_fops_fw_info);
+	if (!entry) {
+		pr_err("Failed to create proc entry\n");
+		err = -ENOMEM;
+		goto  proc_entry5_fail;
+	}
+
+	entry = proc_create("fw_log", 0444, wifi->umac_proc_dir_entry,
+			    &params_fops_fw_log);
+	if (!entry) {
+		pr_err("Failed to create proc entry\n");
+		err = -ENOMEM;
+		goto  proc_entry6_fail;
+	}
+
+	entry = proc_create("fw_params", 0644, wifi->umac_proc_dir_entry,
+			    &params_fops_fw_params);
+	if (!entry) {
+		pr_err("Failed to create proc entry\n");
+		err = -ENOMEM;
+		goto  proc_entry7_fail;
+	}
+
+	/* Initialize WLAN params */
+	memset(&wifi->params, 0, sizeof(struct wifi_params));
+
+	/* TODO: Make this a struct */
+	memset(wifi->params.rf_params, 0xFF, sizeof(wifi->params.rf_params));
+	conv_str_to_byte(wifi->params.rf_params, rf_params, RF_PARAMS_SIZE);
+
+	if (!rf_params_vpd)
+		rf_params_vpd = wifi->params.rf_params;
+
+	memcpy(wifi->params.rf_params_vpd, rf_params_vpd, RF_PARAMS_SIZE);
+
+	wifi->params.is_associated = 0;
+	wifi->params.ed_sensitivity = -89;
+	wifi->params.auto_sensitivity = 1;
+	wifi->params.dot11a_support = 0;
+	wifi->params.dot11g_support = 1;
+	wifi->params.num_vifs = 2;
+
+	/* Check, if required add it */
+	wifi->params.tx_fixed_mcs_indx = -1;
+	wifi->params.tx_fixed_rate = -1;
+	wifi->params.num_spatial_streams = min(MAX_TX_STREAMS, MAX_RX_STREAMS);
+	wifi->params.uccp_num_spatial_streams = min(MAX_TX_STREAMS,
+						    MAX_RX_STREAMS);
+	wifi->params.antenna_sel = 1;
+
+	if (num_streams_vpd > 0)
+		wifi->params.uccp_num_spatial_streams = num_streams_vpd;
+
+	wifi->params.enable_early_agg_checks = 1;
+	wifi->params.bt_state = 1;
+
+	/* Defaults optimized for all clients
+	 */
+	wifi->params.mgd_mode_tx_fixed_mcs_indx = -1;
+	wifi->params.mgd_mode_mcast_fixed_data_rate = -1;
+	wifi->params.mgd_mode_tx_fixed_rate = -1;
+	wifi->params.mgd_mode_mcast_fixed_nss = 1;
+	wifi->params.mgd_mode_mcast_fixed_bcc_or_ldpc = 1;
+	wifi->params.mgd_mode_mcast_fixed_stbc_enabled = 1;
+	wifi->params.chnl_bw = WLAN_20MHZ_OPERATION;
+
+	wifi->params.max_tx_streams = MAX_TX_STREAMS;
+	wifi->params.max_rx_streams = MAX_RX_STREAMS;
+	wifi->params.max_data_size  = 8 * 1024;
+
+	wifi->params.max_tx_cmds = MAX_SUBFRAMES_IN_AMPDU_HT;
+	wifi->params.disable_power_save = 0;
+	wifi->params.disable_sm_power_save = 0;
+	wifi->params.rate_protection_type = 0; 
+	wifi->params.prod_mode_rate_preamble_type = 1; /* LONG */
+	wifi->params.prod_mode_stbc_enabled = 0;
+	wifi->params.prod_mode_bcc_or_ldpc = 0;
+	wifi->params.bg_scan_enable = 0;
+	memset(wifi->params.bg_scan_channel_list, 0, 50);
+	memset(wifi->params.bg_scan_channel_flags, 0, 50);
+
+	if (wifi->params.dot11g_support) {
+		wifi->params.bg_scan_num_channels = 3;
+
+		wifi->params.bg_scan_channel_list[i] = 1;
+		wifi->params.bg_scan_channel_flags[i++] = ACTIVE;
+
+		wifi->params.bg_scan_channel_list[i] = 6;
+		wifi->params.bg_scan_channel_flags[i++] = ACTIVE;
+
+		wifi->params.bg_scan_channel_list[i] = 11;
+		wifi->params.bg_scan_channel_flags[i++] = ACTIVE;
+	}
+
+	wifi->params.disable_beacon_ibss = 0;
+	wifi->params.pkt_gen_val = -1;
+	wifi->params.init_pkt_gen = 0;
+	wifi->params.payload_length = 4000;
+	wifi->params.start_prod_mode = 0;
+	wifi->params.fw_skip_rx_pkt_submit = 0;
+	wifi->params.init_prod = 0;
+	wifi->params.bg_scan_intval = 5000 * 1000; /* Once in 5 seconds */
+	wifi->params.bg_scan_chan_dur = 300; /* Channel spending time */
+	wifi->params.bg_scan_serv_chan_dur = 100; /* Oper chan spending time */
+	wifi->params.nw_selection = 0;
+	wifi->params.scan_type = ACTIVE;
+	wifi->params.hw_scan_status = HW_SCAN_STATUS_NONE;
+	wifi->params.fw_loaded = 0;
+#ifdef RPU_SLEEP_ENABLE
+#ifdef RPU_NO_SLEEP_FLAG
+	wifi->params.rpu_sleep_type = LMAC_NO_SLEEP;
+#else
+	/* Default RPU Sleep is enabled
+	 */
+	if (lpw_no_sleep)
+		wifi->params.rpu_sleep_type = LMAC_NO_SLEEP;
+	else
+		wifi->params.rpu_sleep_type = 0;
+#endif
+#endif
+
+#ifdef ENABLE_DAPT
+	wifi->params.dapt_thresh_offset = DAPT_THRESH_OFFSET;
+	wifi->params.dapt_thresh_exponent = DAPT_THRESH_EXPONENT;
+	wifi->params.dapt_thresh_min = DAPT_PHY_THRESH_MIN;
+	wifi->params.dapt_thresh_max = DAPT_PHY_THRESH_MAX;
+#endif
+
+	wifi->params.min_dtim_peroid = 4;
+
+	memset(&wifi->fw_info, 0, sizeof(struct fw_info_dump));
+	wifi->fw_info.info = kzalloc(MAX_FW_INFO_SIZE, GFP_KERNEL);
+	if (!wifi->fw_info.info) {
+		err = -ENOMEM;
+		goto proc_entry8_fail;
+	}
+	wifi->fw_info.len = MAX_FW_INFO_SIZE;
+	wifi->fw_info.offset = 0;
+
+	**main_dir_entry = wifi->umac_proc_dir_entry;
+	return err;
+proc_entry8_fail:
+	remove_proc_entry("fw_params", wifi->umac_proc_dir_entry);
+proc_entry7_fail:
+	remove_proc_entry("fw_log", wifi->umac_proc_dir_entry);
+proc_entry6_fail:
+	remove_proc_entry("fw_info", wifi->umac_proc_dir_entry);
+proc_entry5_fail:
+	remove_proc_entry("sleep_stats", wifi->umac_proc_dir_entry);
+#ifdef RPU_SLEEP_ENABLE
+proc_entry4_fail:
+	remove_proc_entry("mac_stats", wifi->umac_proc_dir_entry);
+#endif
+proc_entry3_fail:
+	remove_proc_entry("phy_stats", wifi->umac_proc_dir_entry);
+proc_entry2_fail:
+	remove_proc_entry("params", wifi->umac_proc_dir_entry);
+proc_entry1_fail:
+	remove_proc_entry("rk915", init_net.proc_net);
+proc_dir_fail:
+	kfree(wifi);
+out:
+	return err;
+
+}
+
+void proc_exit(void)
+{
+	remove_proc_entry("fw_params", wifi->umac_proc_dir_entry);
+	remove_proc_entry("fw_log", wifi->umac_proc_dir_entry);
+	remove_proc_entry("fw_info", wifi->umac_proc_dir_entry);
+#ifdef RPU_SLEEP_ENABLE
+	remove_proc_entry("sleep_stats", wifi->umac_proc_dir_entry);
+#endif
+	remove_proc_entry("hal_stats", wifi->umac_proc_dir_entry);
+	remove_proc_entry("mac_stats", wifi->umac_proc_dir_entry);
+	remove_proc_entry("phy_stats", wifi->umac_proc_dir_entry);
+	remove_proc_entry("params", wifi->umac_proc_dir_entry);
+	remove_proc_entry("rk915", init_net.proc_net);
+	kfree(wifi->fw_info.info);
+	kfree(wifi);
+	wifi = NULL;
+}
+
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/rpu_if.c b/drivers/net/wireless/rockchip_wlan/rk915/src/rpu_if.c
new file mode 100755
index 000000000..d0c6416ef
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/rpu_if.c
@@ -0,0 +1,3154 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+
+#include <linux/netdevice.h>
+#include <linux/rcupdate.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/of_platform.h>
+
+#include "core.h"
+#include "utils.h"
+#include "if_io.h"
+#include "hal_io.h"
+#include "hal_common.h"
+
+//#define TX_CMD_SYNC_WITH_OTHER_CMD
+
+static int rpu_send_cmd_without_delay(unsigned char *buf,
+				unsigned int len,
+				unsigned char id);
+static inline void rpu_process_pending_cmd(struct img_priv *priv, int lock);
+
+unsigned char wildcard_ssid[7] = "DIRECT-";
+#ifdef CONFIG_PM
+unsigned char rx_interrupt_status;
+#endif
+
+struct cmd_send_recv_cnt cmd_info;
+
+struct rpu_if_data {
+	char *name;
+	void *context;
+};
+
+static struct rpu_if_data __rcu *rpu_if;
+
+#ifdef DUMP_MORE_DEBUG_INFO
+static char cmd_str_tbl[RPU_MAX_CMD_NUMBER][32] = {
+	"RPU_CMD_RESET",
+	"RPU_CMD_SCAN",
+	"RPU_CMD_SCAN_ABORT",
+	"RPU_CMD_UNUSED1",
+	"RPU_CMD_SETKEY",
+	"RPU_CMD_UNUSED2",
+	"RPU_CMD_UNUSED3",
+	"RPU_CMD_TX",
+	"RPU_CMD_UNUSED4",
+	"RPU_CMD_UNUSED5",
+	"RPU_CMD_TX_POWER",
+	"RPU_CMD_UNUSED6",
+	"RPU_CMD_UNUSED7",
+	"RPU_CMD_PS",
+	"RPU_CMD_PS_ECON_CFG",
+	"RPU_CMD_VIF_CTRL",
+	"RPU_CMD_UNUSED8",
+	"RPU_CMD_UNUSED9",
+	"RPU_CMD_BA_SESSION_INFO",
+	"RPU_CMD_MCST_ADDR_CFG",
+	"RPU_CMD_MCST_FLTR_CTRL",
+	"RPU_CMD_UNUSED10",
+	"RPU_CMD_ROC_CTRL",
+	"RPU_CMD_CHANNEL",
+	"RPU_CMD_VIF_CFG",
+	"RPU_CMD_UNUSED11",
+	"RPU_CMD_TXQ_PARAMS",
+	"RPU_CMD_MIB_STATS",
+	"RPU_CMD_PHY_STATS",
+	"RPU_CMD_UNUSED12",
+	"RPU_CMD_UNUSED13",
+	"RPU_CMD_UNUSED14",
+	"RPU_CMD_UNUSED15",
+	"RPU_CMD_UNUSED16",
+	"RPU_CMD_UNUSED17",
+	"RPU_CMD_UNUSED18",
+	"RPU_CMD_CLEAR_STATS",
+	"RPU_CMD_CONT_TX",
+	"RPU_CMD_RX_CTRL",
+	"RPU_CMD_CFG_PWRMGMT",
+	"RPU_CMD_UPD_PHY_THRESH",
+	"RPU_CMD_TXRX_TEST",
+	"RPU_CMD_FW_PRIV_CMD",
+	"RPU_CMD_SL_WP_CTRL",
+	"RPU_CMD_READ_CSR",
+}; 
+
+static char event_str_tbl[RPU_MAX_EVENT_NUMBER][32] = {
+	"RPU_EVENT_RX",
+	"RPU_EVENT_TX_DONE",
+	"RPU_EVENT_DISCONNECTED",
+	"RPU_EVENT_UNUSED1",
+	"RPU_EVENT_UNUSED2",
+	"RPU_EVENT_SCAN_COMPLETE",
+	"RPU_EVENT_SCAN_ABORT_COMPLETE",
+	"RPU_EVENT_UNUSED3",
+	"RPU_EVENT_RESET_COMPLETE",
+	"RPU_EVENT_UNUSED4",
+	"RPU_EVENT_UNUSED5",
+	"RPU_EVENT_UNUSED6",
+	"RPU_EVENT_MIB_STAT",
+	"RPU_EVENT_PHY_STAT",
+	"RPU_EVENT_NW_FOUND",
+	"RPU_EVENT_NOA",
+	"RPU_EVENT_CTRL_POOL_ACK",
+	"RPU_EVENT_COMMAND_PROC_DONE",
+	"RPU_EVENT_CH_PROG_DONE",
+	"RPU_EVENT_PS_ECON_CFG_DONE",
+	"RPU_EVENT_PS_ECON_WAKE",
+	"RPU_EVENT_MAC_STATS",
+	"RPU_EVENT_UNUSED7",
+	"RPU_EVENT_UNUSED8",
+#ifndef RK915	
+	"RPU_EVENT_MSRMNT_COMPLETE",
+#endif	
+	"RPU_EVENT_ROC_STATUS",
+	"RPU_EVENT_FW_ERROR",
+	"RPU_EVENT_BLOCK_ALL",
+	"RPU_EVENT_UNBLOCK_ALL",
+	"RPU_EVENT_TXRX_TEST",
+	"RPU_EVENT_FW_PRIV_CMD_DONE",
+	"RPU_EVENT_AIRKISS_STATUS",
+	"RPU_EVENT_READ_CSR_CMP",	
+};
+void convert_cmd_to_str(int id, char *str)
+{
+	if (id < 0 || id >= RPU_MAX_CMD_NUMBER) {
+		strcpy(str, "ILLEGAL_CMD_ID");
+	} else {
+		strcpy(str, cmd_str_tbl[id]);
+	}
+}
+
+void convert_event_to_str(int id, char *str)
+{
+	if (id < 0 || id >= RPU_MAX_EVENT_NUMBER) {
+		strcpy(str, "ILLEGAL_EVENT_ID");
+	} else {
+		strcpy(str, event_str_tbl[id]);
+	}
+}
+
+#define VIF_CONF_CHANGED_INFO_NUM 16
+static char vif_conf_changed_info_tbl[VIF_CONF_CHANGED_INFO_NUM][24] = {
+	"BASICRATES_CHANGED",
+	"SHORTSLOT_CHANGED",
+	"POWERSAVE_CHANGED",
+	"UAPSDTYPE_CHANGED",
+	"ATIMWINDOW_CHANGED ",
+	"AID_CHANGED",
+	"CAPABILITY_CHANGED",
+	"SHORTRETRY_CHANGED",
+	"LONGRETRY_CHANGED",
+	"BSSID_CHANGED",
+	"RCV_BCN_MODE_CHANGED",
+	"BCN_INT_CHANGED",
+	"DTIM_PERIOD_CHANGED",
+	"SMPS_CHANGED",
+	"CONNECT_STATE_CHANGED",
+	"OP_CHAN_CHANGED"
+};
+
+static int dump_vif_cfg_changed_info(unsigned char *buf)
+{
+	struct cmd_vif_cfg *cfg = (struct cmd_vif_cfg *)buf;
+	unsigned int i;
+	char prt_str[384];
+
+	memset(prt_str, 0, sizeof(prt_str));
+	for (i = 0; i < VIF_CONF_CHANGED_INFO_NUM; i++) {
+		if (cfg->changed_bitmap & (1<<i))
+			sprintf(prt_str + strlen(prt_str), "%s|", vif_conf_changed_info_tbl[i]);
+	}
+	
+	RPU_DEBUG_IF("%s: changed_bitmap = %08x (%s)\n", __func__, cfg->changed_bitmap, prt_str);
+
+	if (cfg->changed_bitmap & BSSID_CHANGED)
+		return 0;
+	else
+		return 1;
+}
+#else
+
+void convert_cmd_to_str(int id, char *str)
+{
+	strcpy(str, "");
+}
+
+void convert_event_to_str(int id, char *str)
+{
+	strcpy(str, "");
+}
+
+int dump_vif_cfg_changed_info(unsigned char *buf)
+{
+	return 0;
+}
+
+#endif
+
+#ifdef REGENERATE_CMD_TEST
+static void regenerate_reset_cmd_data(unsigned char* buf, int type) {
+      unsigned int *init_add = (unsigned int *)buf;
+
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0xFFFF    ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=type		; init_add++;
+      *(init_add)=0xFFFFFFAC; init_add++;
+      *(init_add)=0x1       ; init_add++;
+      *(init_add)=0x1E      ; init_add++;
+      *(init_add)=0x26240000; init_add++;
+      *(init_add)=0x2E2C2A29; init_add++;
+      *(init_add)=0x3F393732; init_add++;
+      *(init_add)=0x57524A45; init_add++;
+      *(init_add)=0x6660    ; init_add++;
+      *(init_add)=0x2C2B0000; init_add++;
+      *(init_add)=0x3A373330; init_add++;
+      *(init_add)=0x4D47443D; init_add++;
+      *(init_add)=0x615A5751; init_add++;
+      *(init_add)=0x6F6B65  ; init_add++;
+      *(init_add)=0x2B000000; init_add++;
+      *(init_add)=0x3733302C; init_add++;
+      *(init_add)=0x47443D3A; init_add++;
+      *(init_add)=0x5A57514D; init_add++;
+      *(init_add)=0x6F6B6561; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x33302C2B; init_add++;
+      *(init_add)=0x443D3A37; init_add++;
+      *(init_add)=0x57514D47; init_add++;
+      *(init_add)=0x6B65615A; init_add++;
+      *(init_add)=0x6F      ; init_add++;
+      *(init_add)=0x302C2B00; init_add++;
+      *(init_add)=0x3D3A3733; init_add++;
+      *(init_add)=0x514D4744; init_add++;
+      *(init_add)=0x65615A57; init_add++;
+      *(init_add)=0x6F6B    ; init_add++;
+      *(init_add)=0x24000000; init_add++;
+      *(init_add)=0x2C2A2926; init_add++;
+      *(init_add)=0x3937322E; init_add++;
+      *(init_add)=0x524A453F; init_add++;
+      *(init_add)=0x666057  ; init_add++;
+      *(init_add)=0x2B000000; init_add++;
+      *(init_add)=0x3733302C; init_add++;
+      *(init_add)=0x47443D3A; init_add++;
+      *(init_add)=0x5A57514D; init_add++;
+      *(init_add)=0x6F6B6561; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x33302C2B; init_add++;
+      *(init_add)=0x443D3A37; init_add++;
+      *(init_add)=0x57514D47; init_add++;
+      *(init_add)=0x6B65615A; init_add++;
+      *(init_add)=0x6F      ; init_add++;
+      *(init_add)=0x302C2B00; init_add++;
+      *(init_add)=0x3D3A3733; init_add++;
+      *(init_add)=0x514D4744; init_add++;
+      *(init_add)=0x65615A57; init_add++;
+      *(init_add)=0x6F6B    ; init_add++;
+      *(init_add)=0x2C2B0000; init_add++;
+      *(init_add)=0x3A373330; init_add++;
+      *(init_add)=0x4D47443D; init_add++;
+      *(init_add)=0x615A5751; init_add++;
+      *(init_add)=0x86F6B65 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x8080808 ; init_add++;
+      *(init_add)=0x108     ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x3020100 ; init_add++;
+      *(init_add)=0x7060504 ; init_add++;
+      *(init_add)=0xB0A0908 ; init_add++;
+      *(init_add)=0xE0D0C   ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x138800  ; init_add++;
+      *(init_add)=0x12C00   ; init_add++;
+      *(init_add)=0xC800    ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x100     ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x10000   ; init_add++;
+      //*(init_add)=0xAAAA0000; init_add++;
+}
+
+static void regenerate_channel_cmd_data(unsigned char* buf, int channel) {
+      unsigned int *init_add = (unsigned int *)buf;	
+
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0xFFFF    ; init_add++;
+      *(init_add)=0x20      ; init_add++;
+      *(init_add)=0x17      ; init_add++;
+      *(init_add)=0x21      ; init_add++;
+      *(init_add)=0xB0012800; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      /**(init_add)=channel   ; */init_add++;
+      /**(init_add)=channel   ; */init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      //*(init_add)=0x0       ; init_add++;
+}
+
+static void regenerate_vif_ctrl_cmd_data(unsigned char* buf, int vif_add) {
+      unsigned int *init_add = (unsigned int *)buf;	
+	  unsigned char *init_add_char;
+	  unsigned char *LMAC = vif_macs[0];
+
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0xFFFF    ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0xF       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=IF_ADD    ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=0x0       ; init_add++;
+      *(init_add)=LMAC[3]<<24 | LMAC[2]<<16 | LMAC[1]<<8 | LMAC[0]; init_add++;
+	  init_add_char = (unsigned char *)init_add;
+	  *(init_add_char) = LMAC[4];  init_add++;
+	  *(init_add_char) = LMAC[5];  init_add++;
+      //*(init_add)=0xAAAA0000 | LMAC[5]<<8 | LMAC[4]  ; init_add++;
+}
+
+static void regenerate_vif_cfg_cmd_data(unsigned char* buf) {
+        unsigned char *LMAC = vif_macs[0];
+		struct cmd_vif_cfg *vif_cfg = (struct cmd_vif_cfg*)buf;		
+
+        //memset(vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+        vif_cfg->hdr.descriptor_id = 0xFFFF;
+        vif_cfg->hdr.id = RPU_CMD_VIF_CFG;
+        vif_cfg->hdr.length = sizeof(struct cmd_vif_cfg);
+        vif_cfg->changed_bitmap = BSSID_CHANGED | CONNECT_STATE_CHANGED;
+        vif_cfg->connect_state = 0;
+        vif_cfg->basic_rate_set = 0;//0xffff;
+        vif_cfg->use_short_slot = 0;//1;
+        vif_cfg->bcn_mode = 0;
+        vif_cfg->atim_window = 0;
+        vif_cfg->aid = 0;//1;
+        vif_cfg->capability = 0;
+        vif_cfg->short_retry = 0;//8;
+        vif_cfg->long_retry = 0;//8 ;
+        vif_cfg->smps_info = 0;
+        //memcpy(vif_cfg->bssid, BSSID, 6);
+        vif_cfg->if_index = 0;
+        //memcpy(vif_cfg->vif_addr, LMAC, 6);
+}
+#endif
+
+void update_mcs_packet_stat(int mcs_rate_num,
+				   int rate_flags,
+				   struct img_priv *priv)
+{
+	if (rate_flags & ENABLE_11N_FORMAT) {
+		switch (mcs_rate_num) {
+		case 0:
+			priv->stats->ht_tx_mcs0_packet_count++;
+			break;
+		case 1:
+			priv->stats->ht_tx_mcs1_packet_count++;
+			break;
+		case 2:
+			priv->stats->ht_tx_mcs2_packet_count++;
+			break;
+		case 3:
+			priv->stats->ht_tx_mcs3_packet_count++;
+			break;
+		case 4:
+			priv->stats->ht_tx_mcs4_packet_count++;
+			break;
+		case 5:
+			priv->stats->ht_tx_mcs5_packet_count++;
+			break;
+		case 6:
+			priv->stats->ht_tx_mcs6_packet_count++;
+			break;
+		case 7:
+			priv->stats->ht_tx_mcs7_packet_count++;
+			break;
+		case 8:
+			priv->stats->ht_tx_mcs8_packet_count++;
+			break;
+		case 9:
+			priv->stats->ht_tx_mcs9_packet_count++;
+			break;
+		case 10:
+			priv->stats->ht_tx_mcs10_packet_count++;
+			break;
+		case 11:
+			priv->stats->ht_tx_mcs11_packet_count++;
+			break;
+		case 12:
+			priv->stats->ht_tx_mcs12_packet_count++;
+			break;
+		case 13:
+			priv->stats->ht_tx_mcs13_packet_count++;
+			break;
+		case 14:
+			priv->stats->ht_tx_mcs14_packet_count++;
+			break;
+		case 15:
+			priv->stats->ht_tx_mcs15_packet_count++;
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+
+static void get_rate(struct sk_buff *skb,
+		     struct cmd_tx_ctrl *txcmd,
+		     struct tx_pkt_info *pkt_info,
+		     bool retry,
+		     struct img_priv *priv)
+{
+	struct ieee80211_rate *rate;
+	struct ieee80211_tx_info *c = IEEE80211_SKB_CB(skb);
+	unsigned int index, min_rate;
+	bool is_mcs = false, is_mgd = false;
+	struct ieee80211_tx_rate *txrate;
+	unsigned char mcs_rate_num = 0;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	int mcs_indx;
+	int mgd_rate;
+	int mgd_mcast_rate;
+	int prot_type;
+	unsigned char nss = 1;
+	bool all_rates_invalid = true;
+
+
+	/* Normal Mode*/
+	rate = ieee80211_get_tx_rate(priv->hw, c);
+	min_rate = priv->hw->wiphy->bands[c->band]->bitrates[0].hw_value;
+
+	if (rate == NULL) {
+		RPU_DEBUG_IF("%s:%d rate is null taking defaults: min: %d\n",
+			      __func__,
+			      __LINE__,
+			      c->control.rates[0].idx);
+		txcmd->num_rates = 1;
+		txcmd->rate[0] = min_rate;
+		txcmd->rate_retries[0] = 5;
+		txcmd->rate_protection_type[0] = USE_PROTECTION_NONE;
+		txcmd->rate_preamble_type[0] = DONT_USE_SHORT_PREAMBLE;
+		txcmd->num_spatial_streams[0] = 1;
+		txcmd->bcc_or_ldpc = 0;
+		txcmd->stbc_enabled = 0;
+		txcmd->rate_flags[0] = 0;
+		return;
+	}
+
+	/* Some defaults*/
+	txcmd->num_rates = 0;
+	txcmd->stbc_enabled = 0;
+
+	/* BCC (or) LDPC */
+	if (c->flags & IEEE80211_TX_CTL_LDPC)
+		txcmd->bcc_or_ldpc = 1;
+	else
+		txcmd->bcc_or_ldpc = 0;
+
+	if (ieee80211_is_data(hdr->frame_control) &&
+	    c->flags & IEEE80211_TX_CTL_AMPDU) {
+		txcmd->aggregate_mpdu = AMPDU_AGGR_ENABLED;
+	}
+
+	for (index = 0; index < 4; index++) {
+		bool skip_rate = false;
+
+		txrate = (&c->control.rates[index]);
+		txcmd->rate_flags[index] = 0;
+
+		if (txrate->idx < 0)
+			continue;
+
+		txcmd->num_rates++;
+		txcmd->num_spatial_streams[index] = 1;
+
+		/* No input from production_test proc, continue and use
+		 * info from mac80211 RC
+		 */
+
+		if (txrate->flags & IEEE80211_TX_RC_MCS) {
+			is_mcs = true;
+			mcs_rate_num  = txrate->idx;
+			nss = mcs_rate_num/8 + 1;
+			txcmd->rate_flags[index] |= ENABLE_11N_FORMAT;
+		}
+
+		mcs_indx = priv->params->mgd_mode_tx_fixed_mcs_indx;
+		mgd_rate = priv->params->mgd_mode_tx_fixed_rate;
+		mgd_mcast_rate = priv->params->mgd_mode_mcast_fixed_data_rate;
+
+		/* Rate Index:
+		 * From proc:
+		 *    ** Multicast data packets
+		 *    ** Unicast data packets
+		 * From RC in mac80211
+		 * Can be MCS(HT/VHT) or Rate (11abg)
+		 */
+		if (ieee80211_is_data(hdr->frame_control) &&
+		    is_multicast_ether_addr(hdr->addr1) &&
+		    (mgd_mcast_rate != -1)) {
+			/* proc: Fixed MCS/Legacy rate for Multicast packets
+			 */
+			is_mgd = true;
+			is_mcs = (mgd_mcast_rate & 0x80) == 0x80 ? true : false;
+
+			if (!is_mcs) {
+				if (mgd_mcast_rate == 55)
+					mgd_mcast_rate = 11;
+				else
+					mgd_mcast_rate *= 2;
+			}
+
+			txcmd->rate[index] = mgd_mcast_rate;
+			txcmd->rate_flags[index] =
+				priv->params->mgd_mode_mcast_fixed_rate_flags;
+			txcmd->bcc_or_ldpc =
+				priv->params->mgd_mode_mcast_fixed_bcc_or_ldpc;
+			if (txcmd->rate_flags[index] & ENABLE_11N_FORMAT)
+				nss = (mgd_mcast_rate & 0x7F)/8 + 1;
+			else
+				nss = priv->params->mgd_mode_mcast_fixed_nss;
+			txcmd->stbc_enabled =
+				priv->params->mgd_mode_mcast_fixed_stbc_enabled;
+			txcmd->rate_preamble_type[index] =
+				priv->params->mgd_mode_mcast_fixed_preamble;
+			if (is_mcs)
+				update_mcs_packet_stat(mgd_mcast_rate & 0x7F,
+						       txcmd->rate_flags[index],
+						       priv);
+		} else if (ieee80211_is_data(hdr->frame_control) &&
+			   mcs_indx != -1) {
+			/* proc: Fixed MCS for unicast
+			 */
+			is_mgd = true;
+
+			txcmd->rate[index] = 0x80;
+			txcmd->rate[index] |= (mcs_indx);
+			txcmd->rate_flags[index] =
+				priv->params->prod_mode_rate_flag;
+			if (txcmd->rate_flags[index] & ENABLE_11N_FORMAT)
+				nss = (mcs_indx)/8 + 1;
+			else
+				nss = priv->params->num_spatial_streams;
+			txcmd->bcc_or_ldpc =
+				priv->params->prod_mode_bcc_or_ldpc;
+			txcmd->stbc_enabled =
+				priv->params->prod_mode_stbc_enabled;
+
+			update_mcs_packet_stat(mcs_indx,
+					       txcmd->rate_flags[index],
+					       priv);
+		} else if (ieee80211_is_data(hdr->frame_control) &&
+			   mgd_rate != -1) {
+			/* proc: Fixed Legacy Rate for unicast
+			 */
+			is_mgd = true;
+			txcmd->rate[index] = 0x80;
+			txcmd->rate[index] = 0x00;
+
+			if (mgd_rate == 55)
+				txcmd->rate[index] |= ((mgd_rate) / 5);
+			else
+				txcmd->rate[index] |= ((mgd_rate * 10) / 5);
+
+			txcmd->rate_flags[index] = 0;
+			nss = 1;
+			txcmd->bcc_or_ldpc         = 0;
+			txcmd->stbc_enabled        = 0;
+			txcmd->rate_preamble_type[index] =
+				priv->params->prod_mode_rate_preamble_type;
+		} else if (is_mcs) {
+			txcmd->rate[index] = MARK_RATE_AS_MCS_INDEX;
+			txcmd->rate[index] |= mcs_rate_num;
+			update_mcs_packet_stat(mcs_rate_num,
+					      txcmd->rate_flags[index],
+					      priv);
+		} else if (!is_mcs) {
+			rate = &priv->hw->wiphy->bands[
+				c->band]->bitrates[
+				c->control.rates[index].idx];
+			txcmd->rate[index] = MARK_RATE_AS_RATE;
+			txcmd->rate[index] |= rate->hw_value;
+			nss = 1;
+		}
+
+		txcmd->num_spatial_streams[index] = nss;
+
+		if (is_mgd) {
+			if (priv->params->rate_protection_type)
+				txcmd->rate_protection_type[index] =
+					USE_PROTECTION_RTS;
+			else
+				txcmd->rate_protection_type[index] =
+					USE_PROTECTION_NONE;
+			txcmd->rate_retries[index] = 1;
+			all_rates_invalid = false;
+			break;
+		}
+
+		/* STBC Enabled/Disabled: valid if n_antennas > Nss */
+		if (priv->params->uccp_num_spatial_streams > nss &&
+		    (c->flags & IEEE80211_TX_CTL_STBC))
+			txcmd->stbc_enabled = 1;
+
+		txcmd->rate_retries[index] =
+			c->control.rates[index].count;
+
+		if (c->control.rates[index].flags &
+		    IEEE80211_TX_RC_USE_SHORT_PREAMBLE)
+			txcmd->rate_preamble_type[index] =
+				USE_SHORT_PREAMBLE;
+		else
+			txcmd->rate_preamble_type[index] =
+				DONT_USE_SHORT_PREAMBLE;
+
+		prot_type = USE_PROTECTION_NONE;
+		if (priv->params->rate_protection_type == 1) {
+			/* Protection*/
+			if (c->control.rates[index].flags &
+			    IEEE80211_TX_RC_USE_CTS_PROTECT)
+				prot_type = USE_PROTECTION_CTS2SELF;
+			else if (c->control.rates[index].flags &
+				 IEEE80211_TX_RC_USE_RTS_CTS)
+				prot_type = USE_PROTECTION_RTS;
+			else
+				prot_type = USE_PROTECTION_NONE;
+
+			/*RTS threshold: Check for PSDU length
+			 * Need to add all HW added lenghts to skb,
+			 * sw added lengths are already part of skb->len
+			 * IV ==> Always SW
+			 * MIC for CCMP ==> HW (MMIC for TKIP ==> SW)
+			 * ICV ==> HW
+			 * FCS ==> HW
+			*/
+			if (ieee80211_is_data(hdr->frame_control) &&
+			    !is_multicast_ether_addr(hdr->addr1) &&
+			    ieee80211_has_protected(hdr->frame_control)) {
+				if (skb->len +
+				    c->control.hw_key->icv_len +
+				    priv->rts_threshold < FCS_LEN)
+					prot_type = USE_PROTECTION_RTS;
+			}
+
+			if (ieee80211_is_data(hdr->frame_control) &&
+			    !is_multicast_ether_addr(hdr->addr1) &&
+			    !ieee80211_has_protected(hdr->frame_control) &&
+			    (skb->len + FCS_LEN > priv->rts_threshold))
+				prot_type = USE_PROTECTION_RTS;
+		}
+
+		txcmd->rate_protection_type[index] = prot_type;
+
+
+		/*Some Sanity Checks*/
+		if (nss <= max(MAX_TX_STREAMS, MAX_RX_STREAMS))
+			/*Got at-least one valid rate*/
+			all_rates_invalid = false;
+		else {
+			if (net_ratelimit())
+				RPU_DEBUG_IF("RPU_WIFI:Skip Nss: %d\n",
+					      nss);
+			skip_rate = true;
+		}
+
+		/*First Time*/
+			if (!index)
+				pkt_info->max_retries = 0;
+			pkt_info->max_retries +=
+				txcmd->rate_retries[index];
+		if (skip_rate)
+			txcmd->rate_retries[index] = 0;
+
+	}
+
+	if (all_rates_invalid) {
+		/*use min supported rate*/
+		if (net_ratelimit())
+			RPU_INFO_TX("RPU_WIFI:invalid rates\n");
+		txcmd->num_rates = 1;
+		txcmd->rate[0] = min_rate;
+		txcmd->rate_retries[0] = 4;
+		txcmd->rate_protection_type[0] = USE_PROTECTION_NONE;
+		txcmd->rate_preamble_type[0] = DONT_USE_SHORT_PREAMBLE;
+		txcmd->num_spatial_streams[0] = 1;
+		txcmd->bcc_or_ldpc = 0;
+		txcmd->stbc_enabled = 0;
+		txcmd->rate_flags[0] = 0;
+	}
+}
+
+static inline void rpu_send(void *nbuf, struct img_priv *priv)
+{
+	struct sk_buff *pending_cmd;
+	int send_pnd_cnt = 0;
+	int need_pending = 0;
+	int num_of_pending;
+#ifdef OUTS_CMD_CHECK
+	struct sk_buff *skb, *tmp;
+#endif
+
+	/* Take lock to make the control commands sequential in case of SMP*/
+	spin_lock_bh(&cmd_info.control_path_lock);
+	if (!block_rpu_comm && cmd_info.outstanding_ctrl_req < MAX_OUTSTANDING_CTRL_REQ) {
+		while (1) {
+			pending_cmd = skb_dequeue(&cmd_info.outstanding_cmd);
+			if (!pending_cmd)
+				break;
+			hal_ops.send((void *)pending_cmd , NULL, 0);
+			if (cmd_info.outstanding_ctrl_req > 0)
+				cmd_info.outstanding_ctrl_req--;
+			priv->stats->gen_cmd_send_count++;
+			send_pnd_cnt++;
+			if (send_pnd_cnt >= MAX_OUTSTANDING_CTRL_REQ) {
+				need_pending = 1;
+				break;
+			}
+		}
+	} else {
+		need_pending = 1;
+	}
+	
+	if (need_pending) {
+		RPU_DEBUG_IF("Sending the CMD, Waiting in Queue: %d\n",
+			     cmd_info.outstanding_ctrl_req);
+#ifdef OUTS_CMD_CHECK
+		if (hpriv->fw_error_processing)
+			SET_TIME_TICKS_TO_SKB_CB((struct sk_buff *)nbuf, 0);
+		else
+			SET_TIME_TICKS_TO_SKB_CB((struct sk_buff *)nbuf, jiffies);
+#endif
+		skb_queue_tail(&cmd_info.outstanding_cmd, nbuf);
+	} else {
+		RPU_DEBUG_IF("Sending the CMD, got Access\n");
+		hal_ops.send((void *)nbuf, NULL, 0);
+		priv->stats->gen_cmd_send_count++;
+	}
+
+	/* sent but still no proc_done / unsent due to pending requests */
+	cmd_info.outstanding_ctrl_req++;
+
+	num_of_pending = skb_queue_len(&cmd_info.outstanding_cmd);
+#ifdef OUTS_CMD_CHECK
+	/* we had found that,  loss of cmd_proc_done will happens low probability
+	 * that will cause outstanding_ctrl_req >= MAX_OUTSTANDING_CTRL_REQ
+	 * Finally cause driver stop send any commands to rpu
+	 * Add a check mechanism here
+	*/
+	if (num_of_pending) {
+		int pending = 0;
+
+		skb_queue_walk_safe(&cmd_info.outstanding_cmd, skb, tmp) {
+			if (!skb || GET_TIME_TICKS_FROM_SKB_CB(skb) == 0)
+				continue;
+			if (time_after(jiffies, GET_TIME_TICKS_FROM_SKB_CB(skb) + msecs_to_jiffies(300))) {
+				RPU_INFO_IF("detect loss of cmd_proc_done (%lu, %lu)\n",
+								jiffies, GET_TIME_TICKS_FROM_SKB_CB(skb));
+				rpu_process_pending_cmd(priv, 0);
+				pending = 1;
+			}
+			if (pending) { // update other outstanding cmd
+				SET_TIME_TICKS_TO_SKB_CB(skb, jiffies);
+			}
+		}
+	}
+#endif
+
+	if (num_of_pending > priv->stats->max_outstanding_cmd_queue_cnt)
+		priv->stats->max_outstanding_cmd_queue_cnt = num_of_pending;
+	priv->stats->outstanding_cmd_cnt = cmd_info.outstanding_ctrl_req;
+	spin_unlock_bh(&cmd_info.control_path_lock);
+}
+
+#ifdef REGENERATE_CMD_TEST
+static int cmd_channel = 0;
+static int cmd_vif_cfg = 0;
+#endif
+static int rpu_send_cmd(unsigned char *buf,
+				unsigned int len,
+				unsigned char id)
+{
+	struct host_rpu_msg_hdr *hdr = (struct host_rpu_msg_hdr *)buf;
+	struct sk_buff *nbuf;
+	struct rpu_if_data *p;
+	struct img_priv *priv;
+	char cmd_str[64];
+
+	convert_cmd_to_str(id, cmd_str);
+
+#ifdef DUMP_MORE_DEBUG_INFO
+	if (id == RPU_CMD_VIF_CFG) {
+		int skip;
+		skip = dump_vif_cfg_changed_info(buf);
+	}
+#endif
+
+	rcu_read_lock();
+
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+
+	if (!p) {
+		RPU_ERROR_IF("%s: Unable to retrieve rpu_if\n", __func__);
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+	priv= p->context;
+	nbuf = alloc_skb(len, GFP_ATOMIC);
+
+	if (!nbuf) {
+		RPU_ERROR_IF("%s: ENOMEM\n", __func__);
+		rcu_read_unlock();
+		//WARN_ON(1);
+		return -ENOMEM;
+	}
+	hdr->id = id;
+	RPU_DEBUG_IF("%s-RPUIF: Sending command:%d(%s), outstanding_cmds: %d\n",
+		     p->name, hdr->id, cmd_str, cmd_info.outstanding_ctrl_req);
+	hdr->length = len;
+	hdr->descriptor_id = 0;
+	hdr->descriptor_id |= 0x0000ffff;
+
+	memcpy(skb_put(nbuf, len), buf, len);
+	//priv->stats->outstanding_cmd_cnt = cmd_info.outstanding_ctrl_req;
+
+	rpu_send(nbuf, priv);
+	
+	rcu_read_unlock();
+
+	return 0;
+}
+
+#ifdef SDIO_TXRX_STABILITY_TEST
+#include <asm/div64.h>
+#define CALCULATE_RATE_LENGTH (50*1024*1024)
+#define TX_SKB_NUM 10
+INIT_GET_SPEND_TIME(start_time, end_time);
+extern void hal_send_direct(void *msg);
+static u8 test_data[2048];
+int rpu_prog_txrx_test(int status)
+{
+	struct cmd_txrx_test test;
+
+#if 1
+#if 1 // only cmd_tx test
+	int i, j, count = 1024*1024, total = 0;
+	struct sk_buff *test_skb[TX_SKB_NUM];
+	struct sk_buff *skb;
+	int test_skb_len = 1568;
+	int len;
+	struct cmd_tx_ctrl cmd_tx_ctrl;
+	struct cmd_tx_ctrl *tx_cmd = &cmd_tx_ctrl;
+	int queue = 3;
+	int descriptor_id = 3;
+
+	memset(test_data, 0xAA, 2048);
+	skb = alloc_skb(sizeof(struct cmd_tx_ctrl), GFP_ATOMIC);
+	for (i = 0; i < TX_SKB_NUM; i++) {
+		test_skb[i] = alloc_skb(test_skb_len, GFP_ATOMIC);
+		memcpy(skb_put(test_skb[i], test_skb_len), test_data, test_skb_len);
+	}
+
+	/* HAL UMAC-LMAC HDR*/
+	tx_cmd->hdr.id = RPU_CMD_TX;
+	/* Keep the queue num and pool id in descriptor id */
+	tx_cmd->hdr.descriptor_id = 0;
+	tx_cmd->hdr.descriptor_id |= ((queue & 0x0000FFFF) << 16);
+	tx_cmd->hdr.descriptor_id |= (descriptor_id & 0x0000FFFF);
+	/* Not used anywhere currently */
+	tx_cmd->hdr.length = sizeof(struct cmd_tx_ctrl);
+
+	/* RPU_CMD_TX*/
+	tx_cmd->if_index = 0;
+	tx_cmd->queue_num = queue;
+	tx_cmd->more_frms = 0;
+	tx_cmd->descriptor_id = descriptor_id;
+	tx_cmd->num_frames_per_desc = TX_SKB_NUM; 
+
+	for (j = 0; j < TX_SKB_NUM; j++) {
+		tx_cmd->pkt_length[j] = test_skb_len;
+		tx_cmd->p_frame_ddr_pointer[j] = (unsigned int *)test_skb[j]->data;	
+	}
+	memcpy(skb_put(skb, sizeof(struct cmd_tx_ctrl)), tx_cmd, sizeof(struct cmd_tx_ctrl));
+
+	// start cmd_tx test
+	RPU_INFO_IF("%s: start cmd_tx test\n", __func__);
+	memset(&test, 0, sizeof(struct cmd_txrx_test));
+	test.status = status;
+	rpu_send_cmd((unsigned char *) &test,
+				    sizeof(struct cmd_txrx_test),
+				    RPU_CMD_TXRX_TEST);
+
+	// do cmd_tx test
+	START_GET_SPEND_TIME(start_time, end_time);
+	for (i = 0; i < count; i++) {
+		//RPU_INFO_IF("rk915_data_write: %d\n", skb->len);
+		rk915_data_write(hpriv, 0, skb->data, skb->len);
+		if (rpu_is_cmd_has_data(skb->data)) {
+			rpu_send_cmd_datas(skb->data, hpriv);
+		}
+
+		len = test_skb_len*TX_SKB_NUM;
+		total += len;
+		if (total >= CALCULATE_RATE_LENGTH) {
+			int spend_time;
+			END_GET_SPEND_TIME(start_time, end_time);
+			spend_time = GET_SPEND_TIME_US(start_time, end_time)/1000;
+			RPU_INFO_IF("send %d Mbytes (every pkgs len = %d) use %d ms\n", total/1024/1024, len, spend_time);
+			total = 0;
+			START_GET_SPEND_TIME(start_time, end_time);
+		}
+	}
+#else // only sdio RX test
+	// start rx test
+	RPU_INFO_IF("%s: start rx test\n", __func__);
+	memset(&test, 0, sizeof(struct cmd_txrx_test));
+	test.status = TXRX_TEST_START_RX;
+	rpu_send_cmd_without_delay((unsigned char *) &test,
+				    sizeof(struct cmd_txrx_test),
+				    RPU_CMD_TXRX_TEST);
+	START_GET_SPEND_TIME(start_time, end_time);
+#endif
+#else
+#if 0 // only sdio TX test
+	int i, count = 1024*1024, total = 0;
+	// start tx test
+	RPU_INFO_IF("%s: start tx test\n", __func__);
+	memset(&test, 0, sizeof(struct cmd_txrx_test));
+	test.status = status;
+	rpu_send_cmd((unsigned char *) &test,
+				    sizeof(struct cmd_txrx_test),
+				    RPU_CMD_TXRX_TEST);
+
+	// do tx test
+	START_GET_SPEND_TIME(start_time, end_time);
+	for (i = 0; i < count; i++) {
+		char tx_test_data[4096];
+		struct cmd_txrx_test *cmd;
+		int len, data_len ;
+
+		data_len = 512*3;
+		len = data_len + sizeof(struct cmd_txrx_test);
+
+		memset(tx_test_data, 0xAA, len);
+		memset(tx_test_data, 0, sizeof(struct cmd_txrx_test));
+		cmd = (struct cmd_txrx_test *)tx_test_data;
+		cmd->status = TXRX_TEST_TX;
+		//RPU_INFO_IF("%s: do tx test (len=%d)\n", __func__, len);
+		rpu_send_cmd_without_delay((unsigned char *) &tx_test_data,
+				    len,
+				    RPU_CMD_TXRX_TEST);
+		total += len;
+		if (total >= CALCULATE_RATE_LENGTH) {
+			int spend_time;
+			END_GET_SPEND_TIME(start_time, end_time);
+			spend_time = GET_SPEND_TIME_US(start_time, end_time)/1000;
+			RPU_INFO_IF("send %d Mbytes (every pkgs len = %d) use %d ms\n", total/1024/1024, len, spend_time);
+			total = 0;
+			START_GET_SPEND_TIME(start_time, end_time);
+		}
+	}
+#else // only sdio RX test
+	// start rx test
+	RPU_INFO_IF("%s: start rx test\n", __func__);
+	memset(&test, 0, sizeof(struct cmd_txrx_test));
+	test.status = TXRX_TEST_START_RX;
+	rpu_send_cmd_without_delay((unsigned char *) &test,
+				    sizeof(struct cmd_txrx_test),
+				    RPU_CMD_TXRX_TEST);
+	START_GET_SPEND_TIME(start_time, end_time);
+#endif
+#endif
+
+	while (1) {
+		msleep(1000);
+	}
+	return 0;
+}
+
+static int rx_total_len = 0;
+static void rpu_txrx_test_receive(struct host_rpu_msg_hdr *hdr)
+{
+	rx_total_len += hdr->length;
+	if (rx_total_len >= CALCULATE_RATE_LENGTH) {
+		int spend_time;
+		END_GET_SPEND_TIME(start_time, end_time);
+		spend_time = GET_SPEND_TIME_US(start_time, end_time)/1000;
+		RPU_INFO_IF("receive %d Mbytes (every pkgs len = %d) use %d ms\n", rx_total_len/1024/1024, hdr->length, spend_time);
+		rx_total_len = 0;
+		START_GET_SPEND_TIME(start_time, end_time);
+	}
+}
+#endif
+
+/* rpu_send_cmd_without_delay, will not block by MAX_OUTSTANDING_CTRL_REQ */
+static int rpu_send_cmd_without_delay(unsigned char *buf,
+				unsigned int len,
+				unsigned char id)
+{
+	struct host_rpu_msg_hdr *hdr = (struct host_rpu_msg_hdr *)buf;
+	struct sk_buff *nbuf;
+	struct rpu_if_data *p;
+	struct img_priv *priv;
+	char cmd_str[64];
+
+	convert_cmd_to_str(id, cmd_str);
+
+	rcu_read_lock();
+
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+
+	if (!p) {
+		RPU_ERROR_IF("%s: Unable to retrieve rpu_if\n", __func__);
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+	priv= p->context;
+	nbuf = alloc_skb(len, GFP_ATOMIC);
+
+	if (!nbuf) {
+		rcu_read_unlock();
+		WARN_ON(1);
+		return -ENOMEM;
+	}
+	hdr->id = id;
+	hdr->length = len;
+	hdr->descriptor_id = 0;
+	hdr->descriptor_id |= 0x0000ffff;
+
+	memcpy(skb_put(nbuf, len), buf, len);
+	//priv->stats->outstanding_cmd_cnt = cmd_info.outstanding_ctrl_req;
+
+#ifdef SDIO_TXRX_STABILITY_TEST
+	hal_send_direct(nbuf);
+#else
+	spin_lock_bh(&cmd_info.control_path_lock);
+	RPU_DEBUG_IF("Sending the CMD, got Access\n");
+	hal_ops.send((void *)nbuf, NULL, 0);
+	priv->stats->gen_cmd_send_count++;
+	spin_unlock_bh(&cmd_info.control_path_lock);
+#endif
+
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static int fw_priv_init(void *context, struct fw_priv_cmd *info) {
+	struct img_priv *priv = (struct img_priv *)context;
+
+	info->production_test = priv->params->production_test;
+	info->fw_skip_rx_pkt_submit = priv->params->fw_skip_rx_pkt_submit;
+        info->wlan_mac_addr = vif_macs[0][0];
+        info->p2p_mac_addr = vif_macs[1][0];
+	return 0;
+}
+
+int rpu_fw_priv_cmd(unsigned int type, void *priv)
+{
+	struct fw_priv_cmd info;
+	struct rpu_if_data *p;
+	struct fw_reg_info *reg = (struct fw_reg_info *)priv;
+
+	rcu_read_lock();
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+	rcu_read_unlock();
+
+	if (type == DUMP_REG_INFO)
+		rpu_fw_info_dump_start(p->context, type, reg->reg);
+	else
+		rpu_fw_info_dump_start(p->context, type, 0);
+
+	memset(&info, 0, sizeof(struct fw_priv_cmd));
+	info.type = type;
+	if (type == DUMP_REG_INFO) {
+		int mod = reg->len % 4;
+		if (mod) {
+			reg->len += 4 - mod;
+		}
+		
+		info.reg_info.reg = reg->reg;
+		info.reg_info.val = reg->val;
+		info.reg_info.len = reg->len;
+		info.reg_info.rw  = reg->rw;
+	} else if (type == FW_PRIV_INIT) {
+		fw_priv_init(p->context, &info);
+	} else if (type == FW_SET_PARAMS) {
+		memcpy(&info.params, priv, sizeof(struct fw_params));
+	} else if (type == ENABLE_SNIFFER) {
+		int sniffer = *((int *)priv);
+
+		if (sniffer > 3)
+			sniffer = 0;
+		info.sniffer = sniffer;
+		pr_info("sniffer %d\n", info.sniffer);
+	}
+
+	return rpu_send_cmd_without_delay((unsigned char *) &info,
+				sizeof(struct fw_priv_cmd),
+				RPU_CMD_FW_PRIV_CMD);
+}
+
+int rpu_fw_priv_cmd_sync(unsigned int type, void *priv)
+{
+	int ret = 0;
+	int count = 100;
+	struct fw_info_dump *fw_info = &wifi->fw_info;
+
+	ret = rpu_fw_priv_cmd(type, priv);
+	if (ret != 0) {
+		pr_err("%s: cmd(%d) send fail!\n", __func__, type);
+		return ret;
+	}
+
+	while (fw_info->finish == 0 || fw_info->type != type) {
+		if (count-- < 0) {
+			pr_err("%s: cmd(%d) timeout\n", __func__, type);
+			return -1;
+		}
+		msleep(10);
+	}
+
+	return 0;
+}
+
+int rpu_prog_reset(unsigned int reset_type, unsigned int rpu_mode)
+{
+	struct cmd_reset reset;
+	struct img_priv *priv;
+	struct rpu_if_data *p;
+	unsigned int i;
+
+	rcu_read_lock();
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+	rcu_read_unlock();
+	priv= p->context;
+
+	memset(&reset, 0, sizeof(struct cmd_reset));
+
+	reset.type = reset_type;
+
+	reset.reserv[0] = 0x01b50052; // 0x468bc
+	reset.reserv[1] = 0x017901b5; // 0x468c0
+
+	if (reset_type != LMAC_DISABLE) {
+		priv->cmd_reset_count++;
+		reset.type |= LOAD_FACTORY_CAL;
+#ifdef RK915
+		reset.type |= LMAC_DO_CALIB;		
+#endif
+		RPU_DEBUG_IF("ed = %d auto = %d\n",
+			priv->params->ed_sensitivity,
+			priv->params->auto_sensitivity);
+		reset.num_spatial_streams =
+			priv->params->uccp_num_spatial_streams;
+		reset.lmac_mode = rpu_mode;
+		/* Always force RF calibration */
+		reset.lmac_mode |= LMAC_DO_CALIB;
+		reset.antenna_sel = priv->params->antenna_sel;
+
+		if (priv->params->production_test == 0 &&
+			priv->params->bypass_vpd == 0) {
+			memcpy(reset.rf_params, priv->params->rf_params_vpd,
+			       RF_PARAMS_SIZE);
+		} else {
+			memcpy(reset.rf_params, priv->params->rf_params,
+			       RF_PARAMS_SIZE);
+		}
+
+		reset.system_rev = priv->stats->system_rev;
+		reset.bg_scan.enabled = priv->params->bg_scan_enable;
+
+		if (reset.bg_scan.enabled) {
+			for (i = 0; i < priv->params->bg_scan_num_channels;
+			     i++) {
+				reset.bg_scan.channel_list[i] =
+					priv->params->bg_scan_channel_list[i];
+				reset.bg_scan.channel_flags[i] =
+					priv->params->bg_scan_channel_flags[i];
+			}
+			reset.bg_scan.num_channels =
+				priv->params->bg_scan_num_channels;
+			reset.bg_scan.scan_intval =
+				priv->params->bg_scan_intval;
+			reset.bg_scan.channel_dur =
+				/* Channel spending time */
+				priv->params->bg_scan_chan_dur;
+
+			reset.bg_scan.serv_channel_dur =
+				/* operating channel spending time */
+				priv->params->bg_scan_serv_chan_dur;
+		}
+	}
+
+	RPU_INFO_IF("%s: reset_type=0x%x, rpu_mode=0x%x\n", __func__, reset.type, rpu_mode);
+
+	return rpu_send_cmd((unsigned char *) &reset,
+				    sizeof(struct cmd_reset), RPU_CMD_RESET);
+}
+
+int rpu_prog_phy_thresh(unsigned int *thresh)
+{
+	struct cmd_update_phy_thresh cmd;
+	int i;
+
+	RPU_DEBUG_DAPT("%s: thresh: "
+					"%03d %03d %03d %03d "
+					"%03d %03d %03d %03d "
+					"%03d %03d %03d %03d "
+					"%03d %03d\n", __func__,
+					thresh[0], thresh[1], thresh[2], thresh[3],
+					thresh[4], thresh[5], thresh[6], thresh[7],
+					thresh[8], thresh[9], thresh[10], thresh[11],
+					thresh[12], thresh[13]);
+
+	memset(&cmd, 0, sizeof(struct cmd_update_phy_thresh));
+	for (i = 0; i < 14; i++) {
+		cmd.thresholds[i] = (unsigned char)thresh[i];
+	}
+
+	return rpu_send_cmd((unsigned char *) &cmd,
+				    sizeof(struct cmd_update_phy_thresh),
+				    RPU_CMD_UPD_PHY_THRESH);
+}
+
+int rpu_prog_cfgmisc(unsigned int flag)
+{
+	struct cmd_cfg_misc cmisc;
+
+	memset(&cmisc, 0, sizeof(struct cmd_cfg_misc));
+	cmisc.flags = RPU_MISC_CFG_SNIFF_MODE_MASK;
+	cmisc.sniff_mode = flag;
+
+	return rpu_send_cmd((unsigned char *) &cmisc,
+				    sizeof(struct cmd_cfg_misc),
+				    RPU_CMD_MISC_CFG);
+}
+
+int rpu_prog_txpower(unsigned int txpower)
+{
+	struct cmd_tx_pwr power;
+
+	memset(&power, 0, sizeof(struct cmd_tx_pwr));
+	power.tx_pwr = txpower;
+	power.if_index = 0;
+
+	return rpu_send_cmd((unsigned char *) &power,
+				    sizeof(struct cmd_tx_pwr),
+				    RPU_CMD_TX_POWER);
+}
+
+int rpu_prog_patch_feature(unsigned int feature)
+{
+	struct cmd_patch_feature patch;
+
+	memset(&patch, 0, sizeof(struct cmd_patch_feature));
+	patch.feature_val = feature;
+
+	return rpu_send_cmd((unsigned char *) &patch,
+				    sizeof(struct cmd_patch_feature),
+				    RPU_CMD_PATCH_FEATURES);
+}
+
+int rpu_prog_vif_ctrl(int index,
+		unsigned char *mac_addr,
+		unsigned int vif_type,
+		unsigned int op)
+{
+	struct cmd_vifctrl vif_ctrl;
+
+	memset(&vif_ctrl, 0, sizeof(struct cmd_vifctrl));
+	vif_ctrl.mode = vif_type;
+	memcpy(vif_ctrl.mac_addr, mac_addr, 6);
+	vif_ctrl.if_index = index;
+	vif_ctrl.if_ctrl = op;
+
+	return rpu_send_cmd((unsigned char *) &vif_ctrl,
+				    sizeof(struct cmd_vifctrl),
+				    RPU_CMD_VIF_CTRL);
+}
+
+
+int rpu_prog_mcast_addr_cfg(unsigned char *mcast_addr,
+				    unsigned int op)
+{
+	struct cmd_mcst_addr_cfg mcast_config;
+
+	//RPU_INFO_UMACIF("RPU_CMD_MCST_ADDR_CFG: %s %pM\n",
+	//		op==WLAN_MCAST_ADDR_ADD ? "ADD":"REM", mcast_addr);
+
+	memset(&mcast_config, 0, sizeof(struct cmd_mcst_addr_cfg));
+
+	mcast_config.op = op;
+	memcpy(mcast_config.mac_addr, mcast_addr, 6);
+
+	return rpu_send_cmd((unsigned char *) &mcast_config,
+				    sizeof(struct cmd_mcst_addr_cfg),
+				    RPU_CMD_MCST_ADDR_CFG);
+}
+
+
+int rpu_prog_mcast_filter_control(unsigned int mcast_filter_enable)
+{
+	struct cmd_mcst_filter_ctrl mcast_ctrl;
+
+	//RPU_INFO_UMACIF("RPU_CMD_MCST_FLTR_CTRL: %s\n",
+	//		mcast_filter_enable==MCAST_FILTER_ENABLE ? "ENABLE":"DISABLE");
+
+	memset(&mcast_ctrl, 0, sizeof(struct cmd_mcst_filter_ctrl));
+	mcast_ctrl.ctrl = mcast_filter_enable;
+
+	return rpu_send_cmd((unsigned char *) &mcast_ctrl,
+				    sizeof(struct cmd_mcst_filter_ctrl),
+				    RPU_CMD_MCST_FLTR_CTRL);
+}
+
+
+
+int rpu_prog_roc(unsigned int roc_ctrl,
+			 unsigned int roc_channel,
+			 unsigned int roc_duration,
+			 unsigned int roc_type)
+{
+	struct cmd_roc cmd_roc;
+
+	memset(&cmd_roc, 0, sizeof(struct cmd_roc));
+
+	cmd_roc.roc_ctrl = roc_ctrl;
+	cmd_roc.roc_channel	= roc_channel;
+	cmd_roc.roc_duration = roc_duration;
+	cmd_roc.roc_type = roc_type;
+
+	return rpu_send_cmd((unsigned char *) &cmd_roc,
+			sizeof(struct cmd_roc), RPU_CMD_ROC_CTRL);
+}
+
+
+int rpu_prog_peer_key(int vif_index,
+			      unsigned char *vif_addr,
+			      unsigned int op,
+			      unsigned int key_id,
+			      unsigned int key_type,
+			      unsigned int cipher_type,
+			      struct umac_key *key)
+{
+	struct cmd_setkey peer_key;
+
+	memset(&peer_key, 0, sizeof(struct cmd_setkey));
+
+	peer_key.if_index = vif_index;
+	/* memcpy(peer_key.vif_addr, vif_addr, ETH_ALEN); */
+	peer_key.ctrl = op;
+	peer_key.key_id = key_id;
+	img_ether_addr_copy(peer_key.mac_addr, key->peer_mac);
+
+	peer_key.key_type = key_type;
+	peer_key.cipher_type = cipher_type;
+	memcpy(peer_key.key, key->key, MAX_KEY_LEN);
+	peer_key.key_len = MAX_KEY_LEN;
+
+	if (key->tx_mic) {
+		memcpy(peer_key.key + MAX_KEY_LEN, key->tx_mic, TKIP_MIC_LEN);
+		peer_key.key_len += TKIP_MIC_LEN;
+	}
+	if (key->rx_mic) {
+		memcpy(peer_key.key + MAX_KEY_LEN + TKIP_MIC_LEN, key->rx_mic,
+		       TKIP_MIC_LEN);
+		peer_key.key_len += TKIP_MIC_LEN;
+	}
+	peer_key.rsc_len = 6;
+	memset(peer_key.rsc, 0, 6);
+
+	return rpu_send_cmd((unsigned char *) &peer_key,
+				    sizeof(struct cmd_setkey), RPU_CMD_SETKEY);
+}
+
+
+int rpu_prog_if_key(int vif_index,
+			    unsigned char *vif_addr,
+			    unsigned int op,
+			    unsigned int key_id,
+			    unsigned int cipher_type,
+			    struct umac_key *key)
+	{
+	struct cmd_setkey if_key;
+
+	memset(&if_key, 0, sizeof(struct cmd_setkey));
+
+	if_key.if_index = vif_index;
+	/* memcpy(if_key.vif_addr, vif_addr, 6); */
+	if_key.key_id = key_id;
+	if_key.ctrl = op;
+
+	if (op == KEY_CTRL_ADD) {
+		if_key.cipher_type = cipher_type;
+
+		if (cipher_type == CIPHER_TYPE_TKIP ||	cipher_type ==
+		    CIPHER_TYPE_CCMP) {
+			memcpy(if_key.key, key->key, MAX_KEY_LEN);
+			if_key.key_len = MAX_KEY_LEN;
+
+			if (key->tx_mic) {
+				memcpy(if_key.key + MAX_KEY_LEN, key->tx_mic,
+				       TKIP_MIC_LEN);
+				if_key.key_len += TKIP_MIC_LEN;
+			}
+		} else {
+			if_key.key_len =
+				(cipher_type == CIPHER_TYPE_WEP40) ? 5 : 13;
+			memcpy(if_key.key, key->key, if_key.key_len);
+		}
+	}
+
+	if_key.rsc_len = 6;
+	if_key.key_type = KEY_TYPE_BCAST;
+	memset(if_key.rsc, 0, 6);
+	memset(if_key.mac_addr, 0xff, 6);
+
+	return rpu_send_cmd((unsigned char *) &if_key,
+				    sizeof(struct cmd_setkey), RPU_CMD_SETKEY);
+}
+
+int rpu_prog_ba_session_data(unsigned int op,
+				     unsigned short tid,
+				     unsigned short *ssn,
+				     unsigned short ba_policy,
+				     unsigned char *vif_addr,
+				     unsigned char *peer_addr)
+{
+	struct cmd_ht_ba ba_cmd;
+	int index;
+	struct img_priv *priv;
+	struct rpu_if_data *p;
+	struct ieee80211_vif *vif = NULL;
+
+	rcu_read_lock();
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+
+	priv= p->context;
+
+	memset(&ba_cmd, 0, sizeof(struct cmd_ht_ba));
+
+	for (index = 0; index < priv->params->num_vifs; index++) {
+		if (!(priv->active_vifs & (1 << index)))
+			continue;
+
+		vif = rcu_dereference(priv->vifs[index]);
+
+		if (ether_addr_equal(vif->addr, vif_addr))
+			break;
+	}
+
+	if (index == priv->params->num_vifs) {
+		RPU_INFO_IF("no VIF found\n");
+		rcu_read_unlock();
+		return -1;
+	}
+
+	ba_cmd.if_index = index;
+	ba_cmd.op = op;
+	ba_cmd.policy = ba_policy;
+	ba_cmd.tid = tid;
+	ba_cmd.ssn = *ssn;
+	img_ether_addr_copy(ba_cmd.vif_addr, vif_addr);
+	img_ether_addr_copy(ba_cmd.peer_addr, peer_addr);
+
+	rcu_read_unlock();
+
+	return rpu_send_cmd((unsigned char *) &ba_cmd,
+				    sizeof(struct cmd_ht_ba),
+				    RPU_CMD_BA_SESSION_INFO);
+}
+
+#ifdef ENABLE_KEEP_ALIVE
+extern void rpu_send_nullframe(struct img_priv *priv);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+void keep_alive_expiry(struct timer_list *t)
+#else
+void keep_alive_expiry(unsigned long data)
+#endif
+{
+	struct rpu_if_data *p;
+	struct img_priv *priv;
+
+	rcu_read_lock();
+
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+	if (!p) {
+		//WARN_ON(1);
+		rcu_read_unlock();
+		return;
+	}
+	priv = (struct img_priv *)p->context;
+
+	RPU_DEBUG_UMACIF("%s: %p\n", __func__, priv);
+
+	if (hpriv->fw_error_processing ||
+		priv->state != STARTED) {
+		rcu_read_unlock();
+		return;
+	}
+
+	if (is_wlan_connected(priv)) {
+		RPU_DEBUG_UMACIF("%s: send null f\n", __func__);
+		rpu_send_nullframe(priv);
+
+		mod_timer(&priv->keep_alive_timer,
+				jiffies + SEND_NULL_FRAME_INTERVAL_SECONDS * HZ);
+	}
+
+	rcu_read_unlock();
+}
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+void roc_timer_expiry(struct timer_list *t)
+#else
+void roc_timer_expiry(unsigned long data)
+#endif
+{
+	struct rpu_if_data *p;
+	struct img_priv *priv;
+	struct delayed_work *work = NULL;
+
+	RPU_DEBUG_UMACIF("%s: \n", __func__);
+
+	rcu_read_lock();
+
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+	if (!p) {
+		//WARN_ON(1);
+		rcu_read_unlock();
+		return;
+	}
+
+	priv = (struct img_priv *)p->context;
+	if (priv->roc_params.roc_in_progress == 1) {
+		work = &priv->roc_complete_work;
+		ieee80211_queue_delayed_work(priv->hw,
+    				     work,
+    				     0);
+	}
+
+	rcu_read_unlock();
+}
+
+#ifdef HW_SCAN_TIMEOUT_ABORT
+extern void cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+void scan_timer_expiry(struct timer_list *t)
+#else
+void scan_timer_expiry(unsigned long data)
+#endif
+{
+	struct rpu_if_data *p;
+	struct img_priv *priv;
+
+	RPU_DEBUG_UMACIF("%s: \n", __func__);
+
+	rcu_read_lock();
+
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+	if (!p) {
+		//WARN_ON(1);
+		rcu_read_unlock();
+		return;
+	}
+
+	priv = (struct img_priv *)p->context;
+	priv->in_scan_timeout = 1;
+	cancel_hw_scan(priv->hw, NULL);
+	priv->in_scan_timeout = 0;
+
+	rcu_read_unlock();
+}
+#endif
+
+int rpu_scan(int index,
+		     struct scan_req *req)
+{
+	struct cmd_scan *scan;
+	unsigned char i;
+	struct img_priv *priv;
+	struct rpu_if_data *p;
+
+	rcu_read_lock();
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+
+	rcu_read_unlock();
+	priv = p->context;
+
+	scan = kmalloc(sizeof(struct cmd_scan) +
+		       req->ie_len, GFP_KERNEL);
+
+	if (scan == NULL) {
+		RPU_ERROR_IF("%s: Failed to allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	memset(scan, 0, sizeof(struct cmd_scan));
+
+	scan->if_index = index;
+
+	/* We support 4 SSIDs */
+	scan->n_ssids = req->n_ssids;
+	scan->n_channel = req->n_channels;
+	scan->type = priv->params->scan_type;
+
+	for (i = 0; i < scan->n_channel; i++) {
+		scan->channel_list[i] =
+			(ieee80211_frequency_to_channel(req->center_freq[i]));
+		scan->chan_max_power[i] = req->freq_max_power[i];
+
+		/* scan->chan_max_antenna_gain[i] =
+		 * req->freq_max_antenna_gain[i];
+		 */
+
+		/* In mac80211 the flags are u32 but for scanning we need
+		 * only first PASSIVE_SCAN flag, remaining flags may be used
+		 * in future.
+		 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		if (req->chan_flags[i] & IEEE80211_CHAN_NO_IR) {
+#else
+		if (req->chan_flags[i] & IEEE80211_CHAN_PASSIVE_SCAN) {
+#endif
+			scan->chan_flags[i] = PASSIVE;
+		} else {
+			scan->chan_flags[i] = ACTIVE;
+		}
+	}
+
+	scan->p2p_probe = req->p2p_probe;
+
+	scan->extra_ies_len = req->ie_len;
+
+	if (req->ie_len)
+		memcpy(scan->extra_ies, req->ie, req->ie_len);
+
+	if (req->n_ssids > 0) {
+		for (i = 0; i < scan->n_ssids; i++) {
+			scan->ssids[i].len = req->ssids[i].ssid_len;
+			if (scan->ssids[i].len > 0)
+				memcpy(scan->ssids[i].ssid, req->ssids[i].ssid,
+				       req->ssids[i].ssid_len);
+		}
+	}
+	RPU_DEBUG_SCAN("Scan request ie len = %d n_channel = %d,",
+						req->ie_len,
+						scan->n_channel);
+	RPU_DEBUG_SCAN(" n_ssids = %d, if_index = %d type = %d p2p = %d\n",
+						scan->n_ssids,
+						scan->if_index,
+						scan->type,
+						scan->p2p_probe);
+
+	for (i = 0; i < scan->n_ssids; i++) {
+		if (scan->ssids[i].len != 0)
+			RPU_DEBUG_SCAN("SSID: %s\n", scan->ssids[i].ssid);
+		else
+			RPU_DEBUG_SCAN("SSID: EMPTY\n");
+	}
+
+	RPU_DEBUG_SCAN("CHANNEL_LIST: Channel ==> Channel Flags\n");
+
+	for (i = 0; i < scan->n_channel; i++)
+		RPU_DEBUG_SCAN("Index %d: %d ==> %d\n", i,
+				scan->channel_list[i], scan->chan_flags[i]);
+
+	priv->stats->umac_scan_req++;
+
+	rpu_send_cmd((unsigned char *)scan, sizeof(struct cmd_scan) +
+			     req->ie_len, RPU_CMD_SCAN);
+	kfree(scan);
+
+	return 0;
+}
+
+
+int rpu_scan_abort(int index)
+{
+	struct cmd_scan_abort *scan_abort = NULL;
+
+	scan_abort = (struct cmd_scan_abort *)
+		kmalloc(sizeof(struct cmd_scan_abort), GFP_KERNEL);
+
+	if (scan_abort == NULL) {
+		RPU_ERROR_IF("%s: Failed to allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	memset(scan_abort, 0, sizeof(struct cmd_scan_abort));
+
+	scan_abort->if_index = index;
+
+	rpu_send_cmd((unsigned char *)scan_abort,
+			     sizeof(struct cmd_scan_abort),
+			     RPU_CMD_SCAN_ABORT);
+
+	kfree(scan_abort);
+	scan_abort = NULL;
+
+	return 0;
+}
+
+
+int rpu_prog_channel(unsigned int prim_ch,
+			     unsigned int center_freq1,
+			     unsigned int center_freq2,
+			     unsigned int ch_width,
+			     unsigned int freq_band)
+{
+	struct cmd_channel channel;
+	struct rpu_if_data *p;
+	struct img_priv *priv;
+	int ch_no1, ch_no2;
+	int err = 0;
+	unsigned int cf_offset = center_freq1;
+#ifdef SDIO_CLOCK_SWITCH
+	int hz = 50000000;
+
+	RPU_INFO_UMACIF("set ch %d\n", prim_ch);
+
+	if (of_machine_is_compatible("rockchip,rk3036") ||
+	    of_machine_is_compatible("rockchip,rk3126")) {
+		if (prim_ch == 2 || prim_ch == 3)
+			hz = 30000000;
+		else if (prim_ch == 4 || prim_ch == 5 ||
+		         prim_ch == 12 || prim_ch == 13)
+			hz = 40000000;
+	} else {
+		if (prim_ch == 7 || prim_ch == 8)
+			hz = 30000000;
+		else if (prim_ch == 9 || prim_ch == 10)
+			hz = 40000000;
+	}
+	rk915_sdio_set_clock(hpriv->io_info, hz);
+#endif
+	memset(&channel, 0, sizeof(struct cmd_channel));
+
+	rcu_read_lock();
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+	priv = p->context;
+
+	ch_no1 = ieee80211_frequency_to_channel(cf_offset);
+	ch_no2 = 0;
+
+	channel.primary_ch_number = prim_ch;
+	channel.channel_number1 = ch_no1;
+	channel.channel_number2 = ch_no2;
+
+	switch (ch_width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+	case NL80211_CHAN_WIDTH_20:
+		channel.channel_bw = RPU_CHAN_WIDTH_20_NOHT;
+		break;
+	default:
+		break;
+	}
+
+	channel.freq_band = freq_band;
+	priv->cur_chan.center_freq1 = cf_offset;
+	priv->cur_chan.center_freq2 = ch_no2;
+	priv->cur_chan.pri_chnl_num = prim_ch;
+	priv->cur_chan.ch_width  = ch_width;
+	priv->cur_chan.freq_band = freq_band;
+
+	rcu_read_unlock();
+
+	priv->chan_prog_done = 0;
+
+	err = rpu_send_cmd((unsigned char *) &channel,
+				   sizeof(struct cmd_channel),
+				   RPU_CMD_CHANNEL);
+
+
+	if (err)
+		return err;
+
+	if (wait_for_channel_prog_complete(priv))
+		return -1;
+
+	return 0;
+}
+
+
+
+
+int rpu_prog_ps_state(int index,
+			      unsigned char *vif_addr,
+			      unsigned int powersave_state)
+{
+#ifdef RPU_ENABLE_PS
+	struct cmd_ps ps_cfg;
+
+	memset(&ps_cfg, 0, sizeof(struct cmd_ps));
+	ps_cfg.mode = powersave_state;
+	ps_cfg.if_index = index;
+
+	RPU_INFO_UMACIF("%s: %pM (%s)\n", "CMD_PS",
+			vif_addr, powersave_state ? "AWAKE":"SLEEP");
+
+	return rpu_send_cmd((unsigned char *)&ps_cfg,
+				    sizeof(struct cmd_ps), RPU_CMD_PS);
+#else
+	return 0;
+#endif
+}
+
+bool rpu_is_cmd_has_data(unsigned char *data)
+{
+	struct cmd_tx_ctrl *tx_cmd = (struct cmd_tx_ctrl *)data;
+
+	if (tx_cmd->hdr.id == RPU_CMD_TX &&
+		tx_cmd->num_frames_per_desc > 0) {
+		//RPU_INFO_HAL("tx desc %d\n", tx_cmd->descriptor_id);
+		return true;
+	}
+
+	return false;
+}
+
+int rpu_send_cmd_datas(unsigned char *data, struct hal_priv *priv)
+{
+	struct cmd_tx_ctrl *tx_cmd = (struct cmd_tx_ctrl *)data;
+	unsigned int pkt = 0;
+	int ret;
+
+	for (pkt = 0; pkt < tx_cmd->num_frames_per_desc; pkt++) {
+		unsigned int pkt_len = tx_cmd->pkt_length[pkt];
+		unsigned char *pkt_data = (unsigned char *)tx_cmd->p_frame_ddr_pointer[pkt];
+		if (!pkt_data || pkt_len == 0) {
+			RPU_ERROR_TX("%s: pkt_data(%p), pkt_len(%d)\n", __func__, pkt_data, pkt_len);
+			continue;
+		}
+		RPU_DEBUG_TX("%s: sdio send: (pkt=%d) %p, %d\n",
+					 __func__, pkt, pkt_data, pkt_len);
+		dump_ieee80211_hdr_info(pkt_data, pkt_len, 1);
+		RPU_DEBUG_DUMP_HAL(" ", DUMP_PREFIX_NONE, 16, 1, pkt_data, pkt_len, 1);
+		ret = rk915_data_write(priv, 0, pkt_data, pkt_len);
+		if (ret)
+			RPU_ERROR_TX("%s: ret = %d, pkt_len = %d.\n", __func__, ret, pkt_len);
+	}
+
+	return 0;
+}
+
+void rpu_prog_tx_send(void *skb)
+{
+	spin_lock_bh(&cmd_info.control_path_lock);
+	hal_ops.send(skb, NULL, 0);
+	spin_unlock_bh(&cmd_info.control_path_lock);
+}
+
+int rpu_prog_tx(unsigned int queue,
+			unsigned int more_frms,
+			unsigned int descriptor_id,
+			bool retry)
+{
+	struct cmd_tx_ctrl *tx_cmd;
+	struct rpu_if_data *p;
+	struct img_priv *priv;
+	struct umac_vif *uvif;
+	struct sk_buff *skb, *skb_first, *tmp, *tx_cmd_skb;
+	struct sk_buff_head *txq = NULL;
+	struct ieee80211_hdr *mac_hdr;
+	struct ieee80211_tx_info *tx_info_first;
+	unsigned int hdrlen, pkt = 0, extra_copy_gram = 0;
+	int vif_index;
+	__u16 fc;
+	//dma_addr_t phy_addr;
+	struct tx_pkt_info *pkt_info = NULL;
+	unsigned int cmd_tx_size;
+	rcu_read_lock();
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+
+	priv = p->context;
+	spin_lock_bh(&priv->tx.lock);
+	txq = &priv->tx.pkt_info[descriptor_id].pkt;
+	pkt_info = &priv->tx.pkt_info[descriptor_id];
+	skb_first = skb_peek(txq);
+
+	if (!skb_first) {
+		spin_unlock_bh(&priv->tx.lock);
+		rcu_read_unlock();
+		return -10;
+	}
+
+	cmd_tx_size = sizeof(struct cmd_tx_ctrl);
+
+	tx_cmd_skb = alloc_skb(cmd_tx_size, GFP_ATOMIC);
+
+	if (!tx_cmd_skb) {
+		spin_unlock_bh(&priv->tx.lock);
+		rcu_read_unlock();
+		return -ENOMEM;
+	}
+
+	skb_put(tx_cmd_skb, cmd_tx_size);
+
+	tx_cmd = (struct cmd_tx_ctrl *)tx_cmd_skb->data;
+	memset(tx_cmd, 0, sizeof(struct cmd_tx_ctrl));
+	
+	tx_info_first = IEEE80211_SKB_CB(skb_first);
+
+	mac_hdr = (struct ieee80211_hdr *)skb_first->data;
+	fc = mac_hdr->frame_control;
+	hdrlen = ieee80211_hdrlen(fc);
+	vif_index = vif_addr_to_index(mac_hdr->addr2, priv);
+
+	/* GET The security Header Length only for data/qos-data/unicast PMF
+	 * for 11W case.
+	 */
+	if ((ieee80211_is_data(fc) ||
+	     ieee80211_is_data_qos(fc))
+	    && ieee80211_has_protected(fc)) {
+		/* hw_key == NULL: Encrypted in SW (injected frames)
+		 * iv_len = 0: treat as SW encryption.
+		 */
+		if (tx_info_first->control.hw_key == NULL ||
+		    !tx_info_first->control.hw_key->iv_len ||
+		    tx_info_first->control.hw_key->cipher == -1) {
+			RPU_DEBUG_IF("%s: hw_key is %s and iv_len: 0\n",
+			  __func__,
+			  tx_info_first->control.hw_key?"valid":"NULL");
+			tx_cmd->encrypt = ENCRYPT_DISABLE;
+		 } else {
+			RPU_DEBUG_IF("%s: cipher: %d, icv: %d",
+				  __func__,
+				  tx_info_first->control.hw_key->cipher,
+				  tx_info_first->control.hw_key->icv_len);
+			RPU_DEBUG_IF("iv: %d, key: %d\n",
+				  tx_info_first->control.hw_key->iv_len,
+				  tx_info_first->control.hw_key->keylen);
+			/* iv_len is always the header and icv_len is always
+			 * the trailer include only iv_len
+			 */
+			extra_copy_gram += tx_info_first->control.hw_key->iv_len;
+			tx_cmd->encrypt = ENCRYPT_ENABLE;
+		}
+	}
+
+
+	/* For injected frames (wlantest) hw_key is not set,as PMF uses
+	 * CCMP always so hardcode this to CCMP IV LEN 8.
+	 * For Auth3: It is completely handled in SW (mac80211).
+	 */
+	if (ieee80211_is_unicast_robust_mgmt_frame(skb_first) &&
+	    ieee80211_has_protected(fc)) {
+		extra_copy_gram += 8;
+		tx_cmd->encrypt = ENCRYPT_ENABLE;
+	}
+
+	/* separate in to up to TSF and From TSF*/
+	if (ieee80211_is_beacon(fc) || ieee80211_is_probe_resp(fc))
+		extra_copy_gram += 8; /* Timestamp*/
+
+	/* HAL Host-RPU HDR*/
+	tx_cmd->hdr.id = RPU_CMD_TX;
+	/* Keep the queue num and pool id in descriptor id */
+	tx_cmd->hdr.descriptor_id = 0;
+	tx_cmd->hdr.descriptor_id |= ((queue & 0x0000FFFF) << 16);
+	tx_cmd->hdr.descriptor_id |= (descriptor_id & 0x0000FFFF);
+	/* Not used anywhere currently */
+	tx_cmd->hdr.length = sizeof(struct cmd_tx_ctrl);
+
+	/* RPU_CMD_TX*/
+	tx_cmd->if_index = vif_index;
+	tx_cmd->queue_num = queue;
+	tx_cmd->more_frms = more_frms;
+	tx_cmd->descriptor_id = descriptor_id;
+	tx_cmd->num_frames_per_desc = skb_queue_len(txq);
+	tx_cmd->aggregate_mpdu = AMPDU_AGGR_DISABLED;
+
+	/* These extra fields will be copied to GRAM along with 
+	 * tx_cmd and 802.11 header
+	 */
+	hdrlen += extra_copy_gram;
+	memcpy(tx_cmd->config_mac_header, skb_first->data,
+	      hdrlen);
+	tx_cmd->config_mac_hdr_len = hdrlen;
+
+	priv->tx.pkt_info[descriptor_id].vif_index = vif_index;
+	priv->tx.pkt_info[descriptor_id].queue = queue;
+
+	uvif = (struct umac_vif *) (tx_info_first->control.vif->drv_priv);
+
+	if (priv->params->production_test == 1)
+		get_rate_prod(tx_cmd, priv);
+	else
+		/* Get the rate for first packet as all packets have same rate */
+		get_rate(skb_first,
+			 tx_cmd,
+			 pkt_info,
+			 retry,
+			 priv);
+
+	RPU_DEBUG_TX("%s-UMACTX: TX Frame, Queue = %d, descriptord_id = %d\n",
+		     priv->name,
+		     tx_cmd->queue_num, tx_cmd->descriptor_id);
+	RPU_DEBUG_TX("num_frames= %d qlen: %d\n",
+		     tx_cmd->num_frames_per_desc, skb_queue_len(txq));
+
+	RPU_DEBUG_TX("%s-UMACTX: Num rates = %d, %x, %x, %x, %x\n",
+		     priv->name,
+		     tx_cmd->num_rates,
+		     tx_cmd->rate[0],
+		     tx_cmd->rate[1],
+		     tx_cmd->rate[2],
+		     tx_cmd->rate[3]);
+
+	RPU_DEBUG_TX("%s-UMACTX: Retries   = %d, %d, %d, %d, %d\n",
+		  priv->name,
+		  pkt_info->max_retries,
+		  tx_cmd->rate_retries[0],
+		  tx_cmd->rate_retries[1],
+		  tx_cmd->rate_retries[2],
+		  tx_cmd->rate_retries[3]);
+
+
+	skb_queue_walk_safe(txq, skb, tmp) {
+		struct ieee80211_tx_info *tx_info;
+		unsigned char *crypto_params;
+		unsigned int mac_hdr_len;
+
+		if (!skb || (pkt > tx_cmd->num_frames_per_desc))
+			break;
+
+		tx_info = IEEE80211_SKB_CB(skb_first);
+
+		mac_hdr = (struct ieee80211_hdr *)skb->data;
+
+		/* Only for Non-Qos and MGMT frames, for Qos-Data
+		 * mac80211 handles the sequence no generation
+		 */
+		if (!retry &&
+		    tx_info->flags &
+		    IEEE80211_TX_CTL_ASSIGN_SEQ) {
+			if (tx_info->flags &
+			    IEEE80211_TX_CTL_FIRST_FRAGMENT) {
+				uvif->seq_no += 0x10;
+			}
+
+			mac_hdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);
+			mac_hdr->seq_ctrl |= cpu_to_le16(uvif->seq_no);
+		}
+
+		/* Complete packet length */
+		tx_cmd->pkt_length[pkt] = skb->len;
+
+		/*RPU_DEBUG_DUMP_TX(DUMP_PREFIX_NONE,
+				  16,
+				  1,
+				  skb->data,
+				  skb->len,
+				  1);*/
+#if 0
+		if (hal_ops.map_tx_buf(descriptor_id, pkt,
+				       skb->data, skb->len, &phy_addr)) {
+			spin_unlock_bh(&priv->tx.lock);
+			rcu_read_unlock();
+			kfree(tx_cmd_skb);
+			return -30;
+		}
+#endif
+		tx_cmd->p_frame_ddr_pointer[pkt] = (unsigned int *)skb->data;
+	//	pr_err("%s:%d phy_addr:0x%x\n",__func__,__LINE__,phy_addr);
+		crypto_params = tx_cmd->per_pkt_crypto_params[pkt];
+		memset(crypto_params, 0, PER_PKT_CRYPTO_PARAMS_SIZE);
+
+		memcpy(crypto_params + PER_PKT_CRYPTO_PARAMS_SEQ_CTRL_OFFSET,
+		       &mac_hdr->seq_ctrl,
+		       2);
+
+		if (ieee80211_is_data_qos(mac_hdr->frame_control)) {
+			struct ieee80211_qos_hdr *qos_mac_hdr;
+			unsigned char *qos_offset;
+
+			qos_offset = crypto_params +
+				     PER_PKT_CRYPTO_PARAMS_QOS_CTRL_OFFSET;
+			qos_mac_hdr = (struct ieee80211_qos_hdr *) skb->data;
+			memcpy(qos_offset,
+			       &qos_mac_hdr->qos_ctrl,
+			       2);
+		}
+
+		mac_hdr_len =  ieee80211_hdrlen(mac_hdr->frame_control);
+		if (tx_cmd->encrypt == ENCRYPT_ENABLE) {
+			unsigned char *iv_offset;
+
+			iv_offset = crypto_params +
+				    PER_PKT_CRYPTO_PARAMS_IV_OFFSET;
+
+			memcpy(iv_offset,
+			       skb->data + mac_hdr_len,
+			       tx_info->control.hw_key->iv_len);
+		}
+
+		pkt++;
+	}
+
+		/* SDK: Check if we can use the same txq initialized before in
+		 * the function here
+		 */
+		txq = &priv->tx.pkt_info[descriptor_id].pkt;
+
+		RPU_DEBUG_TX("%s:%d Sending TX_CMD\n",__func__,__LINE__);
+  		RPU_DEBUG_DUMP_TX(DUMP_PREFIX_NONE,
+				  16,
+				  1,
+				  tx_cmd_skb->data,
+				  tx_cmd_skb->len,
+				  1);
+
+#ifdef TX_CMD_SYNC_WITH_OTHER_CMD
+		rpu_send((void *)tx_cmd_skb, priv);
+#else
+		spin_lock_bh(&cmd_info.control_path_lock);
+		hal_ops.send((void *)tx_cmd_skb,
+			NULL,
+			0);
+		spin_unlock_bh(&cmd_info.control_path_lock);
+#endif
+
+		/* increment tx_cmd_send_count to keep track of number of
+		 * tx_cmd send
+		 */
+		if (queue != WLAN_AC_BCN) {
+			if (skb_queue_len(txq) == 1)
+				priv->stats->tx_cmd_send_count_single++;
+			else if (skb_queue_len(txq) > 1)
+				priv->stats->tx_cmd_send_count_multi++;
+		} else
+			priv->stats->tx_cmd_send_count_beaconq++;
+
+	spin_unlock_bh(&priv->tx.lock);
+	rcu_read_unlock();
+
+	return 0;
+}
+
+
+int rpu_prog_vif_short_slot(int index,
+				    unsigned char *vif_addr,
+				    unsigned int use_short_slot)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = SHORTSLOT_CHANGED;
+	vif_cfg.use_short_slot = use_short_slot;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+}
+
+
+int rpu_prog_vif_atim_window(int index,
+				     unsigned char *vif_addr,
+				     unsigned int atim_window)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = ATIMWINDOW_CHANGED;
+	vif_cfg.atim_window = atim_window;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+}
+
+
+int rpu_prog_long_retry(int index,
+				unsigned char *vif_addr,
+				unsigned int long_retry)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = LONGRETRY_CHANGED;
+	vif_cfg.long_retry = long_retry;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+
+}
+
+
+int rpu_prog_short_retry(int index,
+				 unsigned char *vif_addr,
+				 unsigned int short_retry)
+{
+
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = SHORTRETRY_CHANGED;
+	vif_cfg.short_retry = short_retry;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+
+
+}
+
+extern void cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+int rpu_prog_vif_basic_rates(int index,
+				     unsigned char *vif_addr,
+				     unsigned int basic_rate_set)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = BASICRATES_CHANGED;
+	vif_cfg.basic_rate_set = basic_rate_set;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+
+
+}
+
+
+int rpu_prog_vif_aid(int index,
+			     unsigned char *vif_addr,
+			     unsigned int aid)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = AID_CHANGED;
+	vif_cfg.aid = aid;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+}
+
+
+int rpu_prog_vif_op_channel(int index,
+				    unsigned char *vif_addr,
+				    unsigned char op_channel)
+{
+
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = OP_CHAN_CHANGED;
+	vif_cfg.op_channel = op_channel;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+}
+
+
+int rpu_prog_vif_conn_state(int index,
+				       unsigned char *vif_addr,
+				       unsigned int connect_state)
+{
+
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = CONNECT_STATE_CHANGED;
+	vif_cfg.connect_state = connect_state;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+}
+
+
+int rpu_prog_vif_assoc_cap(int index,
+				   unsigned char *vif_addr,
+				   unsigned int caps)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = CAPABILITY_CHANGED;
+	vif_cfg.capability = caps;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+
+}
+
+
+int rpu_prog_vif_beacon_int(int index,
+				    unsigned char *vif_addr,
+				    unsigned int bcn_int)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+
+	vif_cfg.changed_bitmap = BCN_INT_CHANGED;
+	vif_cfg.beacon_interval = bcn_int;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+}
+
+
+int rpu_prog_vif_dtim_period(int index,
+				     unsigned char *vif_addr,
+				     unsigned int dtim_period)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+
+	if (dtim_period < wifi->params.min_dtim_peroid)
+		dtim_period = wifi->params.min_dtim_peroid;
+
+	vif_cfg.changed_bitmap = DTIM_PERIOD_CHANGED;
+	vif_cfg.dtim_period = dtim_period;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+
+	RPU_INFO_IF("dtim_period = %d\n", dtim_period);
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+}
+
+
+int rpu_prog_vif_bssid(int index,
+			       unsigned char *vif_addr,
+			       unsigned char *bssid)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = BSSID_CHANGED;
+	img_ether_addr_copy(vif_cfg.bssid, bssid);
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+	vif_cfg.if_index = index;
+
+	RPU_DEBUG_IF("BSSID MAC ADDR: %pM\n", vif_cfg.bssid);
+	RPU_DEBUG_IF("VIF MAC ADDR: %pM\n", vif_cfg.vif_addr);
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+}
+
+
+int rpu_prog_vif_smps(int index,
+			      unsigned char *vif_addr,
+			      unsigned char smps_mode)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = SMPS_CHANGED;
+	vif_cfg.if_index = index;
+	img_ether_addr_copy(vif_cfg.vif_addr, vif_addr);
+
+	switch (smps_mode) {
+	case IEEE80211_SMPS_STATIC:
+		vif_cfg.smps_info |= SMPS_ENABLED;
+		break;
+	case IEEE80211_SMPS_DYNAMIC:
+		vif_cfg.smps_info |= SMPS_ENABLED;
+		vif_cfg.smps_info |= SMPS_MODE;
+		break;
+	case IEEE80211_SMPS_AUTOMATIC:/* will be one of the above*/
+	case IEEE80211_SMPS_OFF:
+		break;
+	default:
+		WARN(1, "Invalid SMPS Mode: %d\n", smps_mode);
+	}
+
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+}
+
+int rpu_prog_txq_params(int index,
+				unsigned char *addr,
+				unsigned int queue,
+				unsigned int aifs,
+				unsigned int txop,
+				unsigned int cwmin,
+				unsigned int cwmax,
+				unsigned int uapsd)
+{
+	struct cmd_txq_params params;
+
+	memset(&params, 0, (sizeof(struct cmd_txq_params)));
+
+	params.if_index = index;
+	img_ether_addr_copy(params.vif_addr, addr);
+	params.queue_num = queue;
+	params.aifsn = aifs;
+	params.txop = txop;
+	params.cwmin = cwmin;
+	params.cwmax = cwmax;
+	params.uapsd = uapsd;
+	RPU_DEBUG_IF("%s: queue=%d, aifs=%d, txop=%d, cwmin=%d, cwmax=%d, uapsd=%d\n",
+							__func__, queue, aifs, txop, cwmin, cwmax, uapsd);
+
+	return rpu_send_cmd((unsigned char *) &params,
+				    sizeof(struct cmd_txq_params),
+				    RPU_CMD_TXQ_PARAMS);
+}
+
+int rpu_prog_rcv_bcn_mode(unsigned int bcn_rcv_mode)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = RCV_BCN_MODE_CHANGED;
+	vif_cfg.bcn_mode = bcn_rcv_mode;
+
+	return rpu_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    RPU_CMD_VIF_CFG);
+
+}
+
+
+int rpu_prog_cont_tx(int val)
+{
+	struct cmd_cont_tx status;
+
+	memset(&status, 0, sizeof(struct cmd_cont_tx));
+	status.op = val;
+
+	return rpu_send_cmd((unsigned char *)&status,
+				    sizeof(struct cmd_cont_tx),
+				    RPU_CMD_CONT_TX);
+}
+
+
+
+int rpu_prog_mib_stats(void)
+{
+	struct host_rpu_msg_hdr mib_stats_cmd;
+
+	RPU_DEBUG_IF("cmd mib stats\n");
+	memset(&mib_stats_cmd, 0, sizeof(struct host_rpu_msg_hdr));
+
+	return rpu_send_cmd_without_delay((unsigned char *)&mib_stats_cmd,
+				    sizeof(struct host_rpu_msg_hdr),
+				    RPU_CMD_MIB_STATS);
+}
+
+
+
+#ifdef CONFIG_PM
+int rpu_prog_econ_ps_state(int if_index,
+				   unsigned int ps_state)
+{
+	struct cmd_ps ps_cfg;
+
+	memset(&ps_cfg, 0, sizeof(struct cmd_ps));
+	ps_cfg.mode = ps_state;
+	ps_cfg.if_index = if_index;
+
+	return rpu_send_cmd((unsigned char *)&ps_cfg,
+				    sizeof(struct cmd_ps),
+				    RPU_CMD_PS_ECON_CFG);
+}
+#endif
+
+
+int rpu_prog_pwrmgmt_pwr_on_value(unsigned int *pwr_on_values, unsigned int size) {
+	struct cmd_cfg_pwrmgmt pwrmgmt;
+	
+	memset(&pwrmgmt, 0, sizeof(struct cmd_cfg_pwrmgmt));
+
+	pwrmgmt.sleep_config_changed = PMFLAG_PWR_ON_VALUE_CHANGED;
+	memcpy(pwrmgmt.pwr_on_value, pwr_on_values, size);
+
+	return rpu_send_cmd((unsigned char *) &pwrmgmt,
+				    sizeof(struct cmd_cfg_pwrmgmt),
+				    RPU_CMD_CFG_PWRMGMT);
+}
+
+int rpu_prog_pwrmgmt_pwr_off_value(unsigned int *pwr_off_values, unsigned int size) {
+	struct cmd_cfg_pwrmgmt pwrmgmt;
+	
+	memset(&pwrmgmt, 0, sizeof(struct cmd_cfg_pwrmgmt));
+
+	pwrmgmt.sleep_config_changed = PMFLAG_PWR_OFF_VALUE_CHANGED;
+	memcpy(pwrmgmt.pwr_off_value, pwr_off_values, size);
+
+	return rpu_send_cmd((unsigned char *) &pwrmgmt,
+				    sizeof(struct cmd_cfg_pwrmgmt),
+				    RPU_CMD_CFG_PWRMGMT);
+}
+
+int rpu_prog_pwrmgmt_ram_on_state(unsigned int *ram_on_states, unsigned int size) {
+	struct cmd_cfg_pwrmgmt pwrmgmt;
+	
+	memset(&pwrmgmt, 0, sizeof(struct cmd_cfg_pwrmgmt));
+
+	pwrmgmt.sleep_config_changed = PMFLAG_RAM_ON_STATE_CHANGED;
+	memcpy(pwrmgmt.ram_on_state, ram_on_states, size);
+
+	return rpu_send_cmd((unsigned char *) &pwrmgmt,
+				    sizeof(struct cmd_cfg_pwrmgmt),
+				    RPU_CMD_CFG_PWRMGMT);
+}
+
+int rpu_prog_pwrmgmt_ram_off_state(unsigned int *ram_off_states, unsigned int size) {
+	struct cmd_cfg_pwrmgmt pwrmgmt;
+	
+	memset(&pwrmgmt, 0, sizeof(struct cmd_cfg_pwrmgmt));
+
+	pwrmgmt.sleep_config_changed = PMFLAG_RAM_OFF_STATE_CHANGED;
+	memcpy(pwrmgmt.ram_off_state, ram_off_states, size);
+
+	return rpu_send_cmd((unsigned char *) &pwrmgmt,
+				    sizeof(struct cmd_cfg_pwrmgmt),
+				    RPU_CMD_CFG_PWRMGMT);
+}
+
+int rpu_prog_pwrmgmt_pwr_on_time(unsigned int *pwr_on_times, unsigned int size) {
+	struct cmd_cfg_pwrmgmt pwrmgmt;
+	
+	memset(&pwrmgmt, 0, sizeof(struct cmd_cfg_pwrmgmt));
+
+	pwrmgmt.sleep_config_changed = PMFLAG_PWR_ON_TIME_CHANGED;
+	memcpy(pwrmgmt.pwr_on_time, pwr_on_times, size);
+
+	return rpu_send_cmd((unsigned char *) &pwrmgmt,
+				    sizeof(struct cmd_cfg_pwrmgmt),
+				    RPU_CMD_CFG_PWRMGMT);
+}
+
+int rpu_prog_pwrmgmt_pwr_off_time(unsigned int *pwr_off_times, unsigned int size) {
+	struct cmd_cfg_pwrmgmt pwrmgmt;
+	
+	memset(&pwrmgmt, 0, sizeof(struct cmd_cfg_pwrmgmt));
+
+	pwrmgmt.sleep_config_changed = PMFLAG_PWR_OFF_TIME_CHANGED;
+	memcpy(pwrmgmt.pwr_off_time, pwr_off_times, size);
+
+	return rpu_send_cmd((unsigned char *) &pwrmgmt,
+				    sizeof(struct cmd_cfg_pwrmgmt),
+				    RPU_CMD_CFG_PWRMGMT);
+}
+
+int rpu_prog_pwrmgmt_ram_on_time(unsigned int *ram_on_times, unsigned int size) {
+	struct cmd_cfg_pwrmgmt pwrmgmt;
+	
+	memset(&pwrmgmt, 0, sizeof(struct cmd_cfg_pwrmgmt));
+
+	pwrmgmt.sleep_config_changed = PMFLAG_RAM_ON_TIME_CHANGED;
+	memcpy(pwrmgmt.ram_on_time, ram_on_times, size);
+
+	return rpu_send_cmd((unsigned char *) &pwrmgmt,
+				    sizeof(struct cmd_cfg_pwrmgmt),
+				    RPU_CMD_CFG_PWRMGMT);
+}
+
+int rpu_prog_pwrmgmt_ram_off_time(unsigned int *ram_off_times, unsigned int size) {
+	struct cmd_cfg_pwrmgmt pwrmgmt;
+	
+	memset(&pwrmgmt, 0, sizeof(struct cmd_cfg_pwrmgmt));
+
+	pwrmgmt.sleep_config_changed = PMFLAG_RAM_OFF_TIME_CHANGED;
+	memcpy(pwrmgmt.ram_off_time, ram_off_times, size);
+
+	return rpu_send_cmd((unsigned char *) &pwrmgmt,
+				    sizeof(struct cmd_cfg_pwrmgmt),
+				    RPU_CMD_CFG_PWRMGMT);
+}
+
+int rpu_prog_pwrmgmt_sleep_freq(unsigned int sleep_freq) {
+	struct cmd_cfg_pwrmgmt pwrmgmt;
+	
+	memset(&pwrmgmt, 0, sizeof(struct cmd_cfg_pwrmgmt));
+
+	pwrmgmt.sleep_config_changed = PMFLAG_SLEEP_FREQ_CHANGED;
+	pwrmgmt.sleep_timer_freq_hz = sleep_freq;
+
+	return rpu_send_cmd((unsigned char *) &pwrmgmt,
+				    sizeof(struct cmd_cfg_pwrmgmt),
+				    RPU_CMD_CFG_PWRMGMT);
+}
+
+int rpu_prog_pwrmgmt_clk_adj(unsigned int clk_adj_val) {
+	struct cmd_cfg_pwrmgmt pwrmgmt;
+
+	memset(&pwrmgmt, 0, sizeof(struct cmd_cfg_pwrmgmt));
+
+	pwrmgmt.sleep_config_changed = PMFLAG_CLK_ADJ_VAL_CHANGED;
+	pwrmgmt.clk_adj_val = clk_adj_val;
+
+	return rpu_send_cmd((unsigned char *) &pwrmgmt,
+				    sizeof(struct cmd_cfg_pwrmgmt),
+				    RPU_CMD_CFG_PWRMGMT);
+}
+
+int rpu_prog_pwrmgmt_wakeup_time(unsigned int wakeup_time) {
+	struct cmd_cfg_pwrmgmt pwrmgmt;
+
+	memset(&pwrmgmt, 0, sizeof(struct cmd_cfg_pwrmgmt));
+
+	pwrmgmt.sleep_config_changed = PMFLAG_WAKEUP_TIME_CHANGED;
+	pwrmgmt.wakeup_time = wakeup_time;
+
+	return rpu_send_cmd((unsigned char *) &pwrmgmt,
+				    sizeof(struct cmd_cfg_pwrmgmt),
+				    RPU_CMD_CFG_PWRMGMT);
+}
+
+int rpu_prog_read_csr(unsigned int addr) {
+	struct cmd_read_csr readcsr;
+
+	memset(&readcsr, 0, sizeof(struct cmd_read_csr));
+
+	readcsr.addr = addr;
+
+	return rpu_send_cmd((unsigned char *) &readcsr,
+				    sizeof(struct cmd_read_csr),
+				    RPU_CMD_READ_CSR);
+}
+
+static inline void rpu_process_pending_cmd(struct img_priv *priv, int lock)
+{
+	struct sk_buff *pending_cmd;
+	struct host_rpu_msg_hdr *cmd_hdr;
+	char cmd_str[64];
+
+	if (lock)
+		spin_lock_bh(&cmd_info.control_path_lock);
+
+	if (cmd_info.outstanding_ctrl_req == 0) {
+		RPU_DEBUG_IF("RPUIF: Unexpected outstanding_ctrl_req. Ignoring and continuing.\n");
+	} else {
+		cmd_info.outstanding_ctrl_req--;
+		priv->stats->outstanding_cmd_cnt = cmd_info.outstanding_ctrl_req;
+
+		if (block_rpu_comm) {
+			if (lock)
+				spin_unlock_bh(&cmd_info.control_path_lock);
+			return;
+		}
+
+		RPU_DEBUG_IF("After DEC: outstanding cmd: %d\n",
+			     cmd_info.outstanding_ctrl_req);
+		pending_cmd = skb_dequeue(&cmd_info.outstanding_cmd);
+
+		//if (unlikely(pending_cmd != NULL)) {
+		if (likely(pending_cmd != NULL)) {
+			cmd_hdr = (struct host_rpu_msg_hdr *)pending_cmd->data;
+			convert_cmd_to_str(cmd_hdr->id, cmd_str);
+			RPU_DEBUG_IF("Send 1 outstanding cmd(%s)\n", cmd_str);
+			hal_ops.send((void *)pending_cmd, NULL, 0);
+			priv->stats->gen_cmd_send_count++;
+		}
+	}
+
+	if (lock)
+		spin_unlock_bh(&cmd_info.control_path_lock);
+}
+
+extern int rk915_download_firmware_patch_only(struct hal_priv *priv);
+
+void rpu_process_pending_operates(void)
+{
+	struct img_priv *priv = wifi->hw->priv;
+
+	cmd_info.outstanding_ctrl_req = skb_queue_len(&cmd_info.outstanding_cmd);
+	RPU_INFO_IF("%s: outstanding_ctrl_req %d\n",
+					__func__, cmd_info.outstanding_ctrl_req);
+
+	// clear pending operates, like reset cmd, channel prog
+	if (!cmd_info.outstanding_ctrl_req && !priv->reset_complete)
+		priv->reset_complete = 1;
+	if (!priv->scan_abort_done)
+		priv->scan_abort_done = 1;
+	if (!priv->cancel_hw_roc_done)
+		priv->cancel_hw_roc_done = 1;
+	if (!priv->chan_prog_done)
+		priv->chan_prog_done = 1;
+	// clear pending scan
+	if (wifi->params.hw_scan_status == HW_SCAN_STATUS_PROGRESS)
+		cancel_hw_scan(priv->hw, NULL);
+	// clear pending roc
+	if (priv->roc_params.roc_in_progress == 0 &&
+		priv->roc_params.roc_starting == 1) {
+		ieee80211_ready_on_channel(priv->hw);
+        	priv->roc_params.roc_in_progress = 1;
+	}
+	if (priv->roc_params.roc_in_progress == 1 &&
+		priv->roc_params.roc_starting == 1) {
+		//priv->roc_params.roc_starting = 0;
+		ieee80211_queue_delayed_work(priv->hw,
+					&priv->roc_complete_work,
+					0);
+	}
+	// clear pending econ ps
+	if (priv->econ_ps_cfg_stats.processing) {
+		priv->econ_ps_cfg_stats.completed = 1;
+		priv->econ_ps_cfg_stats.processing = 0;
+		priv->econ_ps_cfg_stats.result = 0;
+		rx_interrupt_status = 0;
+	}
+	// because outstanding_ctrl_req will mismatch after lpw died recovery, reset here.
+	rpu_process_pending_cmd(priv, 1);
+}
+
+int rpu_msg_handler(void *nbuff)
+{
+	unsigned int event;
+	unsigned char *buff;
+	struct host_rpu_msg_hdr *hdr;
+	//struct host_rpu_msg_hdr *cmd_hdr;
+	struct rpu_if_data *p;
+	struct sk_buff *skb = (struct sk_buff *)nbuff;
+	//struct sk_buff *pending_cmd;
+	struct img_priv *priv;
+	char event_str[64];
+	//char cmd_str[64];
+
+	rcu_read_lock();
+
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+
+	if (!p) {
+		WARN_ON(1);
+		dev_kfree_skb_any(skb);
+		rcu_read_unlock();
+		return 0;
+	}
+
+	buff = skb->data;
+	hdr = (struct host_rpu_msg_hdr *)buff;
+
+	event = hdr->id & 0xffff;
+
+	priv = (struct img_priv *)p->context;
+
+	convert_event_to_str(event, event_str);
+	RPU_DEBUG_IF("%s-RPUIF: event %d(%s) received\n", p->name, event, event_str);
+	if (event == RPU_EVENT_RESET_COMPLETE) {
+		struct host_event_reset_complete *r =
+				(struct host_event_reset_complete *)buff;
+
+		RPU_DEBUG_IF("rpu_reset_complete\n");
+
+		block_rpu_comm = false;
+		rpu_reset_complete(r->version, p->context);
+		rpu_process_pending_cmd(priv, 1);
+	} else if (event == RPU_EVENT_SCAN_ABORT_COMPLETE) {
+		priv->scan_abort_done = 1;
+#if 0//def HW_SCAN_TIMEOUT_ABORT
+		if (wifi->params.hw_scan_status == HW_SCAN_STATUS_PROGRESS)
+			cancel_hw_scan(priv->hw, NULL);
+#endif
+#ifdef CONFIG_PM
+	} else if (event == RPU_EVENT_PS_ECON_CFG_DONE) {
+		struct umac_event_ps_econ_cfg_complete *econ_cfg_complete_data =
+				(struct umac_event_ps_econ_cfg_complete *)buff;
+		priv->econ_ps_cfg_stats.completed = 1;
+		priv->econ_ps_cfg_stats.processing = 0;
+		priv->econ_ps_cfg_stats.result = econ_cfg_complete_data->status;
+		rx_interrupt_status = 0;
+	} else if (event == RPU_EVENT_PS_ECON_WAKE) {
+		struct umac_event_ps_econ_wake *econ_wake_data =
+					(struct umac_event_ps_econ_wake *)buff;
+		priv->econ_ps_cfg_stats.wake_trig = econ_wake_data->trigger;
+#endif
+	} else if (event == RPU_EVENT_SCAN_COMPLETE) {
+		rpu_scan_complete(p->context,
+			(struct host_event_scanres *) buff,
+			buff +  sizeof(struct host_event_scanres), skb->len);
+	} else if (event == RPU_EVENT_RX) {
+		if (priv->params->production_test) {
+			rpu_proc_rx_event((void*)skb, p->context);
+		} else {
+			rpu_rx_frame(skb, p->context);
+		}
+	} else if (event == RPU_EVENT_TX_DONE) {
+		if (priv->params->production_test/* &&
+		    priv->params->start_prod_mode*/)
+			rpu_proc_tx_complete((void *)buff,
+						     p->context);
+		else {
+			/* Increment tx_done_recv_count to keep track of number
+			 * of tx_done received do not count tx dones from host.
+			 */
+			priv->stats->tx_done_recv_count++;
+
+			rpu_tx_complete((void *)buff,
+						p->context);
+#ifdef TX_CMD_SYNC_WITH_OTHER_CMD		
+			rpu_process_pending_cmd(priv, 1);
+#endif
+		}
+		cmd_info.tx_done_recv_count++;
+	} else if (event == RPU_EVENT_DISCONNECTED) {
+		struct host_event_disconnect *dis =
+			(struct host_event_disconnect *)buff;
+		struct img_priv *priv = (struct img_priv *)p->context;
+		struct ieee80211_vif *vif = NULL;
+		int i = 0;
+
+		if (dis->reason_code == REASON_NW_LOST) {
+			RPU_INFO_IF("connection lost\n");
+			if (!wake_lock_active(&hpriv->fw_err_lock))
+				wake_lock_timeout(&hpriv->fw_err_lock, msecs_to_jiffies(3*1000));
+			for (i = 0; i < MAX_VIFS; i++) {
+				if (!(priv->active_vifs & (1 << i)))
+					continue;
+
+				vif = rcu_dereference(priv->vifs[i]);
+
+				if (ether_addr_equal(vif->addr,
+						     dis->mac_addr)) {
+					ieee80211_connection_loss(vif);
+					break;
+				}
+			}
+		}
+	} else if (event == RPU_EVENT_MAC_STATS) {
+		struct umac_event_mac_stats  *mac_stats =
+			(struct umac_event_mac_stats *) buff;
+
+		rpu_mac_stats(mac_stats, p->context);
+	} else if (event == RPU_EVENT_NOA) {
+		rpu_noa_event(FROM_EVENT_NOA, (void *)buff,
+				      p->context, NULL);
+
+	} else if (event == RPU_EVENT_COMMAND_PROC_DONE) {
+		/*struct host_event_command_complete *cmd =
+		 * (struct host_event_command_complete*)buff;
+		 */
+		RPU_DEBUG_IF("Received  PROC_DONE\n");
+		rpu_process_pending_cmd(priv, 1);
+	} else if (event == RPU_EVENT_CH_PROG_DONE) {
+		rpu_ch_prog_complete(event,
+			(struct umac_event_ch_prog_complete *)buff, p->context);
+		//rpu_process_pending_cmd(priv, 1);
+	} else if (event == RPU_EVENT_ROC_STATUS) {
+		struct umac_event_roc_status *roc_status = (void *)buff;
+		struct delayed_work *work = NULL;
+
+		RPU_DEBUG_ROC("%s:%d ROC status is %d\n",
+			__func__, __LINE__, roc_status->roc_status);
+
+		switch (roc_status->roc_status) {
+		case UMAC_ROC_STAT_STARTED:
+			if (priv->roc_params.roc_in_progress == 0) {
+				priv->roc_params.roc_in_progress = 1;
+				ieee80211_ready_on_channel(priv->hw);
+				RPU_DEBUG_ROC("%s-RPUIF: ROC READY..\n",
+					  priv->name);
+			}
+			break;
+		case UMAC_ROC_STAT_DONE:
+		case UMAC_ROC_STAT_STOPPED:
+			if (priv->roc_params.roc_in_progress == 1) {
+				work = &priv->roc_complete_work;
+				ieee80211_queue_delayed_work(priv->hw,
+							     work,
+							     0);
+			}
+			break;
+		}
+	} else if (event == RPU_EVENT_FW_ERROR) {
+#if defined(LPW_RECOVERY_FROM_RPU)
+		unsigned char *err_str;
+		int ret = 0;
+
+		err_str = buff + sizeof(struct host_rpu_msg_hdr);
+		RPU_ERROR_IF("%s: FW is in Error State (%s)\n", __func__, err_str);
+		if (strstr(err_str, "beacon tx without done")) {
+			rk915_signal_io_error(FW_ERR_LPW_RECOVERY);
+		} else {
+#ifdef TXRX_DATA_LOCK
+			mutex_lock(&hpriv->txrx_mutex);
+#endif
+			ret = rk915_download_firmware_patch_only(hpriv);
+#ifdef TXRX_DATA_LOCK
+			mutex_unlock(&hpriv->txrx_mutex);
+#endif
+        }
+		//if (!ret)
+			rpu_process_pending_operates();
+#else //defined(LPW_RECOVERY_FROM_RPU)
+		RPU_ERROR_IF("%s: FW is in Error State, reboot wifi.\n", __func__);
+#ifdef CONFIG_WIRELESS_EXT
+		iw_send_hang_event(priv);
+#endif
+#endif //defined(LPW_RECOVERY_FROM_RPU)
+		hpriv->lpw_error_counter++;
+	} else if (event == RPU_EVENT_BLOCK_ALL) {
+		RPU_INFO_IF("RPU_EVENT_BLOCK_ALL\n");
+		block_rpu_comm = true;
+	} else if (event == RPU_EVENT_UNBLOCK_ALL) {
+		RPU_INFO_IF("RPU_EVENT_UNBLOCK_ALL\n");
+		if (block_rpu_comm) {
+			block_rpu_comm = false;
+			rpu_process_pending_cmd(priv, 1);
+
+			rpu_unblock_all_frames(priv, 0);
+		}
+	} else if (event == RPU_EVENT_READ_CSR_CMP) {
+		struct umac_event_read_csr_complete *csr_cmp =
+			(struct umac_event_read_csr_complete *)buff;
+		priv->read_csr_value = csr_cmp->value;
+		priv->read_csr_complete = 1;
+	} else if (event == RPU_EVENT_FW_PRIV_CMD_DONE) {
+		struct fw_priv_cmd_done *info =
+				(struct fw_priv_cmd_done *)buff;
+		rpu_fw_priv_cmd_done(info, p->context);
+#ifdef SDIO_TXRX_STABILITY_TEST		
+	} else if (event == RPU_EVENT_TXRX_TEST) {
+		struct host_rpu_msg_hdr *hdr = (struct host_rpu_msg_hdr *)buff;
+		rpu_txrx_test_receive(hdr);
+#endif
+	} else {
+		RPU_ERROR_IF("%s: Unknown event received %d\n", __func__, event);
+	}
+
+	if (event != RPU_EVENT_RX)
+		dev_kfree_skb_any(skb);
+
+	rcu_read_unlock();
+
+	return 0;
+}
+
+
+int rpu_if_init(void *context, const char *name)
+{
+	struct rpu_if_data *p;
+
+	RPU_DEBUG_IF("%s-RPUIF: rpu_if init called\n", name);
+
+	p = kzalloc(sizeof(struct rpu_if_data), GFP_KERNEL);
+
+	if (!p) {
+		WARN_ON(1);
+		return -ENOMEM;
+	}
+
+	p->name = (char *)name;
+	p->context = context;
+	hal_ops.register_callback(rpu_msg_handler);
+	rcu_assign_pointer(rpu_if, p);
+	skb_queue_head_init(&cmd_info.outstanding_cmd);
+	spin_lock_init(&cmd_info.control_path_lock);
+	cmd_info.outstanding_ctrl_req = 0;
+
+	return 0;
+}
+
+
+void rpu_if_deinit(void)
+{
+	struct rpu_if_data *p;
+
+	RPU_DEBUG_IF("%s-RPUIF: Deinit called\n", rpu_if->name);
+
+	p = rcu_dereference(rpu_if);
+	rcu_assign_pointer(rpu_if, NULL);
+	synchronize_rcu();
+	kfree(p);
+}
+
+
+void rpu_if_free_outstnding(void)
+{
+
+	struct sk_buff *skb;
+
+	spin_lock_bh(&cmd_info.control_path_lock);
+
+	/* First free the outstanding commands, we are not sending
+	 * anymore commands to the FW except RESET.
+	 */
+	while ((skb = __skb_dequeue(&cmd_info.outstanding_cmd))) {
+		struct host_rpu_msg_hdr *hdr = (struct host_rpu_msg_hdr *)skb->data;
+		char cmd_str[64];
+
+		convert_cmd_to_str(hdr->id, cmd_str);
+		RPU_DEBUG_IF("%s: free outstanding command %s(%d)\n", __func__, cmd_str, hdr->id);
+		dev_kfree_skb_any(skb);
+	}
+
+	cmd_info.outstanding_ctrl_req = 0;
+
+	spin_unlock_bh(&cmd_info.control_path_lock);
+}
+
+#ifdef ENABLE_DAPT
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+void dapt_timer_expiry(struct timer_list *t)
+#else
+void dapt_timer_expiry(unsigned long data)
+#endif
+{
+	struct rpu_if_data *p;
+	struct img_priv *priv;
+
+	RPU_DEBUG_DAPT("%s\n", __func__);
+
+	rcu_read_lock();
+
+	p = (struct rpu_if_data *)(rcu_dereference(rpu_if));
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return;
+	}
+
+	priv = (struct img_priv *)p->context;
+	if (priv)
+		dapt_timer_handler(priv);
+
+	rcu_read_unlock();
+}
+#endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/rx.c b/drivers/net/wireless/rockchip_wlan/rk915/src/rx.c
new file mode 100755
index 000000000..2b7df94a1
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/rx.c
@@ -0,0 +1,875 @@
+
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include "core.h"
+#include "utils.h"
+
+struct wlan_rx_pkt rx_control_info;
+
+spinlock_t tsf_lock;
+
+#ifdef ENABLE_DAPT
+
+#define DAPT_ENABLE_SCAN
+
+#define CURRENT_CHANNEL(x) ieee80211_frequency_to_channel(x->cur_chan.center_freq1)
+
+#define INVALID_VIF_IDX(x) (x > MAX_VIFS -1)
+
+static inline bool dapt_is_ap_mode(struct img_priv *priv)
+{
+	if (priv->iftype == NL80211_IFTYPE_AP)
+		return true;
+	return false;
+}
+
+static void dapt_find_main_iface(struct img_priv *priv)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	dapt->main_index = find_main_iface(priv);
+}
+
+static void dapt_find_p2p_iface(struct img_priv *priv)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	dapt->p2p_index = find_p2p_iface(priv);
+}
+
+void dapt_start_timer(struct img_priv *priv, int msecs)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	RPU_DEBUG_DAPT("%s\n", __func__);
+
+	if (!dapt->dapt_disable) {
+		mod_timer(&dapt->dapt_timer, jiffies + msecs_to_jiffies(msecs));
+		dapt->timer_start = 1;
+	}
+}
+
+void dapt_stop_timer(struct img_priv *priv)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	RPU_DEBUG_DAPT("%s\n", __func__);
+
+	if (!dapt->dapt_disable) {
+		del_timer_sync(&dapt->dapt_timer);
+		dapt->timer_start = 0;
+	}
+}
+
+void dapt_param_init(struct img_priv *priv)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+	int i;
+
+	if (priv->params->production_test == 1)
+		return;
+
+	RPU_DEBUG_DAPT("%s\n", __func__);
+
+	memset(dapt, 0, sizeof(struct dapt_params));
+
+	for (i = 0; i < 14; i++) {
+		dapt->cur_seted_thresh[i] = DAPT_DEFAULT_PHY_THRESH;
+	}
+
+	dapt->main_index = MAX_VIFS;
+	dapt->p2p_index = MAX_VIFS;
+
+	priv->sniffer = 0;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+	timer_setup(&dapt->dapt_timer, dapt_timer_expiry, 0);
+#else
+	init_timer(&dapt->dapt_timer);
+	dapt->dapt_timer.data = (unsigned long)priv;
+	dapt->dapt_timer.function = dapt_timer_expiry;
+#endif
+
+	dapt_start_timer(priv, DAPT_CALC_INTERVAL);
+}
+
+void dapt_param_late_init(struct img_priv *priv)
+{
+	dapt_find_main_iface(priv);
+	dapt_find_p2p_iface(priv);
+}
+
+void dapt_param_deinit(struct img_priv *priv)
+{
+	if (priv->params->production_test == 1)
+		return;
+
+	RPU_DEBUG_DAPT("%s\n", __func__);
+
+	dapt_stop_timer(priv);
+}
+
+void dapt_disable(struct img_priv *priv, int disable)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	RPU_DEBUG_DAPT("%s: disable = %d\n", __func__, disable);
+
+	dapt->dapt_disable = disable;
+}
+
+void dapt_clr_history(struct img_priv *priv, int index)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	if (INVALID_VIF_IDX(index))
+		return;
+
+	dapt->sam_read[index] = 0;
+	dapt->sam_write[index] = 0;
+	dapt->sam_size[index] = 0;
+
+	dapt->bcn_read[index] = 0;
+	dapt->bcn_write[index] = 0;
+	dapt->bcn_size[index] = 0;
+}
+
+/*
+ *         read           write
+ *  |_____|_________|______|
+ *                   size
+ */
+#define SAM_STEP(x, y)						\
+	do {								\
+		x++;							\
+		x = x % y;	\
+	} while(0)
+
+static inline s8 dapt_get_sample(struct img_priv *priv, int index)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+	s8 sample;
+
+	if (INVALID_VIF_IDX(index))
+		return 0;
+
+	sample = dapt->sam_history[index][dapt->sam_read[index]];
+	SAM_STEP(dapt->sam_read[index], DAPT_MAX_RSSI_SAMPLE);
+
+	return sample;
+}
+
+static inline void dapt_set_sample(struct img_priv *priv, s8 rss, int index)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	if (INVALID_VIF_IDX(index))
+		return;
+
+	dapt->sam_history[index][dapt->sam_write[index]] = rss;
+	SAM_STEP(dapt->sam_write[index], DAPT_MAX_RSSI_SAMPLE);
+
+	dapt->sam_size[index]++;
+	if (dapt->sam_size[index] > DAPT_MAX_RSSI_SAMPLE) {
+		SAM_STEP(dapt->sam_read[index], DAPT_MAX_RSSI_SAMPLE);
+	}
+}
+
+static inline s8 dapt_get_bcn_sample(struct img_priv *priv, int index)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+	s8 sample;
+
+	if (INVALID_VIF_IDX(index))
+		return 0;
+
+	sample = dapt->bcn_history[index][dapt->bcn_read[index]];
+	SAM_STEP(dapt->bcn_read[index], DAPT_MAX_RSSI_SAMPLE);
+
+	return sample;
+}
+
+static inline void dapt_set_bcn_sample(struct img_priv *priv, s8 rss, int index)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	if (INVALID_VIF_IDX(index))
+		return;
+
+	dapt->bcn_history[index][dapt->bcn_write[index]] = rss;
+	SAM_STEP(dapt->bcn_write[index], DAPT_MAX_RSSI_SAMPLE);
+
+	dapt->bcn_size[index]++;
+	if (dapt->bcn_size[index] > DAPT_MAX_RSSI_SAMPLE) {
+		SAM_STEP(dapt->bcn_read[index], DAPT_MAX_RSSI_SAMPLE);
+	}
+}
+
+static void dapt_clr_accum(struct img_priv *priv, int index)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	if (INVALID_VIF_IDX(index))
+		return;
+
+	RPU_DEBUG_DAPT("%s\n", __func__);
+
+	dapt->thresh_accum[index] = 0;
+	dapt->avg_thresh[index] = 0;
+	dapt->new_thresh[index] = 0;
+}
+
+/*
+ * Input:
+ * phy_threshold:  current  PHY  start  threshold  in  negative  half-dB  steps  (e.g.,  180  means  -90  dBm)
+ * rss: received signal strength expressed as  the number of half-dB steps above -110 dBm (e.g., 40 means -90  dBm)
+ * adapt_thresh_offset:  the  number  of  half-dB  steps  below  rss  to  set  the  PHY  start  threshold
+ * adapt_thresh_exponent:  e  in  the  adaptation  equation  thresh(n)  =  ((2^e  C  1)/(2^e))*thresh(n-1)  + 1/(2^e)*x(n)
+ * where x(n) = (rss C adapt_thresh_offset) for Packet n
+ * Output:
+ * phy_threshold: updated PHY start threshold
+ */
+static void dapt_calc_accum(struct img_priv *priv, s8 rss, int index)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+	unsigned int update, b, c_rss;
+	int adapt_thresh_offset = priv->params->dapt_thresh_offset;
+	int adapt_thresh_exponent = priv->params->dapt_thresh_exponent;
+
+	if (INVALID_VIF_IDX(index))
+		return;
+
+	if (rss < -110)
+		rss = -110;
+
+	// convert rss from dBm
+	c_rss = (110 + rss) * 2;
+
+	if (c_rss > adapt_thresh_offset)
+		update = (c_rss - adapt_thresh_offset) << 4;
+	else
+		update = 0;
+	b = (1 << adapt_thresh_exponent) - 1;
+
+	if (!dapt->thresh_accum[index])
+		dapt->thresh_accum[index] = update << adapt_thresh_exponent;
+
+	dapt->thresh_accum[index] = b * (dapt->thresh_accum[index] >> adapt_thresh_exponent) + update;
+
+	//RPU_DEBUG_DAPT("rss = %d, c_rss = %d, update = %d, accum = %d\n",
+	//			rss, c_rss, update,
+	//			dapt->thresh_accum);
+}
+
+static void dapt_calc_new_thresh(struct img_priv *priv, int index)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+	int adapt_thresh_exponent = 4;
+
+	if (INVALID_VIF_IDX(index))
+		return;
+
+	dapt->avg_thresh[index] = dapt->thresh_accum[index] >> (adapt_thresh_exponent + 4);
+	dapt->new_thresh[index] = max((unsigned int)priv->params->dapt_thresh_min,
+				min(220 - dapt->avg_thresh[index], (unsigned int)priv->params->dapt_thresh_max));
+
+	RPU_DEBUG_DAPT("index %d: accum = %d, avg = %d, new = %d\n", index,
+				dapt->thresh_accum[index], dapt->avg_thresh[index], dapt->new_thresh[index]);
+}
+
+void dapt_save_history_thresh(struct img_priv *priv, int thresh, int channel)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	if (thresh >= dapt->last_thresh + 10 ||
+		thresh <= dapt->last_thresh - 10) {
+		RPU_DEBUG_DAPT("cur thresh = %d, last thresh = %d\n", thresh, dapt->last_thresh);
+	}
+	dapt->last_thresh = thresh;
+
+	dapt->thr_history[channel][dapt->cur_thr_offset[channel]] = thresh;
+	SAM_STEP(dapt->cur_thr_offset[channel], DAPT_SETED_PHY_THRESH_COUNT);
+}
+
+bool dapt_need_update_thresh(struct img_priv *priv, int thresh, int channel)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	if (dapt->cur_seted_thresh[channel] != thresh) {
+		return true;
+	}
+
+	return false;
+}
+
+int dapt_set_phy_thresh(struct img_priv *priv, int thresh, int ch, int set)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+	int channel;
+	int need_update = 0;
+
+	if (dapt->dapt_disable) {
+		return 0;
+	}
+
+	if (!thresh)
+		return 0;
+
+	if (set)
+		RPU_DEBUG_DAPT("%s: thresh = %d\n", __func__, thresh);
+
+#ifdef DAPT_ENABLE_SCAN
+	if (priv->params->hw_scan_status == HW_SCAN_STATUS_PROGRESS) {
+		if (thresh != DAPT_SCAN_PHY_THRESH &&
+			thresh != DAPT_NON_STA_CONN_PHY_THRESH) {
+			return 0;
+		}
+	}
+#endif
+
+	thresh = max((unsigned int)priv->params->dapt_thresh_min,
+			min((unsigned int)thresh, (unsigned int)priv->params->dapt_thresh_max));
+
+	if (ch == -1) {
+		channel = CURRENT_CHANNEL(priv);
+	} else {
+		channel = ch;
+	}
+	if (channel > 14 || channel < 1) {
+		return 0;
+	}
+
+	if (dapt_need_update_thresh(priv, thresh, channel-1)) {
+		dapt->cur_seted_thresh[channel-1] = thresh;
+		need_update = 1;
+
+		//set thresh to rpu
+		if (set)
+			rpu_prog_phy_thresh(dapt->cur_seted_thresh);
+
+		dapt_save_history_thresh(priv, thresh, channel-1);
+	}
+
+	return need_update;
+}
+
+void dapt_save_cur_thresh_all(struct img_priv *priv)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	memcpy(dapt->save_seted_thresh, dapt->cur_seted_thresh, 14*sizeof(unsigned int));
+}
+
+void dapt_restore_thresh_all(struct img_priv *priv)
+{
+	int i, need_update = 0;
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	for (i = 0; i < 14; i++) {
+		need_update += dapt_set_phy_thresh(priv, dapt->save_seted_thresh[i], i+1, 0);
+	}
+	if (need_update)
+		rpu_prog_phy_thresh(dapt->cur_seted_thresh);
+}
+
+void dapt_set_phy_thresh_all(struct img_priv *priv, int thresh)
+{
+	int i, need_update = 0;
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	for (i = 0; i < 14; i++) {
+		need_update += dapt_set_phy_thresh(priv, thresh, i+1, 0);
+	}
+	if (need_update)
+		rpu_prog_phy_thresh(dapt->cur_seted_thresh);
+}
+
+static void dapt_process(struct img_priv *priv, int index)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+	int i;
+
+	if (INVALID_VIF_IDX(index))
+		return;
+
+	RPU_DEBUG_DAPT("%s: index %d sam_size = %d\n", __func__, index, dapt->sam_size[index]);
+
+	if (dapt->dapt_disable) {
+		return;
+	}
+
+	dapt_clr_accum(priv, index);
+
+	if (dapt->sam_size[index] < DAPT_MIN_RSSI_SAMPLE) {
+		/* if no rx frames, but have lots of tx frame, like wfd source or udp tx
+		 * use beacon rssi to calculate
+		*/
+		if (dapt->bcn_size[index] >= DAPT_MIN_RSSI_SAMPLE) {
+			RPU_DEBUG_DAPT("%s: use beacon rssi sam_size = %d\n",
+					__func__, dapt->bcn_size[index]);
+			dapt->sam_size[index] = dapt->bcn_size[index];
+			dapt->sam_read[index] = dapt->bcn_read[index];
+			dapt->sam_write[index] = dapt->bcn_write[index];
+			memcpy(dapt->sam_history[index],
+					dapt->bcn_history[index], dapt->sam_size[index]);
+		} else {
+			dapt_clr_history(priv, index);
+			return;
+		}
+	}
+
+	if (dapt->sam_size[index] > DAPT_MAX_RSSI_SAMPLE)
+		dapt->sam_size[index] = DAPT_MAX_RSSI_SAMPLE;
+
+	for (i = 0; i < dapt->sam_size[index]; i++) {
+		dapt_calc_accum(priv, dapt_get_sample(priv, index), index);
+	}
+
+	dapt_clr_history(priv, index);
+
+	dapt_calc_new_thresh(priv, index);
+}
+
+void dapt_timer_handler(struct img_priv *priv)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	if (dapt->dapt_disable) {
+		return;
+	}
+
+	spin_lock_bh(&priv->dapt_lock);
+
+#ifdef DAPT_ENABLE_SCAN
+	if (priv->params->hw_scan_status == HW_SCAN_STATUS_PROGRESS) {
+		goto handle_out;
+	}
+#endif
+
+	if (INVALID_VIF_IDX(dapt->main_index) &&
+		INVALID_VIF_IDX(dapt->p2p_index))
+		goto handle_out;
+
+	dapt_process(priv, dapt->main_index);
+	dapt_process(priv, dapt->p2p_index);
+
+	if (INVALID_VIF_IDX(dapt->main_index)) {
+		dapt_set_phy_thresh(priv, dapt->new_thresh[dapt->p2p_index], -1, 1);
+		goto handle_out;
+	} else if (INVALID_VIF_IDX(dapt->p2p_index)) {
+		dapt_set_phy_thresh(priv, dapt->new_thresh[dapt->main_index], -1, 1);
+		goto handle_out;
+	}
+
+	if (!dapt->new_thresh[dapt->main_index] &&
+		!dapt->new_thresh[dapt->p2p_index]) {
+		dapt_clr_history(priv, dapt->main_index);
+		dapt_clr_history(priv, dapt->p2p_index);
+
+		dapt->both_zero_count++;
+		if (dapt->both_zero_count > 5) {
+			dapt->both_zero_count = 0;
+			RPU_DEBUG_DAPT("%s: set default thresh because of no"
+					" rx in both interface\n", __func__);
+			/*
+			* when no rx frames after connected, set back defult phy thresh
+			* this is to compatible wlan0/p2p coexit case like:
+			* 1. when wlan0 is connected with high phy thresh (like 90),
+			*     maybe hard to do p2p connect at this time because of improper phy thresh
+			* 2. when p2p0 is connected phy high thresh (like 90),
+			*     maybe hard to do wlan0 connect at this time because of improper phy thresh
+			* 3. wlan0 and p2p0 both connected, there is no rx on wlan0,
+			*     maybe block p2p throughput of improper phy thresh
+			*/
+			dapt_set_phy_thresh_all(priv, DAPT_DEFAULT_PHY_THRESH);
+		}
+	} else {
+		unsigned int new_thresh =
+				dapt->new_thresh[dapt->main_index] > dapt->new_thresh[dapt->p2p_index] ?
+				dapt->new_thresh[dapt->main_index] : dapt->new_thresh[dapt->p2p_index];
+
+		dapt->both_zero_count = 0;
+		dapt_set_phy_thresh(priv, new_thresh, -1, 1);
+	}
+
+handle_out:
+
+	dapt_start_timer(priv, DAPT_CALC_INTERVAL);
+
+	spin_unlock_bh(&priv->dapt_lock);
+}
+
+static bool dapt_is_target_frame(struct img_priv *priv, struct ieee80211_hdr *hdr)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	if (dapt->dapt_disable)
+		return false;
+
+	if (priv->sniffer)
+		return false;
+
+	if (ieee80211_is_probe_req(hdr->frame_control) ||
+		ieee80211_is_probe_resp(hdr->frame_control) ||
+		ieee80211_is_beacon(hdr->frame_control)) {
+		return false;
+	}
+
+	return true;
+}
+
+/*
+ * set defaut phy thresh when scan
+ * and stop dapt
+ */
+void dapt_scan(struct img_priv *priv)
+{
+#ifdef DAPT_ENABLE_SCAN
+	RPU_DEBUG_DAPT("%s\n", __func__);
+
+	spin_lock_bh(&priv->dapt_lock);
+
+	dapt_save_cur_thresh_all(priv);
+	if (priv->p2p_scan)
+		dapt_set_phy_thresh_all(priv, DAPT_P2P_SCAN_PHY_THRESH);
+	else
+		dapt_set_phy_thresh_all(priv, DAPT_SCAN_PHY_THRESH);
+
+	spin_unlock_bh(&priv->dapt_lock);
+#endif	
+}
+
+/* restart dapt */
+void dapt_scan_complete(struct img_priv *priv)
+{
+#ifdef DAPT_ENABLE_SCAN
+	RPU_DEBUG_DAPT("%s\n", __func__);
+
+	spin_lock_bh(&priv->dapt_lock);
+
+	dapt_restore_thresh_all(priv);
+
+	spin_unlock_bh(&priv->dapt_lock);
+#endif	
+}
+
+void dapt_notify_bssid_change(struct img_priv *priv,
+					int index,
+					unsigned char *vif_addr,
+					unsigned char *bssid)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	RPU_DEBUG_DAPT("%s: index = %d, vif_addr = %pM, bssid = %pM\n",
+			__func__, index, vif_addr, bssid);
+
+	if (INVALID_VIF_IDX(index))
+		return;
+
+	if (vif_addr)
+		memcpy(dapt->vif_addr[index], vif_addr, ETH_ALEN);
+	else
+		memset(dapt->vif_addr[index], 0, ETH_ALEN);
+	if (bssid)
+		memcpy(dapt->bssid[index], bssid, ETH_ALEN);
+	else
+		memset(dapt->bssid[index], 0, ETH_ALEN);
+}
+
+void dapt_notify_conn_state(struct img_priv *priv,
+					int index,
+					unsigned char *vif_addr,					
+					unsigned int connect_state)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	RPU_DEBUG_DAPT("%s: index = %d, vif_addr = %pM, connect_state = %s\n",
+			__func__, index, vif_addr, connect_state==STA_CONN ? "CONN":"DISCONN");
+
+	if (INVALID_VIF_IDX(index))
+		return;
+
+	memcpy(dapt->vif_addr[index], vif_addr, ETH_ALEN);
+	if (connect_state == STA_CONN) {
+		dapt->conn_state[index] = 1;
+	} else {
+		dapt->conn_state[index] = 0;
+	}
+
+	dapt_find_main_iface(priv);
+	dapt_find_p2p_iface(priv);
+	RPU_DEBUG_DAPT("%s, main_index = %d, p2p_index = %d\n", __func__, dapt->main_index, dapt->p2p_index);
+}
+
+static void dapt_rx(struct img_priv *priv, struct ieee80211_hdr * hdr)
+{
+	if (dapt_is_target_frame(priv, hdr)) {
+		int index = -1;
+		struct dapt_params *dapt = &priv->dapt_params;
+		u8 *bssid = ieee80211_get_BSSID(hdr);
+
+		//RPU_DEBUG_DAPT("BSSID: %pM, SA: %pM, DA: %pM\n",
+		//			bssid, ieee80211_get_SA(hdr), ieee80211_get_DA(hdr));
+		if (bssid) {
+			if (!INVALID_VIF_IDX(dapt->main_index)) {
+				if (ether_addr_equal(bssid, dapt->bssid[dapt->main_index]) ||
+					ether_addr_equal(bssid, dapt->vif_addr[dapt->main_index])) { // wlan0
+					index = dapt->main_index;
+				}
+			}
+			if (!INVALID_VIF_IDX(dapt->p2p_index)) {
+				if (ether_addr_equal(bssid, dapt->bssid[dapt->p2p_index]) ||
+					ether_addr_equal(bssid, dapt->vif_addr[dapt->p2p_index])) { // p2p0
+					index = dapt->p2p_index;
+				}
+			}
+
+			if (index != -1) {
+				spin_lock_bh(&priv->dapt_lock);
+				dapt_set_sample(priv, rx_control_info.rssi, index);
+				spin_unlock_bh(&priv->dapt_lock);
+			}
+		}
+	}
+}
+
+void dapt_beacon(struct img_priv *priv, s8 rssi, int index)
+{
+	struct dapt_params *dapt = &priv->dapt_params;
+
+	if (rssi >= 0)
+		return;
+
+	// there is beacon only in station or p2p GC mode
+	if (!dapt->conn_state[index])
+		return;
+
+	//if (net_ratelimit())
+	//	RPU_DEBUG_DAPT("%s: idx %d rssi %d\n", __func__, index, rssi);
+
+	spin_lock_bh(&priv->dapt_lock);
+	dapt_set_bcn_sample(priv, rssi, index);
+	spin_unlock_bh(&priv->dapt_lock);
+}
+#endif
+
+static u64 get_systime_us(void)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+	struct timespec64 ts;
+#else
+	struct timespec ts;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+	ts = ktime_to_timespec64(ktime_get_boottime());
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+	ts = ktime_to_timespec(ktime_get_boottime());
+#else
+	get_monotonic_boottime(&ts);
+#endif
+	return ((u64)ts.tv_sec * 1000000) + ts.tv_nsec / 1000;
+#else
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+	return ((u64)tv.tv_sec * 1000000) + tv.tv_usec;
+#endif
+}
+
+void rpu_add_scan_resp_timestamp(struct ieee80211_hdr *hdr)
+{
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)hdr;
+
+	if (ieee80211_is_beacon(hdr->frame_control)) {
+		mgmt->u.beacon.timestamp = cpu_to_le64(get_systime_us());
+	}
+
+	if (ieee80211_is_probe_resp(hdr->frame_control)) {
+		mgmt->u.probe_resp.timestamp = cpu_to_le64(get_systime_us());
+	}
+}
+
+void rpu_rx_frame(struct sk_buff *skb, void *context)
+{
+	struct img_priv *priv = (struct img_priv *)context;
+	struct ieee80211_hdr *hdr;
+	struct ieee80211_rx_status rx_status;
+	struct ieee80211_supported_band *band = NULL;
+	int i;
+	static unsigned int rssi_index;
+	unsigned char mic_status;
+
+	memcpy(&rx_control_info, skb->data, sizeof(struct wlan_rx_pkt));
+        /* Remove RX control information:
+         * unused more_cmd_data in RX direction is used to indicate QoS/Non-Qos
+         * frames
+         */
+        if (rx_control_info.hdr.more_cmd_data == 0) {
+                /* Non-QOS case*/
+                skb_pull(skb, sizeof(struct wlan_rx_pkt));
+        } else {
+                /* Qos Case: The RPU overwrites the 2 reserved bytes with data
+                 * to maintain the 4 byte alignment of total length and 2 byte
+                 * alignment
+                 * of starting address (as expected by mac80211).
+                 */
+                skb_pull(skb, sizeof(struct wlan_rx_pkt) - 2);
+                skb_trim(skb, skb->len - 2);
+        }
+
+	dump_ieee80211_hdr_info(skb->data, skb->len, 0);
+
+	hdr = (struct ieee80211_hdr *)skb->data;
+
+#ifdef ENABLE_DAPT
+	dapt_rx(priv, hdr);
+#endif
+
+	rpu_add_scan_resp_timestamp(hdr);
+
+	/* Stats for debugging */
+	if (ieee80211_is_data(hdr->frame_control)) {
+		priv->stats->rx_packet_data_count++;
+	} else if (ieee80211_is_mgmt(hdr->frame_control)) {
+		priv->stats->rx_packet_mgmt_count++;
+	}
+
+	memset(&rx_status, 0, sizeof(struct ieee80211_rx_status));
+
+	/* Remove this once hardware supports bip(11w) is available*/
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	if (!ieee80211_is_robust_mgmt_frame(skb))
+#else
+	if (!ieee80211_is_robust_mgmt_frame(hdr))
+#endif
+		rx_status.flag |= RX_FLAG_DECRYPTED;
+
+	rx_status.flag |= RX_FLAG_MMIC_STRIPPED;
+
+	mic_status = rx_control_info.rx_pkt_status;
+
+	if (mic_status == RX_MIC_FAILURE_TKIP) {
+		rx_status.flag |= RX_FLAG_MMIC_ERROR;
+	} else if (mic_status == RX_MIC_FAILURE_CCMP) {
+		RPU_INFO_RX("%s: Drop the Frame\n", __func__);
+		/*Drop the Frame*/
+		dev_kfree_skb_any(skb);
+		return;
+	}
+
+	if (rx_control_info.channel < 15) {
+		rx_status.band = IEEE80211_BAND_2GHZ;
+	} else {
+		WARN_ON_ONCE(1);
+		rx_status.band = IEEE80211_BAND_5GHZ;
+	}
+
+	rx_status.freq = ieee80211_channel_to_frequency(rx_control_info.channel,
+							rx_status.band);
+	rx_status.signal = rx_control_info.rssi;
+
+	/* RSSI Average for Production Mode*/
+	if (priv->params->production_test == 1) {
+		priv->params->rssi_average[rssi_index++] = (char)(rx_control_info.rssi);
+		if (rssi_index >= MAX_RSSI_SAMPLES)
+			rssi_index = 0;
+	}
+
+	rx_status.antenna = 0;
+
+#if 0
+	if (ieee80211_is_data(hdr->frame_control)) {
+		unsigned char *ccmp = (unsigned char *)hdr + ieee80211_hdrlen(hdr->frame_control);
+		unsigned char PN[8];
+		u8 *DA = ieee80211_get_DA(hdr);
+		u8 *SA = ieee80211_get_SA(hdr);
+		unsigned int txif_status;
+		unsigned int rxif_status;
+
+		memcpy(&txif_status, rx_control_info.timestamp, 4);
+		memcpy(&rxif_status, rx_control_info.timestamp + 4, 4);
+		PN[0] = ccmp[0];
+		PN[1] = ccmp[1];
+		PN[2] = ccmp[4];
+		PN[3] = ccmp[5];
+		PN[4] = ccmp[6];
+		PN[5] = ccmp[7];
+		PN[6] = 0;
+		PN[7] = 0;
+		pr_info("SA: %pM -> DA: %pM FRAG %d SEQ %d rssi %d %s txif %x rxif %x\n",
+			SA, DA, hdr->seq_ctrl&0x000F, hdr->seq_ctrl>>4, rx_status.signal,
+			ieee80211_has_retry(hdr->frame_control)?"retry":"", txif_status, rxif_status);
+	}
+#endif	
+
+	if (rx_control_info.rate_flags & ENABLE_11N_FORMAT) {
+		/* Rate */
+		if ((rx_control_info.rate_or_mcs & MARK_RATE_AS_MCS_INDEX) != 0x80) {
+			RPU_DEBUG_RX("Invalid HT MCS Information\n");
+			rx_control_info.rate_or_mcs = 0;/*default to MCS0*/
+		} else {
+			rx_status.rate_idx = (rx_control_info.rate_or_mcs & 0x7f);
+		}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+		rx_status.encoding = RX_ENC_HT;
+#else
+		rx_status.flag |= RX_FLAG_HT;
+#endif
+	} else {
+		band = priv->hw->wiphy->bands[rx_status.band];
+
+		if (!WARN_ON_ONCE(!band)) {
+			for (i = 0; i < band->n_bitrates; i++) {
+				if (rx_control_info.rate_or_mcs ==
+				    band->bitrates[i].hw_value) {
+					rx_status.rate_idx = i;
+					break;
+				}
+			}
+		} else {
+			RPU_DEBUG_DUMP_RX(" ", DUMP_PREFIX_NONE, 16, 1,
+				 &rx_control_info, sizeof(struct wlan_rx_pkt), 1);
+			RPU_INFO_RX("%s: Drop the Frame(band=%p)\n", __func__, band);
+			dev_kfree_skb_any(skb);
+			return;
+		}
+	}
+
+	if (((hdr->frame_control & IEEE80211_FCTL_FTYPE) ==
+	     IEEE80211_FTYPE_MGMT) &&
+	    ((hdr->frame_control & IEEE80211_FCTL_STYPE) ==
+	     IEEE80211_STYPE_BEACON)) {
+		rx_status.mactime = get_unaligned_le64(rx_control_info.timestamp);
+		rx_status.flag |= RX_FLAG_MACTIME_START;
+	}
+
+	RPU_DEBUG_RX(
+		      "%s-RX: RX frame, length = %d, RSSI = %d, rate = %d\n",
+		      priv->name,
+		      skb->len,
+		      rx_status.signal/*rx_control_info.rssi*/,
+		      rx_control_info.rate_or_mcs);
+
+	RPU_DEBUG_DUMP_RX(" ",
+			DUMP_PREFIX_NONE, 16, 1,
+			skb->data, (skb->len>64)?64:skb->len, 1);
+
+	memcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));
+	local_bh_disable();
+	ieee80211_rx(priv->hw, skb);
+	local_bh_enable();
+}
+
+
+
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/sdio.c b/drivers/net/wireless/rockchip_wlan/rk915/src/sdio.c
new file mode 100755
index 000000000..ca11bd559
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/sdio.c
@@ -0,0 +1,1090 @@
+/* Copyright (c) 2008 -2014 Rockchip System.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *
+ * init , call sdio_init
+ *
+ */
+#include <linux/module.h>
+#include <net/mac80211.h>
+#include <linux/time.h>
+#include <linux/pm.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/syscalls.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/rfkill-wlan.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/suspend.h>
+#include <linux/of.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/delay.h>
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sd.h>
+
+#include "core.h"
+#include "if_io.h"
+#include "sdio.h"
+//#include "fw_data.h"
+//#include "rom_patch.h"
+#include "soc.h"
+#include "hal.h"
+#include "utils.h"
+#include "platform.h"
+
+static struct semaphore powerup_sem;
+
+#define RK915_SDIO_RESCAN_COUNT 3
+
+#define MANUFACTURER_ID_EAGLE_BASE        0x5347
+#define MANUFACTURER_ID_EAGLE_BASEX       0x5348
+#define MANUFACTURER_CODE                 0x296
+
+struct sdio_func *gfunc1 = NULL;
+struct sdio_func *gfunc2 = NULL;
+
+static const struct sdio_device_id rk915_sdio_devices[] = {
+        {SDIO_DEVICE(MANUFACTURER_CODE, MANUFACTURER_ID_EAGLE_BASE)},
+	{SDIO_DEVICE(MANUFACTURER_CODE, MANUFACTURER_ID_EAGLE_BASEX)},
+        {},
+};
+
+struct device *hal_get_dev(void)
+{
+	return &gfunc1->dev;
+}
+
+//extern u32 mmc_debug_level;
+extern int sdio_reset_comm(struct mmc_card *card);
+//static unsigned char resetdata[1024];
+static bool sdio_reset;
+int _sdio_reset(struct host_io_info *host)
+{
+#if 1
+	sdio_reset = true;
+	return 0;
+#else
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+	//struct mmc_host *shost = func->card->host;
+	int ret, error, value, i;
+
+	sdio_reset = true;
+//	mmc_debug_level = 0xFFFF;
+
+	printk(" start _sdio_reset ... \n");
+	mdelay(2000);
+
+	if (sdio_reset_comm(func->card))
+		pr_err("sdio_reset_comm fail!!!\n");
+
+	sdio_claim_host(func);
+
+	ret = sdio_enable_func(func);
+	if (ret) {
+		pr_err("%s: failed to enable func, error %d\n", __func__, ret);
+		sdio_release_host(func);
+		return -1;
+	}
+
+	/* Interrupt Enable for Function x */
+	sdio_f0_writeb(func, 0x07, 0x04, &error);
+	if (error)
+		goto fail;
+
+	/* Default is GPIO interrupt, if it's "0", DATA1 interrupt */
+	sdio_f0_writeb(func, 0x80, 0x16, &error);
+	if (error)
+		goto fail;
+
+	/* Block Size for Function 0 */
+	error = sdio_set_block_size(func, 512);
+	if (error)
+		goto fail;
+
+	/* It can generate an interrupt to host */
+	sdio_writeb(func, 0x02, 34, &error);
+	if (error)
+		goto fail;
+
+	sdio_writeb(func, 0x02, 33, &error);
+	if (error)
+		goto fail;
+
+	/* clear interrupt to host */
+	value = sdio_readb(func, 32, &error);
+	if (error)
+		goto fail;
+
+	sdio_writeb(func, value, 32, &error);
+	if (error)
+		goto fail;
+
+	for (i = 0; i < 3; i++) {
+		if (sdio_memcpy_fromio(func, resetdata, 0x0000008, 462)) {
+			pr_err("sdio_memcpy_fromio fail!!!\n");
+			mdelay(3000);
+		} else {
+			pr_info("sdio_memcpy_fromio ok !\n");
+			break;
+		}
+	}
+
+	RPU_ERROR_SDIO("TX FW CRASH:\n");
+	pr_err("%s\n", resetdata);
+
+	sdio_release_host(func);
+
+	return 0;
+
+fail:
+	return -1;
+#endif	
+}
+
+#if SUPPORT_SDIO_SLEEP
+int lpw_is_ready = 0;
+static int is_sdio_sleep = 0;
+
+int sdio_clk_sleep(struct host_io_info *host, int val)
+{
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+	struct mmc_host *shost = func->card->host;
+	static int mmc_working_clk = 0;
+
+	RPU_INFO_SDIO("%s: %d\n", __func__, val);
+
+	// 1. config sdio clock for save power
+	if (val) {
+		// backup working clock, and set sdio clock to 0
+		if (shost->ios.clock > 0)
+			mmc_working_clk = shost->ios.clock;
+		shost->ios.clock = 0;
+	} else {
+		// restore sdio clock
+		shost->ios.clock = mmc_working_clk;
+	}
+	if (shost->ios.clock > shost->f_max) {
+		shost->ios.clock = shost->f_max;
+	}
+	RPU_INFO_SDIO("%s: change clock to %d\n", __func__, shost->ios.clock);
+
+	// 2. config sdio pin ctrl for save power
+#define MMC_POWER_CLK_SLEEP	10
+#define MMC_POWER_CLK_WAKEUP	11
+	shost->ios.power_mode = val?MMC_POWER_CLK_SLEEP:MMC_POWER_CLK_WAKEUP;
+	RPU_INFO_SDIO("%s: change power mode %d\n", __func__, shost->ios.power_mode);
+	shost->ops->set_ios(shost, &shost->ios);
+
+	msleep(5);
+
+	return 0;
+}
+
+// change sdio clock to zero and iomux to gpio
+static int sdio_sleep(struct host_io_info *host)
+{
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+
+	if (lpw_is_ready == 0) {
+		RPU_ERROR_SDIO("%s: LPW is not ready!\n", __func__);
+		return 0;
+	}
+
+	sdio_claim_host(func);
+
+	if (is_sdio_sleep == 0) {
+		sdio_clk_sleep(host, 1);
+		is_sdio_sleep = 1;
+	}
+
+	sdio_release_host(func);
+
+	return 0;
+}
+
+static int sdio_wakeup_unlock(struct host_io_info *host)
+{
+	if (is_sdio_sleep) {
+		sdio_clk_sleep(host, 0);
+		is_sdio_sleep = 0;
+	}
+
+	return 0;
+}
+
+static int sdio_wakeup(struct host_io_info *host)
+{
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+
+	sdio_claim_host(func);
+	sdio_wakeup_unlock(host);
+	sdio_release_host(func);
+
+	return 0;
+}
+
+#if SDIO_AUTO_SLEEP
+static void sleep_timer_expiry(struct work_struct *work)
+{
+        struct host_io_info *host =
+                container_of(work, struct host_io_info, sleep_work.work);
+
+	sdio_sleep(host);
+}
+#endif
+#endif
+
+static void sdio_lock(struct host_io_info *host)
+{
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+
+#if SDIO_AUTO_SLEEP
+	cancel_delayed_work_sync(&host->sleep_work);
+#endif
+	sdio_claim_host(func);
+#if SDIO_AUTO_SLEEP
+	sdio_wakeup_unlock(host);
+#endif
+}
+
+static void sdio_unlock(struct host_io_info *host)
+{
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+
+#if SDIO_AUTO_SLEEP
+	#define SLEEP_TIMEOUT_MS	100
+	schedule_delayed_work(&host->sleep_work, HZ/(1000/SLEEP_TIMEOUT_MS));
+#endif
+	sdio_release_host(func);
+}
+
+static int _sdio_readb(struct host_io_info *host, u32 addr)
+{
+	int val, error;
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+
+	if (sdio_reset == true)
+		return 0;
+
+	val = sdio_readb(func, addr, &error);
+
+	if (val == 0xff)
+		return error;
+	else
+		return val;
+}
+
+static int _sdio_writeb(struct host_io_info *host, u32 addr, u8 val)
+{
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+	int error;
+
+	if (sdio_reset == true)
+		return 0;
+
+	sdio_writeb(func, val, addr, &error);
+	return error;
+}
+
+static int sdio_send_data_sg(struct host_io_info *host, u32 addr, u8 *buf, u32 len)
+{
+#ifdef TX_SG_MODE
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+#endif
+	int ret = 0;
+
+	if (sdio_reset == true)
+		return 0;
+
+#ifdef TX_SG_MODE
+	ret = sdio_memcpy_toio_sg(func, addr, buf, len);
+#endif
+
+	return ret;
+}
+
+static int sdio_send_data(struct host_io_info *host, u32 addr, u8 *buf, u32 len)
+{
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+
+	if (sdio_reset == true)
+		return 0;
+
+	return sdio_memcpy_toio(func, addr, buf, len);
+}
+
+static int sdio_recv_data(struct host_io_info *host, u32 addr, u8 *buf, u32 len)
+{
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+
+	if (sdio_reset == true)
+		return 0;
+
+	return sdio_memcpy_fromio(func, buf, addr, len);
+}
+
+/*
+ * Devices that remain active during a system suspend are
+ * put back into 1-bit mode.
+ */
+static int sdio_disable_wide(struct host_io_info *host)
+{
+	int error;
+	u8 ctrl;
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+	struct mmc_host *shost = func->card->host;
+
+	if (!(func->card->host->caps & MMC_CAP_4_BIT_DATA))
+		return 0;
+
+	if (func->card->cccr.low_speed && !func->card->cccr.wide_bus)
+		return 0;
+
+	ctrl = sdio_f0_readb(func, SDIO_CCCR_IF, &error);
+	if (error)
+		return error;
+
+	if (!(ctrl & SDIO_BUS_WIDTH_4BIT))
+		return 0;
+
+	ctrl &= ~SDIO_BUS_WIDTH_4BIT;
+	ctrl |= SDIO_BUS_ASYNC_INT;
+
+	sdio_f0_writeb(func, ctrl, SDIO_CCCR_IF, &error);
+	if (error)
+		return error;
+
+	shost->ios.bus_width = MMC_BUS_WIDTH_1;
+	shost->ops->set_ios(shost, &shost->ios);
+
+	return 0;
+}
+
+static int sdio_device_init(struct host_io_info *host)
+{
+	int error;
+	unsigned char value;
+	struct sdio_func *func = (struct sdio_func *)host->priv_data;
+
+	RPU_DEBUG_SDIO("enter %s.\n", __func__);
+
+	sdio_claim_host(func);
+
+	/* Interrupt Enable for Function x */
+	sdio_f0_writeb(func, 0x07, 0x04, &error);
+	if (error)
+		goto fail;
+
+	/* Default is GPIO interrupt, if it's "0", DATA1 interrupt */
+	sdio_f0_writeb(func, 0x80, 0x16, &error);
+	if (error)
+		goto fail;
+
+	/* Block Size for Function 0 */
+	error = sdio_set_block_size(func, 512);
+	if (error)
+		goto fail;
+
+	/* It can generate an interrupt to host */
+	sdio_writeb(func, 0x02, 34, &error);
+	if (error)
+		goto fail;
+
+	sdio_writeb(func, 0x02, 33, &error);
+	if (error)
+		goto fail;
+
+	/* clear interrupt to host */
+	value = sdio_readb(func, 32, &error);
+	if (error)
+		goto fail;
+
+	sdio_writeb(func, value, 32, &error);
+	if (error)
+		goto fail;
+
+	sdio_release_host(func);
+#if SUPPORT_SDIO_SLEEP
+	lpw_is_ready = 1;
+#endif
+	return 0;
+
+fail:
+	sdio_release_host(func);
+	return error;
+}
+
+static int sdio_writeb_comp(struct host_io_info *host)
+{
+	int val;
+	int onetime = 1; // us
+	int count = 500*1000; // wait total (onetime*count) ms
+
+	while (count--) {
+		if (hpriv->fw_error_processing)
+			return -1;
+
+		val = _sdio_readb(host, SDIO_HOST_WRITE_REQ_INT_STA);
+		if (val == 0) {
+			//RPU_INFO_SDIO("%s: %d\n", __func__, count);
+			return 0; // success
+		} else if (val < 0) {
+			RPU_ERROR_SDIO("%s: error %d\n", __func__, val);
+			return -1;
+		}
+		udelay(onetime);
+		//RPU_INFO_SDIO("count = %d, val = %d\n", count, val);
+	}
+
+	RPU_ERROR_SDIO("%s: timeout val = %d\n", __func__, val);
+	return -1; // wait timeout failed
+}
+
+static int sdio_notify_fw_pm(struct host_io_info *host, int wakeup)
+{
+#if NOTIFY_M0_SLEEP
+	int msg = wakeup?IO_NOTIFY_WAKEUP:IO_NOTIFY_SLEEP;
+
+	RPU_INFO_SDIO("notify m0 %s\n", wakeup?"wakeup":"sleep");
+	_sdio_writeb(host, IO_NOTIFY_ADDR, msg);
+	return sdio_writeb_comp(host);
+#else
+	return 0;
+#endif
+}
+
+static struct host_io_ops sdio_host_ops = {
+	.io_init			= sdio_device_init,
+	.io_send			= sdio_send_data,
+	.io_send_sg			= sdio_send_data_sg,
+	.io_recv			= sdio_recv_data,
+	.lock				= sdio_lock,
+	.unlock				= sdio_unlock,
+	.io_readb			= _sdio_readb,
+	.io_writeb			= _sdio_writeb,
+	.io_writeb_comp		= sdio_writeb_comp,
+	.io_ejtag			= sdio_disable_wide,
+	.io_reset			= _sdio_reset,
+	.io_notify_pm		= sdio_notify_fw_pm,
+#if SUPPORT_SDIO_SLEEP
+	.sleep				= sdio_sleep,
+	.wakeup				= sdio_wakeup,
+#endif
+};
+
+static int add_rk915_device(struct sdio_func *func)
+{
+	int ret = -1;
+
+	RPU_INFO_SDIO("%s.\n", __func__);
+
+	hpriv->plat_dev = platform_device_alloc("rk915", -1);
+	if (!hpriv->plat_dev) {
+		RPU_ERROR_SDIO("%s: can't allocate platform_device\n", __func__);
+		goto err;
+	}
+
+	hpriv->plat_dev->dev.parent = &func->dev;
+
+	ret = platform_device_add(hpriv->plat_dev);
+	if (ret) {
+		RPU_ERROR_SDIO("%s: can't add platform_device\n", __func__);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	if (hpriv->plat_dev) {
+		platform_device_put(hpriv->plat_dev);
+	}
+	return ret;
+}
+
+static void del_rk915_device(void)
+{
+	RPU_INFO_SDIO("%s.\n", __func__);
+
+	platform_device_unregister(hpriv->plat_dev);
+	hpriv->plat_dev = NULL;
+}
+
+static int sdio_probe(struct sdio_func *func, const struct sdio_device_id *id)
+{
+	int ret = 0;
+
+	RPU_DEBUG_SDIO("%s.\n", __func__);
+	RPU_DEBUG_SDIO("sdio_func_num: 0x%X, vendor id: 0x%X, dev id: 0x%X, block size: 0x%X/0x%X\n",
+			func->num, func->vendor, func->device, func->max_blksize, func->cur_blksize);
+
+	if (func->num == 1)
+		gfunc1 = func;
+	else
+		gfunc2 = func;
+
+	RPU_INFO_SDIO("f1: 0x%p, f2: 0x%p.\n", gfunc1, gfunc2);
+	if (!(gfunc1 && gfunc2)) {
+		RPU_DEBUG_SDIO("%s: no valid func\n", __func__);
+		return 0;
+	}
+
+	sdio_claim_host(gfunc1);
+	ret = sdio_enable_func(gfunc1);
+	if (ret) {
+		RPU_ERROR_SDIO("%s: failed to enable func, error %d\n", __func__, ret);
+		sdio_release_host(gfunc1);
+		return -1;
+	}
+	RPU_INFO_SDIO("%s: enable func ok.\n", __func__);
+	sdio_release_host(gfunc1);
+
+	gfunc1->card->quirks |= MMC_QUIRK_LENIENT_FN0;
+	sdio_reset = false;
+
+	up(&powerup_sem);
+
+	return ret;
+}
+
+static void sdio_remove(struct sdio_func *func) 
+{
+	if (hpriv->plat_dev &&
+		hpriv->plat_dev->dev.parent == &func->dev) {
+		del_rk915_device();
+	}
+	gfunc1 = NULL;
+	gfunc2 = NULL;
+}
+
+#define dev_to_sdio_func(d)	container_of(d, struct sdio_func, dev)
+
+#ifdef CONFIG_PM
+static int sdio_suspend(struct device *dev)
+{
+	int ret = 0;
+	mmc_pm_flag_t sdio_flags;
+	struct sdio_func *func = dev_to_sdio_func(dev);
+
+	if ((void*)func != hpriv->io_info->priv_data) {
+		RPU_DEBUG_SDIO("%s: is not rk915 sdio, skip it!\n", __func__);
+		return 0;
+	}
+
+	RPU_INFO_SDIO("%s enter\n", __func__);
+
+	sdio_flags = sdio_get_host_pm_caps(func);
+	if (!(sdio_flags & MMC_PM_KEEP_POWER)) {
+		dev_err(dev, "can't keep power while host "
+						"is suspended\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* keep power while host suspended */
+	ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+	if (ret) {
+		dev_err(dev, "error while trying to keep power\n");
+		goto out;
+	}
+
+	hpriv->during_pm_resume = 1;
+
+#if SUPPORT_SDIO_SLEEP
+	// change sdio clock to zero and iomux to gpio.
+	sdio_sleep(hpriv->io_info);
+#endif
+	// disable interrupt
+	// disable_irq(hpriv->io_info->irq);
+
+out:
+	return ret;
+}
+
+static int sdio_resume(struct device *dev)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+
+	if ((void*)func != hpriv->io_info->priv_data) {
+		RPU_DEBUG_SDIO("%s: is not rk915 sdio, skip it!\n", __func__);
+		return 0;
+	}
+
+	RPU_INFO_SDIO("%s enter\n", __func__);
+
+	hpriv->during_pm_resume = 1;
+	// enable_irq(hpriv->io_info->irq);
+
+#if SUPPORT_SDIO_SLEEP
+	// change sdio clock to last clk
+	sdio_wakeup(hpriv->io_info);
+#endif
+
+	return 0;
+}
+
+static const struct dev_pm_ops sdio_pm_ops = {
+	.suspend = sdio_suspend,
+	.resume  = sdio_resume,
+};
+#endif
+
+static struct sdio_driver rk915_sdio_driver = {
+		.name = "rk915_sdio",
+		.id_table = rk915_sdio_devices,
+		.probe = sdio_probe,
+		.remove = sdio_remove,
+#ifdef CONFIG_PM		
+		.drv = {
+			.pm = &sdio_pm_ops,
+		}
+#endif
+};
+
+int rk915_sdio_register_driver(void)
+{
+	return sdio_register_driver(&rk915_sdio_driver);
+}
+
+void rk915_sdio_unregister_driver(void)
+{
+	sdio_unregister_driver(&rk915_sdio_driver);
+}
+
+void rk915_sdio_pre_init(void)
+{
+    sema_init(&powerup_sem, 0);
+}
+
+int rk915_sdio_init(struct host_io_info *phost)
+{
+	int retry;
+	struct host_io_info *host = phost;
+
+//	mmc_debug_level = 0;
+
+	retry = RK915_SDIO_RESCAN_COUNT;
+
+reinit:
+    if (!gfunc1) {
+    	/* power up and rescan */
+    	rk915_poweron();
+    	mdelay(200);
+    	rk915_rescan_card(1);
+
+    	if (down_timeout(&powerup_sem, msecs_to_jiffies(800))) {
+    		rk915_rescan_card(0);
+    		rk915_poweroff();
+    		mdelay(200);
+
+    		if (retry == 0)
+    			goto fail;
+
+    		RPU_ERROR_SDIO("rk915 sdio probe failed, retry (%d)\n", retry);
+    		retry--;
+    		goto reinit;
+    	}
+    }
+
+	RPU_DEBUG_SDIO("%s rk915 sdio probe success\n", __func__);
+
+	host->priv_data = (void *)gfunc1;
+	host->dev = &gfunc1->dev;
+
+	host->io_ops = &sdio_host_ops;
+	host->irq = rockchip_wifi_get_oob_irq();
+#if SDIO_AUTO_SLEEP
+	// init delay sleep worker
+	INIT_DELAYED_WORK(&host->sleep_work, sleep_timer_expiry);
+#endif
+	phost->bus_init = true;
+
+	add_rk915_device(gfunc1);
+
+	return 0;
+
+fail:
+	return -1;
+}
+
+int rk915_sdio_deinit(struct host_io_info *phost)
+{
+	rk915_rescan_card(0);
+	rk915_poweroff();
+
+	phost->bus_init = false;
+
+	return 0;
+}
+
+#ifdef ENABLE_FW_ERROR_RECOVERY
+static int rk915_mmc_io_rw_direct_host(struct mmc_host *host, int write, unsigned fn,
+	unsigned addr, u8 in, u8 *out)
+{
+	struct mmc_command cmd = {0};
+	int err;
+
+	/* sanity check */
+	if (addr & ~0x1FFFF)
+		return -EINVAL;
+
+	cmd.opcode = SD_IO_RW_DIRECT;
+	cmd.arg = write ? 0x80000000 : 0x00000000;
+	cmd.arg |= fn << 28;
+	cmd.arg |= (write && out) ? 0x08000000 : 0x00000000;
+	cmd.arg |= addr << 9;
+	cmd.arg |= in;
+	cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+	if (err)
+		return err;
+
+	{
+		if (cmd.resp[0] & R5_ERROR)
+			return -EIO;
+		if (cmd.resp[0] & R5_FUNCTION_NUMBER)
+			return -EINVAL;
+		if (cmd.resp[0] & R5_OUT_OF_RANGE)
+			return -ERANGE;
+	}
+
+	if (out) {
+		*out = cmd.resp[0] & 0xFF;
+	}
+
+	return 0;
+}
+
+static int rk915_mmc_select_card(struct mmc_host *host, struct mmc_card *card)
+{
+	int err;
+	struct mmc_command cmd = {0};
+
+	cmd.opcode = MMC_SELECT_CARD;
+
+	if (card) {
+		cmd.arg = card->rca << 16;
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+	} else {
+		cmd.arg = 0;
+		cmd.flags = MMC_RSP_NONE | MMC_CMD_AC;
+	}
+
+	err = mmc_wait_for_cmd(host, &cmd, 3);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int rk915_sdio_reset(struct mmc_card *card)
+{
+	int ret;
+	u8 abort;
+
+	ret = rk915_mmc_io_rw_direct_host(card->host, 0, 0, SDIO_CCCR_ABORT, 0, &abort);
+	if (ret)
+		abort = 0x08;
+	else
+		abort |= 0x08;
+
+	ret = rk915_mmc_io_rw_direct_host(card->host, 1, 0, SDIO_CCCR_ABORT, abort, NULL);
+	return ret;
+}
+
+static int rk915_mmc_go_idle(struct mmc_host *host)
+{
+	int err;
+	struct mmc_command cmd = {0};
+
+	cmd.opcode = MMC_GO_IDLE_STATE;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_NONE | MMC_CMD_BC;
+
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+
+	mdelay(1);
+
+	host->use_spi_crc = 0;
+
+	return err;
+}
+
+int rk915_mmc_send_io_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
+{
+	struct mmc_command cmd = {0};
+	int i, err = 0;
+
+	cmd.opcode = SD_IO_SEND_OP_COND;
+	cmd.arg = ocr;
+	cmd.flags = MMC_RSP_SPI_R4 | MMC_RSP_R4 | MMC_CMD_BCR;
+
+	for (i = 100; i; i--) {
+		err = mmc_wait_for_cmd(host, &cmd, 3);
+		if (err)
+			break;
+
+		/* if we're just probing, do a single pass */
+		if (ocr == 0)
+			break;
+
+		/* otherwise wait until reset completes */
+		{
+			if (cmd.resp[0] & MMC_CARD_BUSY)
+				break;
+		}
+
+		err = -ETIMEDOUT;
+
+		mdelay(10);
+	}
+
+	return err;
+}
+
+int rk915_mmc_send_relative_addr(struct mmc_host *host, unsigned int *rca)
+{
+	int err;
+	struct mmc_command cmd = {0};
+
+	cmd.opcode = SD_SEND_RELATIVE_ADDR;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_R6 | MMC_CMD_BCR;
+
+	err = mmc_wait_for_cmd(host, &cmd, 3);
+	if (err)
+		return err;
+
+	*rca = cmd.resp[0] >> 16;
+
+	return 0;
+}
+
+static int rk915_mmc_sdio_switch_hs(struct mmc_card *card, int enable)
+{
+	int ret;
+	u8 speed;
+
+	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
+		return 0;
+
+	if (!card->cccr.high_speed)
+		return 0;
+
+	ret = rk915_mmc_io_rw_direct_host(card->host, 0, 0, SDIO_CCCR_SPEED, 0, &speed);
+	if (ret)
+		return ret;
+
+	if (enable)
+		speed |= SDIO_SPEED_EHS;
+	else
+		speed &= ~SDIO_SPEED_EHS;
+
+	ret = rk915_mmc_io_rw_direct_host(card->host, 1, 0, SDIO_CCCR_SPEED, speed, NULL);
+	if (ret)
+		return ret;
+
+	return 1;
+}
+
+static int rk915_sdio_enable_hs(struct mmc_card *card)
+{
+	int ret;
+
+	ret = rk915_mmc_sdio_switch_hs(card, true);
+	/*if (ret <= 0 || card->type == MMC_TYPE_SDIO)
+		return ret;
+
+	ret = mmc_sd_switch_hs(card);
+	if (ret <= 0)
+		mmc_sdio_switch_hs(card, false);*/
+
+	return ret;
+}
+
+static int rk915_sdio_enable_wide(struct mmc_card *card)
+{
+	int ret;
+	u8 ctrl;
+
+	if (!(card->host->caps & MMC_CAP_4_BIT_DATA))
+		return 0;
+
+	if (card->cccr.low_speed && !card->cccr.wide_bus)
+		return 0;
+
+	ret = rk915_mmc_io_rw_direct_host(card->host, 0, 0, SDIO_CCCR_IF, 0, &ctrl);
+	if (ret)
+		return ret;
+
+	/* set as 4-bit bus width */
+	ctrl &= ~SDIO_BUS_WIDTH_MASK;
+	ctrl |= SDIO_BUS_WIDTH_4BIT;
+
+	ret = rk915_mmc_io_rw_direct_host(card->host, 1, 0, SDIO_CCCR_IF, ctrl, NULL);
+	if (ret)
+		return ret;
+
+	return 1;
+}
+
+static int rk915_sdio_enable_4bit_bus(struct mmc_card *card)
+{
+	return rk915_sdio_enable_wide(card);
+}
+
+static void rk915_mmc_power_up(struct mmc_host *host, u32 ocr)
+{
+
+	host->ios.chip_select = MMC_CS_DONTCARE;
+	host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
+	host->ios.power_mode = MMC_POWER_UP;
+	host->ios.bus_width = MMC_BUS_WIDTH_1;
+	host->ios.timing = MMC_TIMING_LEGACY;
+	host->ops->set_ios(host, &host->ios);
+
+	mdelay(10);
+
+	host->ios.clock = host->f_init;
+
+	host->ios.power_mode = MMC_POWER_ON;
+	host->ops->set_ios(host, &host->ios);
+
+	mdelay(10);
+}
+
+static void rk915_mmc_set_clock(struct mmc_host *host, unsigned int hz)
+{
+	if (hz > host->f_max)
+		hz = host->f_max;
+
+	host->ios.clock = hz;
+	host->ops->set_ios(host, &host->ios);
+}
+
+static void rk915_mmc_set_bus_width(struct mmc_host *host, unsigned int width)
+{
+	host->ios.bus_width = width;
+	host->ops->set_ios(host, &host->ios);
+}
+
+
+void rk915_sdio_set_clock(struct host_io_info *phost, int hz)
+{
+	struct sdio_func *func = (struct sdio_func *)phost->priv_data;
+	struct mmc_host *shost = func->card->host;
+
+	sdio_claim_host(func);
+	rk915_mmc_set_clock(shost, hz);
+	sdio_release_host(func);
+}
+
+int rk915_sdio_recovery_init(struct host_io_info *phost)
+{
+	struct sdio_func *func = (struct sdio_func *)phost->priv_data;
+	struct mmc_host *shost = func->card->host;
+	int err;
+	u32 rocr, ocr, rca;
+
+	RPU_DEBUG_ROCOVERY("%s\n", __func__);
+
+	sdio_claim_host(func);
+
+	shost->ios.power_mode = MMC_POWER_OFF;
+	rk915_mmc_power_up(shost, 1);
+
+	err = rk915_sdio_reset(func->card);
+	/*if (err) {
+		RPU_ERROR_ROCOVERY("rk915_sdio_reset failed (%d)\n", err);
+		goto err_out;
+	}*/
+
+	err = rk915_mmc_go_idle(shost);
+	if (err) {
+		RPU_ERROR_ROCOVERY("rk915_mmc_go_idle failed (%d)\n", err);
+		goto err_out;
+	}
+
+	ocr = 0;
+	err = rk915_mmc_send_io_op_cond(shost, ocr, &rocr);
+	if (err) {
+		RPU_ERROR_ROCOVERY("rk915_mmc_send_io_op_cond1 failed (%d)\n", err);
+		goto err_out;
+	}
+
+	ocr = 0x1800000;
+	err = rk915_mmc_send_io_op_cond(shost, ocr, &rocr);
+	if (err) {
+		RPU_ERROR_ROCOVERY("rk915_mmc_send_io_op_cond2 failed (%d)\n", err);
+		goto err_out;
+	}
+
+	err = rk915_mmc_send_relative_addr(shost, &rca);
+	if (err) {
+		RPU_ERROR_ROCOVERY("rk915_mmc_send_relative_addr failed (%d)\n", err);
+		goto err_out;
+	}
+
+	err = rk915_mmc_select_card(shost, func->card);
+	if (err) {
+		RPU_ERROR_ROCOVERY("rk915_mmc_select_card failed (%d)\n", err);
+		goto err_out;
+	}
+
+	err = rk915_sdio_enable_hs(func->card);
+	if (err <= 0) {
+		RPU_ERROR_ROCOVERY("rk915_sdio_enable_hs failed (%d)\n", err);
+		goto err_out;
+	}
+
+	rk915_mmc_set_clock(shost, 50000000);
+
+	err = rk915_sdio_enable_4bit_bus(func->card);
+	if (err > 0) {
+		rk915_mmc_set_bus_width(shost, MMC_BUS_WIDTH_4);
+	} else {
+		RPU_ERROR_ROCOVERY("rk915_sdio_enable_4bit_bus failed (%d)\n", err);
+		goto err_out;
+	}
+
+	err = sdio_set_block_size(func, 512);
+	if (err) {
+		RPU_ERROR_ROCOVERY("sdio_set_block_size failed (%d)\n", err);
+		goto err_out;
+	}
+
+	err = sdio_enable_func(func);
+	if (err) {
+		RPU_ERROR_ROCOVERY("sdio_enable_func failed (%d)\n", err);
+		goto err_out;
+	}
+
+	sdio_reset = false;
+
+err_out:
+	sdio_release_host(func);
+	return err;
+}
+#else
+int rk915_sdio_recovery_init(struct host_io_info *phost)
+{
+	return 0;
+}
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/soc.c b/drivers/net/wireless/rockchip_wlan/rk915/src/soc.c
new file mode 100755
index 000000000..fac97268b
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/soc.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include "core.h"
+#include "soc.h"
+
+void program_rpu_dma_start(struct hal_priv *priv) 
+{
+	return;
+}
+
+void clock_init(struct hal_priv *priv)
+{
+	return;
+}
+void clock_deinit(struct hal_priv *priv)
+{
+	return;
+}
+
+
+
+int parse_dtb_config (struct hal_priv *priv)
+{
+	return 0;
+}
+
+
+
+void config_mem_region(unsigned int addr)
+{
+
+}
+
+struct soc_ops_tag soc_ops = {
+	.program_rpu_dma_start = program_rpu_dma_start,
+	.parse_dtb = parse_dtb_config,
+	.clock_init = clock_init,
+	.clock_deinit = clock_deinit,
+	.set_mem_region = config_mem_region,
+};
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/tx.c b/drivers/net/wireless/rockchip_wlan/rk915/src/tx.c
new file mode 100755
index 000000000..022c4884f
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/tx.c
@@ -0,0 +1,1401 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include "core.h"
+#include "utils.h"
+
+#define TX_TO_MACDEV(x) ((struct img_priv *) \
+			 (container_of(x, struct img_priv, tx)))
+
+#ifdef STA_AP_COEXIST
+static int find_ie(u8 *frame, int len, int ie, int ie_start)
+{
+	int offset = 0;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)frame;
+
+	offset += ieee80211_hdrlen(hdr->frame_control);
+	offset += ie_start;
+	while(offset < len) {
+		if (frame[offset] == ie) {
+			return offset;
+		}
+		offset += frame[offset+1] + 2;
+	}
+
+	return 0;
+}
+
+static void change_channel(u8 *frame, int len, int ch, u8 ie_id)
+{
+	int offset;
+	
+	offset = find_ie(frame, len, ie_id, 12);
+	if (offset)
+		frame[offset + 2] = ch;
+}
+
+static void adjust_beacon_ie(struct img_priv *priv, struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+    
+	if (ieee80211_is_beacon(hdr->frame_control) ||
+	    ieee80211_is_probe_resp(hdr->frame_control)) {
+		// change the channel of DSPS IE
+		change_channel(skb->data, skb->len, priv->pri_chnl_num, 0x3);
+		// change the Primary Channel in HT Info
+		change_channel(skb->data, skb->len, priv->pri_chnl_num, 0x3d);
+	}
+}
+#endif
+
+void rpu_unblock_all_frames(struct img_priv *priv,
+					    int ch_id)
+{
+	int txq_len = 0;
+	int i = 0, cnt = 0;
+	int queue = 0;
+	int curr_bit = 0;
+	int pool_id = 0;
+	int ret = 0;
+	int start_ac, end_ac;
+	unsigned int pkts_pend = 0;
+	struct tx_config *tx = NULL;
+	struct sk_buff_head *txq = NULL;
+
+	tx = &priv->tx;
+
+	for (i = 0; i < NUM_ACS; i++) {
+		if (tx->queue_stopped_bmp & (1 << i))
+		{
+			ieee80211_wake_queue(priv->hw, tx_queue_unmap(i));
+			tx->queue_stopped_bmp &= ~(1 << (i));
+		}
+	}
+
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		spin_lock_bh(&tx->lock);
+
+		curr_bit = (i % TX_DESC_BUCKET_BOUND);
+		pool_id = (i / TX_DESC_BUCKET_BOUND);
+
+		if (test_and_set_bit(curr_bit, &tx->buf_pool_bmp[pool_id])) {
+			spin_unlock_bh(&tx->lock);
+			continue;
+		}
+
+		txq = &tx->pkt_info[i].pkt;
+		txq_len = skb_queue_len(txq);
+
+		/* Not valid when txq len is 0 */
+		queue = tx->pkt_info[i].queue;
+
+		if (!txq_len) {
+			/* Reserved token */
+			if (i < (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
+				queue = (i % NUM_ACS);
+				start_ac = end_ac = queue;
+			} else {
+				/* Spare token:
+				 * Loop through all AC's
+				 */
+				start_ac = WLAN_AC_VO;
+				end_ac = WLAN_AC_BK;
+			}
+
+			for (cnt = start_ac; cnt >= end_ac; cnt--) {
+				pkts_pend = rpu_tx_proc_pend_frms(priv,
+									  cnt,
+									  i);
+				if (pkts_pend) {
+					queue = cnt;
+					break;
+				}
+			}
+
+			if (pkts_pend == 0) {
+				__clear_bit(curr_bit,
+					    &tx->buf_pool_bmp[pool_id]);
+				spin_unlock_bh(&tx->lock);
+				continue;
+			}
+		}
+
+		tx->outstanding_tokens[queue]++;
+		spin_unlock_bh(&tx->lock);
+
+		ret = __rpu_tx_frame(priv,
+					     queue,
+					     i,
+					     0,
+					     0); /* TODO: Currently sending 0
+						  * since this param is not used
+						  * as expected in the orig
+						  * code for multiple frames etc
+						  * Need to set this
+						  * properly when the orig code
+						  * logic is corrected
+						  */
+		if (ret < 0) {
+			RPU_ERROR_TX("%s: Queueing of TX frame to FW failed\n",
+			       __func__);
+		}
+	}
+}
+
+static void wait_for_tx_complete(struct tx_config *tx)
+{
+	int count = 0;
+	struct img_priv *priv = TX_TO_MACDEV(tx);
+
+	/*if (priv->fw_error)
+		return;*/
+
+	/* Find_last_bit: Returns the bit number of the first set bit,
+	 * or size.
+	 */
+	while (find_last_bit(tx->buf_pool_bmp,
+			     NUM_TX_DESCS) != NUM_TX_DESCS) {
+		count++;
+
+		if (count < TX_COMPLETE_TIMEOUT_TICKS) {
+			current->state = TASK_INTERRUPTIBLE;
+			schedule_timeout(1);
+		} else {
+			RPU_DEBUG_TX("%s-UMACTX:WARNING: ", priv->name);
+			RPU_DEBUG_TX("TX complete failed!!\n");
+			RPU_DEBUG_TX("%s-UMACTX:After ", priv->name);
+			RPU_DEBUG_TX("%ld: bitmap is: 0x%lx\n",
+			       TX_COMPLETE_TIMEOUT_TICKS,
+			       tx->buf_pool_bmp[0]);
+			break;
+		}
+	}
+
+	if (count && (count < TX_COMPLETE_TIMEOUT_TICKS)) {
+		RPU_DEBUG_TX("%s-UMACTX:TX complete after %d timer ticks\n",
+			priv->name, count);
+	}
+}
+
+int tx_queue_map(int queue)
+{
+	unsigned int ac[4] = {WLAN_AC_VO, WLAN_AC_VI, WLAN_AC_BE, WLAN_AC_BK};
+	//unsigned int ac[4] = {WLAN_AC_VO, WLAN_AC_VO, WLAN_AC_VO, WLAN_AC_VO};
+
+	if (queue < 4)
+		return ac[queue];
+
+	return WLAN_AC_VO;
+}
+
+int tx_queue_unmap(int queue)
+{
+	unsigned int ac[4] = {3, 2, 1, 0};
+
+	return ac[queue];
+}
+
+
+static int check_80211_aggregation(struct img_priv *priv,
+				struct sk_buff *skb,
+				struct sk_buff *skb_first)
+{
+
+	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *mac_hdr = NULL, *mac_hdr_first = NULL;
+	//struct sk_buff *skb_first;
+	//struct sk_buff_head *pend_pkt_q = NULL;
+	//struct tx_config *tx = &priv->tx;
+	bool ampdu = false, is_qos = false, addr = true;
+
+	mac_hdr = (struct ieee80211_hdr *)skb->data;
+	//pend_pkt_q = &tx->pending_pkt[peer_id][ac];
+	//skb_first = skb_peek(pend_pkt_q);
+	if (skb_first)
+		mac_hdr_first = (struct ieee80211_hdr *)skb_first->data;
+
+	ampdu = (tx_info->flags & IEEE80211_TX_CTL_AMPDU) ? true : false;
+	is_qos = ieee80211_is_data_qos(mac_hdr->frame_control);
+
+	/* RPU has a limitation, it expects A1-A2-A3 to be same
+	* for all MPDU's within an AMPDU. This is a temporary
+	* solution, remove it when RPU has fix for this.
+	*/
+	if (skb_first &&
+	    ((!ether_addr_equal(mac_hdr->addr1,
+		       mac_hdr_first->addr1)) ||
+	    (!ether_addr_equal(mac_hdr->addr2,
+		       mac_hdr_first->addr2)) ||
+	    (!ether_addr_equal(mac_hdr->addr3,
+		       mac_hdr_first->addr3)))) {
+		addr = false;
+	}
+
+	/*stats and debug*/
+	if (!is_qos) {
+		RPU_DEBUG_TX("Not Qos\n");
+		priv->stats->tx_noagg_not_qos++;
+	} else if (!ampdu) {
+		RPU_DEBUG_TX("Not AMPDU\n");
+		priv->stats->tx_noagg_not_ampdu++;
+	} else if (!addr) {
+		if (skb_first) {
+			RPU_DEBUG_TX("first: A1: %pM-A2:%pM -A3%pM not same\n",
+				      mac_hdr_first->addr1,
+				      mac_hdr_first->addr2,
+				      mac_hdr_first->addr3);
+			RPU_DEBUG_TX("curr:  A1: %pM-A2:%pM -A3%pM not same\n",
+				      mac_hdr->addr1,
+				      mac_hdr->addr2,
+				      mac_hdr->addr3);
+		}
+		priv->stats->tx_noagg_not_addr++;
+	}
+
+	return (ampdu && is_qos && addr);
+}
+
+
+static void tx_status(struct sk_buff *skb,
+		      struct umac_event_tx_done *tx_done,
+		      unsigned int frame_idx,
+		      struct img_priv *priv,
+		      struct ieee80211_tx_info tx_info_1st_mpdu)
+{
+	int index, i;
+	char idx = 0;
+	struct ieee80211_tx_rate *txrate;
+	struct ieee80211_tx_rate *tx_inf_rate = NULL;
+	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
+	int tx_fixed_mcs_idx = 0;
+	int tx_fixed_rate = 0;
+	struct ieee80211_supported_band *band = NULL;
+	struct umac_vif *uvif = NULL;
+	int ret = 0;
+
+	uvif = (struct umac_vif *)(tx_info->control.vif->drv_priv);
+
+	/*Just inform ma8c0211, it will free the skb*/
+	if (tx_done->frm_status[frame_idx] == TX_DONE_STAT_DISCARD) {
+		ieee80211_free_txskb(priv->hw, skb);
+		priv->stats->tx_dones_to_stack++;
+		return;
+	}
+
+	/* Rate info will be retained, except the count*/
+	ieee80211_tx_info_clear_status(tx_info);
+
+	if (tx_done->retries_num[frame_idx] > 0) {
+		//RPU_INFO_TX("retries_num[%d] %d\n", frame_idx, tx_done->retries_num[frame_idx]);
+		priv->tx_retry_frm_cnt++;
+	}
+
+	if (tx_done->frm_status[frame_idx] == TX_DONE_STAT_SUCCESS)
+		tx_info->flags |= IEEE80211_TX_STAT_ACK;
+	else if (tx_info->flags & IEEE80211_TX_CTL_AMPDU)
+		tx_info->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;
+
+	tx_info->flags &= ~IEEE80211_TX_STAT_AMPDU;
+	tx_info->flags &= ~IEEE80211_TX_CTL_AMPDU;
+
+	band = priv->hw->wiphy->bands[tx_info->band];
+
+	for (index = 0; index < 4; index++) {
+		tx_inf_rate = &tx_info->status.rates[index];
+
+		/* Populate tx_info based on 1st MPDU in an AMPDU */
+		txrate = (&tx_info_1st_mpdu.control.rates[index]);
+
+		if (txrate->idx < 0)
+			break;
+
+		if ((priv->params->production_test == 1) &&
+		    ((priv->params->tx_fixed_mcs_indx != -1) ||
+		     (priv->params->tx_fixed_rate != -1))) {
+			tx_fixed_mcs_idx = priv->params->tx_fixed_mcs_indx;
+			tx_fixed_rate = priv->params->tx_fixed_rate;
+
+			/* This index is always zero */
+			/* TODO: See if we need to send channel bw information
+			 * taken from proc, since in Production mode the bw
+			 * advised by Minstrel can be overwritten by proc
+			 * settings
+			 */
+			tx_inf_rate->flags = txrate->flags;
+
+			if (tx_fixed_mcs_idx != -1) {
+				if (priv->params->prod_mode_rate_flag & ENABLE_11N_FORMAT) {
+					tx_inf_rate->flags |=
+						IEEE80211_TX_RC_MCS;
+					/* So that actual sent rate is seen in
+					 * sniffer
+					 */
+					idx = tx_done->rate[frame_idx] & 0x7F;
+					tx_inf_rate->idx = idx;
+				} else 
+				if (tx_fixed_rate != -1) {
+					for (i = 0; i < band->n_bitrates; i++) {
+						if ((band->bitrates[i]).hw_value ==
+						    tx_done->rate[frame_idx])
+							tx_inf_rate->idx = i;
+					}
+				}
+			}
+
+			tx_inf_rate->count = (tx_done->retries_num[frame_idx] +
+					      1);
+			break;
+		}
+
+		if ((tx_done->rate[frame_idx] &
+		     MARK_RATE_AS_MCS_INDEX) == 0x80) {
+			if ((txrate->flags & IEEE80211_TX_RC_MCS) &&
+				   ((tx_done->rate[frame_idx] & 0x7F) ==
+				    (txrate->idx & 0x7F))) {
+				tx_inf_rate->count =
+					(tx_done->retries_num[frame_idx] + 1);
+			}
+
+			break;
+		} else if (tx_done->rate[frame_idx] ==
+			   (band->bitrates[tx_inf_rate->idx]).hw_value) {
+			tx_inf_rate->count =
+				(tx_done->retries_num[frame_idx] + 1);
+
+			break;
+		}
+	}
+
+	/* Invalidate the remaining indices */
+	while (((index + 1) < 4)) {
+		tx_info->status.rates[index + 1].idx = -1;
+		tx_info->status.rates[index + 1].count = 0;
+		index++;
+	}
+
+	if (((tx_info->flags & IEEE80211_TX_CTL_TX_OFFCHAN)
+	    ) &&
+	    (atomic_dec_return(&priv->roc_params.roc_mgmt_tx_count) == 0)) {
+		RPU_DEBUG_ROC("%s:%d TXDONE Frame: %d\n",
+			__func__,
+			__LINE__,
+			atomic_read(&priv->roc_params.roc_mgmt_tx_count));
+		if (priv->roc_params.roc_in_progress &&
+		    priv->roc_params.roc_type == ROC_TYPE_OFFCHANNEL_TX) {
+			CALL_RPU(rpu_prog_roc, ROC_STOP, 0, 0, 0);
+			RPU_DEBUG_ROC("%s:%d", __func__, __LINE__);
+			RPU_DEBUG_ROC("all offchan pending frames cleared\n");
+		}
+	}
+
+	priv->stats->tx_dones_to_stack++;
+
+	ieee80211_tx_status(priv->hw, skb);
+prog_rpu_fail:
+	return;
+}
+
+
+int get_token(struct img_priv *priv,
+		     int queue)
+{
+	int cnt = 0;
+	int curr_bit = 0;
+	int pool_id = 0;
+	int token_id = NUM_TX_DESCS;
+	struct tx_config *tx = &priv->tx;
+
+	/* First search for a reserved token */
+	for (cnt = 0; cnt < NUM_TX_DESCS_PER_AC; cnt++) {
+		curr_bit = ((queue + (NUM_ACS * cnt)) % TX_DESC_BUCKET_BOUND);
+		pool_id = ((queue + (NUM_ACS * cnt)) / TX_DESC_BUCKET_BOUND);
+
+		if (!test_and_set_bit(curr_bit, &tx->buf_pool_bmp[pool_id])) {
+			token_id = queue + (NUM_ACS * cnt);
+			tx->outstanding_tokens[queue]++;
+			break;
+		}
+	}
+
+	/* If reserved token is not found search for a spare token
+	 * (only for non beacon queues)
+	 */
+	if ((cnt == NUM_TX_DESCS_PER_AC) && (queue != WLAN_AC_BCN)) {
+		for (token_id = NUM_TX_DESCS_PER_AC * NUM_ACS;
+		     token_id < NUM_TX_DESCS;
+		     token_id++) {
+			curr_bit = (token_id % TX_DESC_BUCKET_BOUND);
+			pool_id = (token_id / TX_DESC_BUCKET_BOUND);
+			if (!test_and_set_bit(curr_bit,
+					      &tx->buf_pool_bmp[pool_id])) {
+				tx->outstanding_tokens[queue]++;
+				break;
+			}
+		}
+	}
+
+	tx->tx_desc_had_send_to_io[token_id] = 0;
+
+	return token_id;
+}
+
+void free_token(struct img_priv *priv,
+		int token_id,
+		int queue)
+{
+	struct tx_config *tx = &priv->tx;
+	int bit = -1;
+	int pool_id = -1;
+	int test = 0;
+	unsigned int old_token = tx->outstanding_tokens[queue];
+
+	//if (old_token <= 0)
+	//	return;
+
+	bit = (token_id % TX_DESC_BUCKET_BOUND);
+	pool_id = (token_id / TX_DESC_BUCKET_BOUND);
+
+	__clear_bit(bit, &tx->buf_pool_bmp[pool_id]);
+	tx->outstanding_pkts[token_id] = 0;
+	tx->tx_desc_had_send_to_io[token_id] = 0;
+
+	if (tx->outstanding_tokens[queue] != 0)
+		tx->outstanding_tokens[queue]--;
+
+	test = tx->outstanding_tokens[queue];
+	if (WARN_ON_ONCE(test < 0 || test > 4)) {
+		RPU_ERROR_TX("%s: invalid outstanding_tokens: %d, old:%d\n",
+			      __func__,
+			      test,
+			      old_token);
+	}
+}
+
+
+struct curr_peer_info get_curr_peer_opp(struct img_priv *priv,
+					int ac)
+{
+	unsigned int curr_peer_opp = 0;
+	unsigned int curr_vif_op_chan = UMAC_VIF_CHANCTX_TYPE_OPER;
+	unsigned int i = 0;
+	struct tx_config *tx = NULL;
+	unsigned int init_peer_opp = 0;
+	struct curr_peer_info peer_info;
+	unsigned int pend_q_len;
+	struct sk_buff_head *pend_q = NULL;
+
+	tx = &priv->tx;
+
+	init_peer_opp = tx->curr_peer_opp[ac];
+	/*TODO: Optimize this loop for BCN_Q
+	 */
+	for (i = 0; i < MAX_PEND_Q_PER_AC; i++) {
+		curr_peer_opp = (init_peer_opp + i) % MAX_PEND_Q_PER_AC;
+
+		pend_q = &tx->pending_pkt[curr_peer_opp][ac];
+		pend_q_len = skb_queue_len(pend_q);
+
+		if (pend_q_len) {
+			tx->curr_peer_opp[ac] =
+				(curr_peer_opp + 1) % MAX_PEND_Q_PER_AC;
+			break;
+		}
+	}
+
+	if (i == MAX_PEND_Q_PER_AC) {
+		peer_info.id = -1;
+		peer_info.op_chan_idx = -1;
+	} else {
+		peer_info.id = curr_peer_opp;
+		peer_info.op_chan_idx = curr_vif_op_chan;
+		RPU_DEBUG_TX("%s: Queue: %d Peer: %d op_chan: %d ",
+			__func__,
+			ac,
+			curr_peer_opp,
+			curr_vif_op_chan);
+		RPU_DEBUG_TX("Pending: %d\n",
+			pend_q_len);
+	}
+
+	return peer_info;
+}
+
+static int get_outstanding_pkts(struct tx_config *tx, int token_id)
+{
+	int i, count = 0;
+	int bit = -1;
+	int pool_id = -1;
+
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		if (i == token_id)
+			continue;
+
+		bit = (i % TX_DESC_BUCKET_BOUND);
+		pool_id = (i / TX_DESC_BUCKET_BOUND);
+		if (test_bit(bit, &tx->buf_pool_bmp[pool_id])) {
+			//RPU_DEBUG_TX("%s: outstanding_pkts[%d] = %d\n",
+			//	__func__, i, tx->outstanding_pkts[i]);
+			count += tx->outstanding_pkts[i];
+		}
+	}
+	if (count >= MAX_FW_TX_PKGS) {
+		RPU_INFO_TX("%s: count(%d), reached MAX_FW_TX_PKGS(%d) (%d)\n",
+					__func__, count, MAX_FW_TX_PKGS, token_id);
+		count = MAX_FW_TX_PKGS;
+	}
+	return count;
+}
+
+int rpu_tx_proc_pend_frms(struct img_priv *priv,
+				  int ac,
+				  int token_id)
+{
+	struct tx_config *tx = &priv->tx;
+	unsigned long ampdu_len = 0;
+	struct sk_buff *loop_skb = NULL;
+	struct sk_buff *tmp = NULL;
+	struct ieee80211_hdr *mac_hdr = NULL;
+	struct ieee80211_tx_info *tx_info = NULL;
+	struct umac_vif *uvif = NULL;
+	struct ieee80211_vif *ivif = NULL;
+	unsigned char *data = NULL;
+	unsigned int max_tx_cmds = priv->params->max_tx_cmds, fw_free_pkts;
+	struct sk_buff_head *txq = NULL;
+	struct sk_buff_head *pend_pkt_q = NULL;
+	unsigned int total_pending_processed = 0;
+	int pend_pkt_q_len = 0;
+	struct curr_peer_info peer_info;
+	int loop_cnt = 0;
+	struct tx_pkt_info *pkt_info = NULL;
+	struct sk_buff *skb_first;
+
+	if (block_rpu_comm) {
+		RPU_INFO_TX("%s: skip with block_rpu_comm\n", __func__);
+		return 0;
+	}
+
+	peer_info = get_curr_peer_opp(priv,
+				       ac);
+
+	/* No pending frames for any peer in that AC.
+	 */
+	if (peer_info.id == -1)
+		return 0;
+
+	pend_pkt_q = &tx->pending_pkt[peer_info.id][ac];
+
+	pkt_info = &priv->tx.pkt_info[token_id];
+	txq = &pkt_info->pkt;
+
+#if 0
+	fw_free_pkts = max_tx_cmds;
+#else
+	fw_free_pkts = MAX_FW_TX_PKGS - get_outstanding_pkts(tx, token_id);
+	if (fw_free_pkts == 0 && token_id != WLAN_AC_BCN) {
+		return 0;
+	}
+#endif
+
+	/* Aggregate Only MPDU's with same RA, same Rate,
+	 * same Rate flags, same Tx Info flags
+	 */
+	skb_first = skb_peek(pend_pkt_q);
+	skb_queue_walk_safe(pend_pkt_q,
+			    loop_skb,
+			    tmp) {
+		data = loop_skb->data;
+		mac_hdr = (struct ieee80211_hdr *)data;
+
+		tx_info = IEEE80211_SKB_CB(loop_skb);
+
+		ivif = tx_info->control.vif;
+		uvif = (struct umac_vif *)(ivif->drv_priv);
+
+		ampdu_len += loop_skb->len;
+
+		if (!check_80211_aggregation(priv,
+					     loop_skb,
+					     skb_first) ||
+		    (skb_queue_len(txq) >= max_tx_cmds) ||
+		    (skb_queue_len(txq) >= fw_free_pkts)) {
+			break;
+		}
+		loop_cnt++;
+		__skb_unlink(loop_skb, pend_pkt_q);
+		skb_queue_tail(txq, loop_skb);
+	}
+
+	/* If our criterion rejects all pending frames, or
+	 * pend_q is empty, send only 1
+	 */
+	if (!skb_queue_len(txq))
+		skb_queue_tail(txq, skb_dequeue(pend_pkt_q));
+
+	total_pending_processed = skb_queue_len(txq);
+	tx->outstanding_pkts[token_id] = total_pending_processed;
+
+	pend_pkt_q_len = skb_queue_len(pend_pkt_q);
+	if ((ac != WLAN_AC_BCN) &&
+	    (tx->queue_stopped_bmp & (1 << ac)) &&
+	    pend_pkt_q_len < (MAX_TX_QUEUE_LEN / 2)) {
+		ieee80211_wake_queue(priv->hw, tx_queue_unmap(ac));
+		tx->queue_stopped_bmp &= ~(1 << (ac));
+	}
+
+	pkt_info->peer_id = peer_info.id;
+	RPU_DEBUG_TX("%s-UMACTX: token_id: %d ",
+				priv->name,
+				token_id);
+	RPU_DEBUG_TX("total_pending_packets_process: %d\n",
+		skb_queue_len(txq));
+
+	return total_pending_processed;
+}
+
+
+int rpu_tx_alloc_token(struct img_priv *priv,
+			       int ac,
+			       int peer_id,
+			       struct sk_buff *skb)
+{
+	int token_id = NUM_TX_DESCS;
+	struct tx_config *tx = &priv->tx;
+	struct sk_buff_head *pend_pkt_q = NULL;
+	unsigned int pkts_pend = 0;
+	struct ieee80211_tx_info *tx_info;
+	struct sk_buff *skb_first;
+
+	spin_lock_bh(&tx->lock);
+	pend_pkt_q = &tx->pending_pkt[peer_id][ac];
+	RPU_DEBUG_TX("%s-UMACTX:Alloc buf Req q = %d\n",
+		      priv->name,
+		      ac);
+	RPU_DEBUG_TX("peerid: %d,\n", peer_id);
+
+	/* Queue the frame to the pending frames queue */
+	skb_queue_tail(pend_pkt_q, skb);
+
+	tx_info = IEEE80211_SKB_CB(skb);
+
+	if (tx->outstanding_tokens[ac] >= NUM_TX_DESCS_PER_AC) {
+		bool agg_status = false;
+
+		skb_first = skb_peek(pend_pkt_q);
+		agg_status = check_80211_aggregation(priv,
+						     skb,
+						     skb_first);
+
+		if (agg_status || !priv->params->enable_early_agg_checks) {
+			int max_cmds = priv->params->max_tx_cmds;
+
+			/* encourage aggregation to the max size
+			 * supported (priv->params->max_tx_cmds)
+			 */
+			if (skb_queue_len(pend_pkt_q) < max_cmds) {
+				RPU_DEBUG_TX("pend_q not full out_tok:%d\n",
+					      tx->outstanding_tokens[ac]);
+				goto out;
+			 } else {
+				RPU_DEBUG_TX("pend_q full out_tok:%d\n",
+					      tx->outstanding_tokens[ac]);
+			}
+		}
+	}
+
+	/* Take steps to stop the TX traffic if we have reached
+	 * the queueing limit.
+	 * We dont this for the ROC queue to avoid the case where we are in the
+	 * OFF channel but there is lot of traffic for the operating channel on
+	 * the shared ROC queue (which is VO right now), since this would block
+	 * ROC traffic too.
+	 */
+	if (skb_queue_len(pend_pkt_q) >= MAX_TX_QUEUE_LEN) {
+		if ((!priv->roc_params.roc_in_progress) ||
+		    (priv->roc_params.roc_in_progress &&
+		     (ac != UMAC_ROC_AC))) {
+			ieee80211_stop_queue(priv->hw,
+					     skb->queue_mapping);
+			tx->queue_stopped_bmp |= (1 << ac);
+		}
+	}
+
+	token_id = get_token(priv,
+			     ac);
+
+	RPU_DEBUG_TX("%s-UMACTX:Alloc buf Result *id= %d q = %d out_tok: %d",
+					priv->name,
+					token_id,
+					ac, tx->outstanding_tokens[ac]);
+	RPU_DEBUG_TX(", peerid: %d,\n", peer_id);
+
+	if (token_id == NUM_TX_DESCS)
+		goto out;
+
+	pkts_pend = rpu_tx_proc_pend_frms(priv,
+						  ac,
+						  token_id);
+
+	/* We have just added a frame to pending_q but channel context is
+	 * mismatch.
+	 */
+
+	if (!pkts_pend) {
+		free_token(priv, token_id, ac);
+		token_id = NUM_TX_DESCS;
+	}
+
+out:
+	spin_unlock_bh(&tx->lock);
+
+	RPU_DEBUG_TX("%s-UMACTX:Alloc buf Result *id= %d out_tok:%d\n",
+					priv->name,
+					token_id, tx->outstanding_tokens[ac]);
+	/* If token is available, just return tokenid, list will be sent*/
+	return token_id;
+}
+
+
+
+int rpu_tx_free_buff_req(struct img_priv *priv,
+				 struct umac_event_tx_done *tx_done,
+				 unsigned char *ac,
+				 int *vif_index_bitmap)
+{
+	int i = 0;
+	unsigned int pkts_pend = 0;
+	struct tx_config *tx = &priv->tx;
+	struct ieee80211_hdr *mac_hdr;
+	struct ieee80211_tx_info *tx_info_bcn;
+	struct ieee80211_tx_info tx_info_1st_mpdu;
+	struct sk_buff *skb, *tmp, *skb_first = NULL;
+	struct sk_buff_head *skb_list, tx_done_list;
+	int vif_index = -1;
+	unsigned int pkt = 0;
+	int cnt = 0;
+	unsigned int desc_id = tx_done->descriptor_id;
+	struct umac_vif *uvif = NULL;
+	struct ieee80211_vif *ivif = NULL;
+	unsigned long bcn_int = 0;
+	int start_ac, end_ac;
+
+	skb_queue_head_init(&tx_done_list);
+
+	spin_lock_bh(&tx->lock);
+
+	RPU_DEBUG_TX("%s-UMACTX:Free buf Req q = %d",
+				priv->name,
+				tx_done->queue);
+	RPU_DEBUG_TX(", desc_id: %d out_tok: %d\n",
+				desc_id,
+				priv->tx.outstanding_tokens[tx_done->queue]);
+
+
+	/* Defer Tx Done Processsing */
+	skb_list = &priv->tx.pkt_info[desc_id].pkt;
+
+	if (skb_queue_len(skb_list)) {
+		/* Cut the list to new one, tx_pkt will be re-initialized */
+		skb_queue_splice_tail_init(skb_list, &tx_done_list);
+	} else {
+		RPU_DEBUG_TX("%s-UMACTX:Got Empty List: list_addr: %p\n",
+						priv->name,
+						skb_list);
+	}
+
+	tx->outstanding_pkts[desc_id] = 0;
+	tx->tx_desc_had_send_to_io[desc_id] = 0;
+
+	/* Reserved token */
+	if (desc_id < (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
+		start_ac = end_ac = tx_done->queue;
+	} else {
+		/* Spare token:
+		 * Loop through all AC's
+		 */
+		start_ac = WLAN_AC_VO;
+		end_ac = WLAN_AC_BK;
+	}
+	for (cnt = start_ac; cnt >= end_ac; cnt--) {
+		pkts_pend = rpu_tx_proc_pend_frms(priv,
+					      cnt,
+					      desc_id);
+
+		if (pkts_pend) {
+			*ac = cnt;
+			/* Spare Token Case*/
+			if (tx_done->queue != *ac) {
+				/*Adjust the counters*/
+				tx->outstanding_tokens[tx_done->queue]--;
+				tx->outstanding_tokens[*ac]++;
+			}
+			break;
+		}
+	}
+
+	/* Unmap here before release lock to avoid race */
+	if (skb_queue_len(&tx_done_list)) {
+		skb_queue_walk_safe(&tx_done_list, skb, tmp) {
+			hal_ops.unmap_tx_buf(tx_done->descriptor_id, pkt);
+			RPU_DEBUG_TX("%s-UMACTX:TXDONE: ID=%d",
+				priv->name,
+				tx_done->descriptor_id);
+			RPU_DEBUG_TX("Stat=%d (%d, %d)\n",
+				tx_done->frm_status[pkt],
+				tx_done->rate[pkt],
+				tx_done->retries_num[pkt]);
+
+			pkt++;
+		}
+	}
+
+	if (!pkts_pend) {
+		/* Mark the token as available */
+		free_token(priv, desc_id, tx_done->queue);
+	}
+
+	/* Unlock: Give a chance for Tx to add to pending lists */
+	spin_unlock_bh(&tx->lock);
+
+	/* Protection from mac80211 _ops especially stop */
+	if (priv->state != STARTED)
+		goto out;
+
+	if (!skb_queue_len(&tx_done_list))
+		goto out;
+
+	skb_first = skb_peek(&tx_done_list);
+
+	memcpy(&tx_info_1st_mpdu,
+	       (struct ieee80211_tx_info *)IEEE80211_SKB_CB(skb_first),
+	       sizeof(struct ieee80211_tx_info));
+
+	pkt = 0;
+
+	skb_queue_walk_safe(&tx_done_list, skb, tmp) {
+		__skb_unlink(skb, &tx_done_list);
+
+		if (!skb)
+			continue;
+		/* In the Tx path we move the .11hdr from skb to CMD_TX
+		 * Hence pushing it here, not required for loopback case
+		 */
+		skb_push(skb,
+			 priv->tx.pkt_info[tx_done->descriptor_id].hdr_len);
+		mac_hdr = (struct ieee80211_hdr *)(skb->data);
+
+		if (!ieee80211_is_beacon(mac_hdr->frame_control)) {
+			vif_index = vif_addr_to_index(mac_hdr->addr2,
+						      priv);
+			if (vif_index > -1)
+				*vif_index_bitmap |= (1 << vif_index);
+
+			/* Same Rate info for all packets */
+			tx_status(skb,
+				  tx_done,
+				  pkt,
+				  priv,
+				  tx_info_1st_mpdu);
+		} else {
+			struct ieee80211_bss_conf *bss_conf;
+			bool bcn_status;
+
+			if (tx_done->frm_status[pkt] ==
+			    TX_DONE_STAT_DISCARD_BCN) {
+				/* We did not send beacon */
+				priv->tx_last_beacon = 0;
+			} else if (tx_done->frm_status[pkt] ==
+				   TX_DONE_STAT_SUCCESS) {
+				/* We did send beacon */
+				priv->tx_last_beacon = 1;
+			}
+
+			tx_info_bcn = IEEE80211_SKB_CB(skb);
+			ivif = tx_info_bcn->control.vif;
+			uvif = (struct umac_vif *)(ivif->drv_priv);
+
+			bss_conf = &uvif->vif->bss_conf;
+			bcn_status = bss_conf->enable_beacon;
+			bcn_int = bss_conf->beacon_int - 10;
+			bcn_int = msecs_to_jiffies(bcn_int);
+
+			for (i = 0; i < MAX_VIFS; i++) {
+				if (priv->active_vifs & (1 << i)) {
+					if ((priv->vifs[i] == ivif) &&
+					    (bcn_status == true)) {
+						mod_timer(&uvif->bcn_timer,
+							  jiffies +
+							  bcn_int);
+					}
+				}
+			}
+
+			dev_kfree_skb_any(skb);
+		}
+
+		pkt++;
+	}
+out:
+	return pkts_pend;
+}
+
+
+
+
+
+
+void rpu_tx_init(struct img_priv *priv)
+{
+	int i = 0;
+	int j = 0;
+	struct tx_config *tx = &priv->tx;
+
+	memset(&tx->buf_pool_bmp,
+	       0,
+	       sizeof(long) * ((NUM_TX_DESCS/TX_DESC_BUCKET_BOUND) + 1));
+
+	tx->queue_stopped_bmp = 0;
+	tx->next_spare_token_ac = WLAN_AC_BE;
+
+	for (i = 0; i < NUM_ACS; i++) {
+		for (j = 0; j < MAX_PEND_Q_PER_AC; j++) {
+				skb_queue_head_init(&tx->pending_pkt[j][i]);
+		}
+
+		tx->outstanding_tokens[i] = 0;
+	}
+
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		skb_queue_head_init(&tx->pkt_info[i].pkt);
+	}
+
+	for (j = 0; j < NUM_ACS; j++)
+		tx->curr_peer_opp[j] = 0;
+
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		tx->outstanding_pkts[i] = 0;
+		tx->tx_desc_had_send_to_io[i] = 0;
+	}
+
+	spin_lock_init(&tx->lock);
+	ieee80211_wake_queues(priv->hw);
+
+	RPU_DEBUG_TX("%s-UMACTX: initialization successful\n",
+			TX_TO_MACDEV(tx)->name);
+}
+
+
+void rpu_tx_deinit(struct img_priv *priv)
+{
+	int i = 0;
+	int j = 0;
+	struct tx_config *tx = &priv->tx;
+	struct sk_buff *skb = NULL;
+	struct sk_buff_head *pend_q = NULL;
+
+	ieee80211_stop_queues(priv->hw);
+
+	wait_for_tx_complete(tx);
+
+	spin_lock_bh(&tx->lock);
+
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		while ((skb = skb_dequeue(&tx->pkt_info[i].pkt)) != NULL)
+			dev_kfree_skb_any(skb);
+	}
+
+	for (i = 0; i < NUM_ACS; i++) {
+		for (j = 0; j < MAX_PEND_Q_PER_AC; j++) {
+			pend_q = &tx->pending_pkt[j][i];
+
+			while ((skb = skb_dequeue(pend_q)) != NULL)
+				dev_kfree_skb_any(skb);
+		}
+	}
+
+	spin_unlock_bh(&tx->lock);
+
+	RPU_DEBUG_TX("%s-UMACTX: deinitialization successful\n",
+			TX_TO_MACDEV(tx)->name);
+}
+
+
+int __rpu_tx_frame(struct img_priv *priv,
+			   unsigned int queue,
+			   unsigned int token_id,
+			   unsigned int more_frames,
+			   bool retry)
+{
+	struct umac_event_tx_done tx_done;
+	struct sk_buff_head *txq = NULL;
+	int ret = 0;
+	int pkt = 0;
+
+	ret = rpu_prog_tx(queue,
+				  more_frames,
+				  token_id,
+				  retry);
+
+	if (ret < 0) {
+		RPU_ERROR_TX("%s-UMACTX: Unable to send frame, dropping ..%d\n",
+		       priv->name, ret);
+
+		memset(&tx_done, 0, sizeof(struct umac_event_tx_done));
+		tx_done.descriptor_id = token_id;
+		tx_done.queue = queue;
+
+		txq = &priv->tx.pkt_info[token_id].pkt;
+
+		for (pkt = 0; pkt < skb_queue_len(txq); pkt++) {
+			tx_done.frm_status[pkt] = TX_DONE_STAT_ERR_RETRY_LIM;
+			tx_done.rate[pkt] = 0;
+		}
+
+		rpu_tx_complete(&tx_done,
+					priv);
+	}
+
+	return ret;
+}
+
+static void rpu_tx_wake_lock(void)
+{
+	if (wake_lock_active(&hpriv->fw_err_lock))
+		wake_unlock(&hpriv->fw_err_lock);
+	wake_lock_timeout(&hpriv->fw_err_lock, msecs_to_jiffies(3*1000));
+}
+
+int rpu_tx_frame(struct sk_buff *skb,
+			 struct ieee80211_sta *sta,
+			 struct img_priv *priv,
+			 bool bcast)
+{
+	unsigned int queue = 0;
+	unsigned int token_id = 0;
+	unsigned int more_frames = 0;
+	int ret = 0;
+	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *mac_hdr = NULL;
+	struct umac_vif *uvif = NULL;
+	struct umac_sta *usta = NULL;
+	int peer_id = -1;
+
+	uvif = (struct umac_vif *)(tx_info->control.vif->drv_priv);
+	mac_hdr = (struct ieee80211_hdr *)(skb->data);
+
+	if (ieee80211_is_data(mac_hdr->frame_control))
+		rpu_tx_wake_lock();
+
+	if (sta) {
+		usta = (struct umac_sta *)sta->drv_priv;
+		peer_id = usta->index;
+	} else {
+		peer_id = MAX_PEERS + uvif->vif_index;
+
+#ifdef STA_AP_COEXIST
+		if (uvif->vif && uvif->vif->type == NL80211_IFTYPE_AP)
+			adjust_beacon_ie(priv, skb);
+#endif
+	}
+
+	if (bcast == false) {
+		queue = tx_queue_map(skb->queue_mapping);
+		more_frames = 0;
+	} else {
+		queue = WLAN_AC_BCN;
+		/* Hack: skb->priority is used to indicate more frames */
+		more_frames = skb->priority;
+	}
+
+	if (!ieee80211_is_beacon(mac_hdr->frame_control))
+		priv->stats->tx_cmds_from_stack++;
+
+	if (priv->params->production_test == 1)
+		tx_info->flags |= IEEE80211_TX_CTL_AMPDU;
+
+
+
+	RPU_DEBUG_TX("%s-UMACTX:%s:%d ",
+			priv->name,
+			 __func__,
+			 __LINE__);
+	RPU_DEBUG_TX("Wait Alloc:queue: %d qmap: %d is_bcn: %d bcast:%d\n",
+			queue,
+			skb->queue_mapping,
+			ieee80211_is_beacon(mac_hdr->frame_control),
+			is_multicast_ether_addr(mac_hdr->addr1) ? true : false);
+
+	token_id = rpu_tx_alloc_token(priv,
+						 queue,
+						 peer_id,
+						 skb);
+
+	/* The frame was unable to find a reserved token */
+	if (token_id == NUM_TX_DESCS) {
+		RPU_DEBUG_TX("%s-UMACTX:%s:%d Token Busy Queued:\n",
+			priv->name, __func__, __LINE__);
+		return NETDEV_TX_OK;
+	}
+
+	ret = __rpu_tx_frame(priv,
+				     queue,
+				     token_id,
+				     more_frames,
+				     0);
+
+
+	return NETDEV_TX_OK;
+}
+
+extern void rpu_prog_tx_send(void *skb);
+
+static void make_null_frame(struct ieee80211_hdr_3addr *nullfunc, int index)
+{
+	struct img_priv *priv = wifi->hw->priv;
+
+#ifdef RPU_ENABLE_PS
+	if (priv->power_save == PWRSAVE_STATE_AWAKE)
+		nullfunc->frame_control = 0x0148;
+	else
+		nullfunc->frame_control = 0x1148;
+#else
+	nullfunc->frame_control = 0x0148;
+#endif
+	nullfunc->duration_id = 0x0034;
+	memcpy(nullfunc->addr1, priv->vif_info.bssid[index], ETH_ALEN);
+	memcpy(nullfunc->addr2, priv->vif_info.vif_addr[index], ETH_ALEN);
+	memcpy(nullfunc->addr3, priv->vif_info.bssid[index], ETH_ALEN);
+	nullfunc->seq_ctrl = priv->null_frame_seq_no;
+	priv->null_frame_seq_no += 0x10;
+}
+
+// only with 1 pkt
+static void make_cmd_tx_ctrl(struct cmd_tx_ctrl *tx_cmd, void *data, int length, int desc_id, int queue, int index)
+{
+	memset(tx_cmd, 0, sizeof(struct cmd_tx_ctrl));
+
+	tx_cmd->hdr.id = RPU_CMD_TX;
+	/* Keep the queue num and pool id in descriptor id */
+	tx_cmd->hdr.descriptor_id |= (queue << 16) | desc_id;
+	tx_cmd->hdr.length = sizeof(struct cmd_tx_ctrl);
+
+	tx_cmd->if_index = index;
+	tx_cmd->queue_num = queue;
+	tx_cmd->more_frms = 0;
+	tx_cmd->descriptor_id = desc_id;
+	tx_cmd->num_frames_per_desc = 1;
+	tx_cmd->pkt_length[0] = length;
+	tx_cmd->p_frame_ddr_pointer[0] = (unsigned int *)data;
+
+	tx_cmd->num_rates = 1;
+	tx_cmd->rate[0] = 2; // 1Mbps
+	tx_cmd->rate_retries[0] = 5;
+	tx_cmd->rate_preamble_type[0] = 1;
+	tx_cmd->num_spatial_streams[0] = 1;
+
+	tx_cmd->config_mac_hdr_len = sizeof(struct ieee80211_hdr_3addr);
+	memcpy(tx_cmd->config_mac_header, data,
+	      tx_cmd->config_mac_hdr_len );
+
+	tx_cmd->per_pkt_crypto_params[0][0] = 0x10;
+}
+
+void rpu_send_nullframe(struct img_priv *priv)
+{
+	int desc_id, queue = 3;
+	struct cmd_tx_ctrl *tx_cmd;
+	int index = find_main_iface(priv);
+	struct sk_buff *cmd_skb = NULL, *data_skb = NULL;
+	unsigned int cmd_tx_size = sizeof(struct cmd_tx_ctrl);
+	unsigned int data_size = sizeof(struct ieee80211_hdr_3addr);
+
+	cmd_skb = alloc_skb(cmd_tx_size, GFP_ATOMIC);
+	if (!cmd_skb)
+		return;
+
+	data_skb = alloc_skb(data_size, GFP_ATOMIC);
+	if (!data_skb) {
+		dev_kfree_skb_any(cmd_skb);
+		return;
+	}
+
+	skb_put(cmd_skb, cmd_tx_size);
+	skb_put(data_skb, data_size);
+
+	spin_lock_bh(&priv->tx.lock);
+
+	if (get_outstanding_pkts(&priv->tx, NUM_TX_DESCS) > 0)
+		goto skip_send_null;
+
+	desc_id = get_token(priv, queue);
+	if (desc_id == NUM_TX_DESCS)
+		goto skip_send_null;
+
+	priv->null_frame_sending = 1;
+	priv->null_frame_send_count++;
+	tx_cmd = (struct cmd_tx_ctrl *)cmd_skb->data;
+	make_null_frame((struct ieee80211_hdr_3addr *)data_skb->data, index);
+	make_cmd_tx_ctrl(tx_cmd, (void *)data_skb->data,
+			sizeof(struct ieee80211_hdr_3addr), desc_id, queue, index);
+	priv->null_frame_skb = data_skb;
+
+	rpu_prog_tx_send(cmd_skb);
+	priv->stats->tx_cmd_send_count_single++;
+
+	spin_unlock_bh(&priv->tx.lock);
+	return;
+
+skip_send_null:
+
+	spin_unlock_bh(&priv->tx.lock);
+	if (cmd_skb)
+		dev_kfree_skb_any(cmd_skb);
+	if (data_skb)
+		dev_kfree_skb_any(data_skb);
+}
+
+void rpu_send_nullframe_cmp(struct img_priv *priv, int token_id, int queue)
+{
+	priv->null_frame_sending = 0;
+
+	spin_lock_bh(&priv->tx.lock);
+	free_token(priv, token_id, queue);
+	spin_unlock_bh(&priv->tx.lock);
+	dev_kfree_skb_any(priv->null_frame_skb);
+}
+
+void rpu_tx_complete(struct umac_event_tx_done *tx_done,
+			     void *context)
+{
+	struct img_priv *priv = (struct img_priv *)context;
+	unsigned int more_frames = 0;
+	int vif_index = 0, vif_index_bitmap = 0, ret = 0;
+	unsigned int pkts_pending = 0;
+	unsigned char queue = 0;
+	struct umac_event_noa noa_event;
+	int token_id = 0;
+	int qlen = 0;
+
+	token_id = tx_done->descriptor_id;
+	//RPU_INFO_TX("tx done %d %d\n", token_id, tx_done->queue);
+
+	if (token_id < 0 || token_id > 11) {
+		RPU_ERROR_TX("%s:%d Invalid token_id: %d\n",
+			     __func__,
+			     __LINE__,
+			     token_id);
+		RPU_DEBUG_DUMP_TX(DUMP_PREFIX_NONE,
+			          16,
+			          1,
+			          tx_done,
+			          sizeof(struct umac_event_tx_done),
+			          1);
+		return;
+	}
+
+	/* check send null frame complete */
+	if (priv->null_frame_sending &&
+		priv->null_frame_desc_id == token_id) {
+		rpu_send_nullframe_cmp(priv, token_id, tx_done->queue);
+		return;
+	}
+
+#ifdef ENABLE_DAPT_BEACON
+	vif_index = priv->tx.pkt_info[token_id].vif_index;
+	if (vif_index < MAX_VIFS)
+		dapt_beacon(priv, *(short *)&tx_done->reserved[2*vif_index], vif_index);
+#endif
+
+	qlen = skb_queue_len(&priv->tx.pkt_info[token_id].pkt);
+
+	RPU_DEBUG_TX("%s-UMACTX:TX Done Rx for desc_id: %d",
+			  priv->name,
+			  tx_done->descriptor_id);
+	RPU_DEBUG_TX("Q: %d qlen: %d status: %d out_tok: %d\n",
+			  tx_done->queue,
+			  qlen,
+			  tx_done->frm_status[0],
+			  priv->tx.outstanding_tokens[tx_done->queue]);
+
+	update_aux_adc_voltage(priv, tx_done->pdout_voltage);
+
+	pkts_pending = rpu_tx_free_buff_req(priv,
+						    tx_done,
+						    &queue,
+						    &vif_index_bitmap);
+
+	if (pkts_pending) {
+		/*TODO..Do we need to check each skb for more_frames??*/
+		more_frames = 0;
+
+		RPU_DEBUG_TX("%s-UMACTX:%s:%d Transfer Pending Frames:\n",
+			       priv->name,
+			       __func__,
+			       __LINE__);
+
+		ret = __rpu_tx_frame(priv,
+					     queue,
+					     token_id,
+					     more_frames,
+					     0);
+
+	} else {
+		RPU_DEBUG_TX("%s-UMACTX:No Pending Packets\n", priv->name);
+	}
+
+
+	for (vif_index = 0; vif_index < MAX_VIFS; vif_index++) {
+		if (vif_index_bitmap & (1 << vif_index)) {
+			memset(&noa_event, 0, sizeof(noa_event));
+			noa_event.if_index = vif_index;
+			rpu_noa_event(FROM_TX_DONE,
+					      &noa_event,
+					      (void *)priv,
+					      NULL);
+		}
+	}
+}
+
+/* process unfinished tx done when fw error happened */
+void rpu_tx_proc_unfi_tx_done(void)
+{
+	int i, j;
+	struct umac_event_tx_done tx_done;
+	struct umac_event_tx_done *ptx_done;
+	struct img_priv *priv = wifi->hw->priv;
+
+	RPU_DEBUG_ROCOVERY("%s: buf_pool_bmp = %x\n", __func__, (unsigned int)priv->tx.buf_pool_bmp[0]);
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		if (test_bit(i, &priv->tx.buf_pool_bmp[0])) {
+			if (priv->tx.tx_desc_had_send_to_io[i] == 0)
+				continue;
+
+			memset(&tx_done, 0, sizeof(struct umac_event_tx_done));
+			ptx_done = (struct umac_event_tx_done *)&tx_done;
+
+			//Setup msg according to TX done message processing in mac handle event
+			ptx_done->hdr.length = sizeof(struct umac_event_tx_done);
+			ptx_done->hdr.payload_length = 0;
+			ptx_done->hdr.id = RPU_EVENT_TX_DONE;
+
+			ptx_done->pdout_voltage = 0;
+			ptx_done->queue = priv->tx.pkt_info[i].queue;
+			ptx_done->descriptor_id = i;
+
+			for(j = 0; j < MAX_TX_CMDS; j++) {
+				ptx_done->frm_status[j] = TX_DONE_STAT_SUCCESS;
+				ptx_done->retries_num[j] = 0;
+				ptx_done->rate[j] = 2;
+			}
+
+			RPU_DEBUG_ROCOVERY("desc %d, queue %d\n", i, ptx_done->queue);
+			rpu_tx_complete(ptx_done, (void *)priv);
+		}
+	}
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/umac_if.c b/drivers/net/wireless/rockchip_wlan/rk915/src/umac_if.c
new file mode 100755
index 000000000..55a856f9a
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/umac_if.c
@@ -0,0 +1,2390 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/etherdevice.h>
+#include <linux/firmware.h>
+#include <linux/interrupt.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/udp.h>
+#include <linux/version.h>
+#include <linux/wireless.h>
+#include <net/iw_handler.h>
+
+#include <net/cfg80211.h>
+#include <net/mac80211.h>
+#include <../net/mac80211/ieee80211_i.h>
+
+#include "core.h"
+#include "p2p.h"
+#include "utils.h"
+//#include "fwldr.h"
+#include "hal_io.h"
+#include "if_io.h"
+
+#define UMAC_IF_TAG "UMAC_IF"
+
+/* Its value will be the default mac address and it can only be updated with the
+ * command line arguments
+ */
+unsigned int ht_support = 1;
+module_param(ht_support, int, 0);
+MODULE_PARM_DESC(ht_support, "Configure the 11n support for this device");
+
+unsigned int ftm;
+module_param(ftm, int, 0);
+MODULE_PARM_DESC(ftm, "Factory Test Mode, should be used only for calibrations.");
+
+unsigned int down_fw_in_probe = 0;
+module_param(down_fw_in_probe, int, 0);
+MODULE_PARM_DESC(down_fw_in_probe, "Downlaod firmware in driver probe or not");
+
+unsigned int system_rev = 0x494D47;
+
+static unsigned int g_cipher_type;
+
+int rpu_debug =
+	RPU_DEBUG_SCAN			|
+	RPU_DEBUG_ROC			|
+	RPU_DEBUG_TX			|
+	RPU_DEBUG_MAIN			|
+	RPU_DEBUG_IF			|
+	RPU_DEBUG_UMACIF		|
+	RPU_DEBUG_RX			|
+	RPU_DEBUG_HAL			|
+	RPU_DEBUG_CRYPTO		|
+	//RPU_DEBUG_DUMP_RX		|
+	//RPU_DEBUG_DUMP_HAL		|
+	RPU_DEBUG_TSMC			|
+	RPU_DEBUG_P2P			|
+	RPU_DEBUG_VIF			|
+	//RPU_DEBUG_DUMP_TX		|
+	RPU_DEBUG_SDIO			|
+	RPU_DEBUG_HALIO			|
+	RPU_DEBUG_DAPT			|
+	RPU_DEBUG_ROCOVERY		|
+	RPU_DEBUG_FIRMWARE;
+
+int rpu_debug_level =
+	RPU_DEBUG_LEVEL_ERROR	|
+	RPU_DEBUG_LEVEL_INFO/*	|
+	RPU_DEBUG_LEVEL_DEBUG*/;
+
+module_param(rpu_debug, uint, 0);
+MODULE_PARM_DESC(rpu_debug, " rpu_debug: Configure Debugging Mask");
+int uccp_reinit;
+
+int load_fw(struct ieee80211_hw *hw);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
+#undef IEEE80211_BAND_2GHZ
+#define IEEE80211_BAND_2GHZ NL80211_BAND_2GHZ
+#endif
+
+#define CHAN2G(_freq, _idx)  {		\
+	.band = IEEE80211_BAND_2GHZ,	\
+	.center_freq = (_freq),		\
+	.hw_value = (_idx),		\
+	.max_power = 20,		\
+}
+
+#define CHAN5G(_freq, _idx, _flags) {	\
+	.band = IEEE80211_BAND_5GHZ,	\
+	.center_freq = (_freq),		\
+	.hw_value = (_idx),		\
+	.max_power = 20,		\
+	.flags = (_flags),		\
+}
+
+static struct ieee80211_channel dsss_chantable[] = {
+	CHAN2G(2412, 0),  /* Channel 1 */
+	CHAN2G(2417, 1),  /* Channel 2 */
+	CHAN2G(2422, 2),  /* Channel 3 */
+	CHAN2G(2427, 3),  /* Channel 4 */
+	CHAN2G(2432, 4),  /* Channel 5 */
+	CHAN2G(2437, 5),  /* Channel 6 */
+	CHAN2G(2442, 6),  /* Channel 7 */
+	CHAN2G(2447, 7),  /* Channel 8 */
+	CHAN2G(2452, 8),  /* Channel 9 */
+	CHAN2G(2457, 9),  /* Channel 10 */
+	CHAN2G(2462, 10), /* Channel 11 */
+	CHAN2G(2467, 11), /* Channel 12 */
+	CHAN2G(2472, 12), /* Channel 13 */
+	CHAN2G(2484, 13), /* Channel 14 */
+};
+
+
+static struct ieee80211_rate dsss_rates[] = {
+	{ .bitrate = 10, .hw_value = 2},
+	{ .bitrate = 20, .hw_value = 4,
+	.flags = IEEE80211_RATE_SHORT_PREAMBLE},
+	{ .bitrate = 55, .hw_value = 11,
+	.flags = IEEE80211_RATE_SHORT_PREAMBLE},
+	{ .bitrate = 110, .hw_value = 22,
+	.flags = IEEE80211_RATE_SHORT_PREAMBLE},
+	{ .bitrate = 60, .hw_value = 12},
+	{ .bitrate = 90, .hw_value = 18},
+	{ .bitrate = 120, .hw_value = 24},
+	{ .bitrate = 180, .hw_value = 36},
+	{ .bitrate = 240, .hw_value = 48},
+	{ .bitrate = 360, .hw_value = 72},
+	{ .bitrate = 480, .hw_value = 96},
+	{ .bitrate = 540, .hw_value = 108}
+};
+
+static struct ieee80211_supported_band band_2ghz = {
+	.channels = dsss_chantable,
+	.n_channels = ARRAY_SIZE(dsss_chantable),
+	.band = IEEE80211_BAND_2GHZ,
+	.bitrates = dsss_rates,
+	.n_bitrates = ARRAY_SIZE(dsss_rates),
+};
+
+
+/* Interface combinations for Virtual interfaces */
+static const struct ieee80211_iface_limit if_limit1[] = {
+		{ .max = 2, .types = BIT(NL80211_IFTYPE_STATION)}
+};
+
+static const struct ieee80211_iface_limit if_limit2[] = {
+		{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION)},
+		{ .max = 1, .types = BIT(NL80211_IFTYPE_AP) |
+				     BIT(NL80211_IFTYPE_P2P_CLIENT) |
+				     BIT(NL80211_IFTYPE_ADHOC) |
+				     BIT(NL80211_IFTYPE_P2P_GO)}
+};
+
+static const struct ieee80211_iface_limit if_limit3[] = {
+		{ .max = 2, .types = BIT(NL80211_IFTYPE_P2P_CLIENT)}
+};
+
+static const struct ieee80211_iface_limit if_limit4[] = {
+		{ .max = 1, .types = BIT(NL80211_IFTYPE_ADHOC)},
+		{ .max = 1, .types = BIT(NL80211_IFTYPE_P2P_CLIENT)}
+};
+
+
+static const struct ieee80211_iface_limit if_limit6[] = {
+		{ .max = 1, .types = BIT(NL80211_IFTYPE_AP)}
+};
+
+
+static const struct ieee80211_iface_combination if_comb[] = {
+	{ .limits = if_limit1,
+	  .n_limits = ARRAY_SIZE(if_limit1),
+	  .max_interfaces = 2,
+	  .num_different_channels = 1},
+	{ .limits = if_limit2,
+	  .n_limits = ARRAY_SIZE(if_limit2),
+	  .max_interfaces = 2,
+	  .num_different_channels = 1},
+	{ .limits = if_limit3,
+	  .n_limits = ARRAY_SIZE(if_limit3),
+	  .max_interfaces = 2,
+	  .num_different_channels = 1},
+	{ .limits = if_limit4,
+	  .n_limits = ARRAY_SIZE(if_limit4),
+	  .max_interfaces = 2,
+	  .num_different_channels = 1},
+};
+
+#ifdef WOWLAN_SUPPORT
+static const struct wiphy_wowlan_support uccp_wowlan_support = {
+	.flags = WIPHY_WOWLAN_ANY,
+};
+#endif
+
+#ifdef DUMP_TX_RX_FRAME_INFO
+
+#include <net/cfg80211.h>
+#include <net/ip.h>
+#include <linux/tcp.h>
+
+static int ieee80211_crypt_hdrlen(u16 fc)
+{
+	int hdrlen = 0;
+
+	if (ieee80211_has_protected(fc)) {
+		switch (g_cipher_type) {
+		case CIPHER_TYPE_WEP40:
+		case CIPHER_TYPE_WEP104:
+			hdrlen = 4;//WEP_IV_LEN;
+			break;
+		case CIPHER_TYPE_TKIP:
+		case CIPHER_TYPE_CCMP:
+			hdrlen = 8;
+			break;
+		}
+	}
+	return hdrlen;
+}
+
+static int ieee8022_ll_hdrlen(u8 *payload, u16 ethertype)
+{
+	if ((ether_addr_equal(payload, rfc1042_header) &&
+		    ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
+		   ether_addr_equal(payload, bridge_tunnel_header)) {
+		return 8;
+	} else {
+		return 0;
+	}
+}
+
+/*
+ * 802.11 frame struct  (for example ICMP):
+ *
+ * | 802.11 header | crypt header | 802.2 LL header | IP header| ICMP |
+ *
+ *                                option              option
+ */
+static void dump_ip_info(u8 *data, int len, u8 *str)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)data;
+	u16 fc = hdr->frame_control;
+
+	if (ieee80211_is_data(fc) /*&&
+		is_unicast_ether_addr(ieee80211_get_DA(hdr))*/) {
+		int offset, ieee8022_hdrlen;
+		u8 *ieee8022_payload;
+		int ethertype, n;
+		struct iphdr *ip;
+
+		offset = ieee80211_hdrlen(fc); /* 802.11 header */
+		offset += ieee80211_crypt_hdrlen(fc); /* crypt header */
+
+		if (offset >= len) {
+			return;
+		}
+
+		ieee8022_payload = data + offset; /* ieee802.2 ll header */
+		ethertype = (ieee8022_payload[6] << 8) | ieee8022_payload[7];
+		ieee8022_hdrlen =ieee8022_ll_hdrlen(ieee8022_payload, ethertype);
+
+		n = sprintf(str, "ethertype %04x ", ethertype);
+		str += n;
+		if (ieee8022_hdrlen &&
+			ethertype == ETH_P_IP/* &&
+			ethertype == ETH_P_IPV6*/) {
+			offset += ieee8022_hdrlen;
+			ip = (struct iphdr *)(data + offset); /* IP header */
+			n = sprintf(str, "protocol %03d %pI4 -> %pI4 ", ip->protocol, &(ip->saddr), &(ip->daddr));
+			str += n;
+			if (ip->protocol == IPPROTO_UDP) {
+				struct udphdr *uh = (struct udphdr *)((u8 *)ip + ip->ihl * 4);
+
+				sprintf(str, "UDP Port %d -> %d ", ntohs(uh->source), ntohs(uh->dest));
+			} else if (ip->protocol == IPPROTO_TCP) {
+				struct tcphdr *th = (struct tcphdr *)((u8 *)ip + ip->ihl * 4);
+
+				sprintf(str, "TCP Port %d -> %d ", ntohs(th->source), ntohs(th->dest));
+			}
+		}
+	}
+}
+
+enum p2p_action_frame_type {
+        P2P_GO_NEG_REQ = 0,
+        P2P_GO_NEG_RESP = 1,
+        P2P_GO_NEG_CONF = 2,
+        P2P_INVITATION_REQ = 3,
+        P2P_INVITATION_RESP = 4,
+        P2P_DEV_DISC_REQ = 5,
+        P2P_DEV_DISC_RESP = 6,
+        P2P_PROV_DISC_REQ = 7,
+        P2P_PROV_DISC_RESP = 8
+};
+
+static inline u32 WPA_GET_BE32(const u8 *a)
+{
+        return ((u32) a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3];
+}
+
+static char *dump_p2p_action_type(struct ieee80211_hdr *hdr)
+{
+	u8 *payload;
+	u8 category;
+
+	payload = (u8 *)hdr + sizeof(struct ieee80211_hdr_3addr);
+	category = *payload++;
+
+#define WLAN_ACTION_PUBLIC 4
+#define WLAN_PA_VENDOR_SPECIFIC 9
+#define P2P_IE_VENDOR_TYPE 0x506f9a09
+
+	if (category == WLAN_ACTION_PUBLIC) {
+        switch (payload[0]) {
+        case WLAN_PA_VENDOR_SPECIFIC:
+            payload++;
+            if (WPA_GET_BE32(payload) != P2P_IE_VENDOR_TYPE)
+                    return "";
+
+            payload += 4;
+	        switch (payload[0]) {
+	        case P2P_GO_NEG_REQ:
+	                return "P2P_GO_NEG_REQ";
+	        case P2P_GO_NEG_RESP:
+	                return "P2P_GO_NEG_RESP";
+	        case P2P_GO_NEG_CONF:
+	                return "P2P_GO_NEG_CONF";
+	        case P2P_INVITATION_REQ:
+	                return "P2P_INVITATION_REQ";
+	        case P2P_INVITATION_RESP:
+	                return "P2P_INVITATION_RESP";
+	        case P2P_PROV_DISC_REQ:
+	                return "P2P_PROV_DISC_REQ";
+	        case P2P_PROV_DISC_RESP:
+	                return "P2P_PROV_DISC_RESP";
+	        case P2P_DEV_DISC_REQ:
+	                return "P2P_DEV_DISC_REQ";
+	        case P2P_DEV_DISC_RESP:
+	                return "P2P_DEV_DISC_RESP";
+	        }
+			break;
+        }
+	}
+	return "";
+}
+
+void dump_ieee80211_hdr_info(unsigned char *data, int len, int tx)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)data;
+	char direct_str[256];
+	u8 *DA = ieee80211_get_DA(hdr);
+	u8 *SA = ieee80211_get_SA(hdr);
+	int n;
+
+	if (wifi->params.hw_scan_status != HW_SCAN_STATUS_NONE)
+		return;
+
+	n = sprintf(direct_str, "%s len %04d %pM -> %pM SN %d ", tx?"tx":"rx", len, SA, DA, hdr->seq_ctrl>>4);
+	dump_ip_info(data, len, &direct_str[n]);
+
+	if (hdr != NULL) {
+		//RPU_DEBUG_UMACIF("%s\n", __func__);
+		if (ieee80211_is_mgmt(hdr->frame_control)) {
+			if (ieee80211_is_assoc_req(hdr->frame_control)) {
+				RPU_INFO_RX("%s assoc req\n", direct_str);
+			} else if (ieee80211_is_assoc_resp(hdr->frame_control)) {
+				RPU_INFO_RX("%s assoc resp\n", direct_str);
+			} else if (ieee80211_is_reassoc_req(hdr->frame_control)) {
+				RPU_INFO_RX("%s reassoc req\n", direct_str);
+			} else if (ieee80211_is_reassoc_resp(hdr->frame_control)) {
+				RPU_INFO_RX("%s reassoc resp\n", direct_str);
+			} else if (ieee80211_is_probe_req(hdr->frame_control)) {
+				RPU_INFO_RX("%s probe req\n", direct_str);
+			} else if (ieee80211_is_probe_resp(hdr->frame_control)) {
+				RPU_INFO_RX("%s probe resp\n", direct_str);
+			} else if (ieee80211_is_beacon(hdr->frame_control)) {
+				RPU_INFO_RX("%s beacon\n", direct_str);
+			} else if (ieee80211_is_atim(hdr->frame_control)) {
+				RPU_INFO_RX("%s atim\n", direct_str);
+			} else if (ieee80211_is_disassoc(hdr->frame_control)) {
+				RPU_INFO_RX("%s disassoc\n", direct_str);
+			} else if (ieee80211_is_auth(hdr->frame_control)) {
+				RPU_INFO_RX("%s auth\n", direct_str);
+			} else if (ieee80211_is_deauth(hdr->frame_control)) {
+				RPU_INFO_RX("%s deauth\n", direct_str);
+			} else if (ieee80211_is_action(hdr->frame_control)) {
+				RPU_INFO_RX("%s action %s\n", direct_str, dump_p2p_action_type(hdr));
+			} else {
+				RPU_INFO_RX("%s mgmt\n", direct_str);
+			}
+		} else if (ieee80211_is_ctl(hdr->frame_control)) {
+			RPU_INFO_RX("%s ctl\n", direct_str);
+		} else if (ieee80211_is_data(hdr->frame_control)) {
+			RPU_INFO_RX("%s data\n", direct_str);
+		} else {
+			RPU_INFO_RX("%s unknow\n", direct_str);
+		}
+	}
+}
+#else
+void dump_ieee80211_hdr_info(unsigned char *data, int len, int tx)
+{
+}
+#endif
+
+#ifdef DUMP_MORE_DEBUG_INFO
+#define BSS_CHANGED_INFO_NUM 22
+static char bss_changed_info_tbl[BSS_CHANGED_INFO_NUM][32] = {
+	"BSS_CHANGED_ASSOC",
+	"BSS_CHANGED_ERP_CTS_PROT",
+	"BSS_CHANGED_ERP_PREAMBLE",
+	"BSS_CHANGED_ERP_SLOT",
+	"BSS_CHANGED_HT",
+	"BSS_CHANGED_BASIC_RATES",
+	"BSS_CHANGED_BEACON_INT",
+	"BSS_CHANGED_BSSID",
+	"BSS_CHANGED_BEACON",
+	"BSS_CHANGED_BEACON_ENABLED",
+	"BSS_CHANGED_CQM",
+	"BSS_CHANGED_IBSS",
+	"BSS_CHANGED_ARP_FILTER",
+	"BSS_CHANGED_QOS",
+	"BSS_CHANGED_IDLE",
+	"BSS_CHANGED_SSID",
+	"BSS_CHANGED_AP_PROBE_RESP",
+	"BSS_CHANGED_PS",
+	"BSS_CHANGED_TXPOWER",
+	"BSS_CHANGED_P2P_PS",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	"BSS_CHANGED_BEACON_INFO",
+#else
+	"BSS_CHANGED_DTIM_PERIOD",
+#endif
+	"BSS_CHANGED_BANDWIDTH"
+};
+
+#define CONF_CHANGED_INFO_NUM 9
+static char conf_changed_info_tbl[CONF_CHANGED_INFO_NUM][40] = {
+	" ",
+	"IEEE80211_CONF_CHANGE_SMPS",
+	"IEEE80211_CONF_CHANGE_LISTEN_INTERVAL",
+	"IEEE80211_CONF_CHANGE_MONITOR",
+	"IEEE80211_CONF_CHANGE_PS",
+	"IEEE80211_CONF_CHANGE_POWER",
+	"IEEE80211_CONF_CHANGE_CHANNEL",
+	"IEEE80211_CONF_CHANGE_RETRY_LIMITS",
+	"IEEE80211_CONF_CHANGE_IDLE"
+};
+static void dump_conf_changed_info(unsigned int changed)
+{
+	unsigned int i;
+	char prt_str[256];
+
+	memset(prt_str, 0, sizeof(prt_str));
+	for (i = 0; i < CONF_CHANGED_INFO_NUM; i++) {
+		if (changed & (1<<i))
+			sprintf(prt_str + strlen(prt_str), "%s|", conf_changed_info_tbl[i]);
+	}
+	
+	RPU_DEBUG_UMACIF("%s: changed = %08x (%s)\n", __func__, changed, prt_str);
+}
+
+static void dump_bss_changed_info(unsigned int changed)
+{
+	unsigned int i;
+	char prt_str[756];
+
+	memset(prt_str, 0, sizeof(prt_str));
+	for (i = 0; i < BSS_CHANGED_INFO_NUM; i++) {
+		if (changed & (1<<i))
+			sprintf(prt_str + strlen(prt_str), "%s|", bss_changed_info_tbl[i]);
+	}
+	
+	RPU_DEBUG_UMACIF("%s: changed = %08x (%s)\n", __func__, changed, prt_str);
+}
+
+#define AMPDU_ACTION_NUM 7
+static char ampdu_action_tbl[AMPDU_ACTION_NUM][32] = {
+	"AMPDU_RX_START",
+	"AMPDU_RX_STOP",
+	"AMPDU_TX_START",
+	"AMPDU_TX_STOP_CONT",
+	"AMPDU_TX_STOP_FLUSH",
+	"AMPDU_TX_STOP_FLUSH_CONT",
+	"AMPDU_TX_OPERATIONAL"
+};
+
+static void dump_ampdu_action_info(unsigned int action)
+{
+	RPU_DEBUG_UMACIF("%s: (%s)\n", __func__, ampdu_action_tbl[action]);
+}
+#else
+static void dump_conf_changed_info(unsigned int changed)
+{
+}
+
+static void dump_bss_changed_info(unsigned int changed)
+{
+}
+
+static void dump_ampdu_action_info(unsigned int action)
+{
+}
+
+#endif
+
+void rk915_signal_io_error(int reason)
+{
+	if (hpriv->shutdown || hpriv->during_fw_download)
+		return;
+	hpriv->fw_error = 1;
+	if (!hpriv->fw_error_processing) {
+		if (!wake_lock_active(&hpriv->fw_err_lock))
+			wake_lock(&hpriv->fw_err_lock);
+		
+		hpriv->fw_error_processing = 1;
+		hpriv->fw_error_counter++;
+		hpriv->fw_error_reason = reason;
+
+		RPU_ERROR_UMACIF("%s\n", __func__);
+		RPU_ERROR_ROCOVERY("-------- fw error recovery (%d) start --------\n", reason);
+
+		// trigger recovery work
+		schedule_work(&hpriv->fw_err_work);
+	}
+}
+
+/* only for wlan0 interface
+ * param val:
+ *   0, enter power save
+ *   1, exit power save
+ */
+void trigger_wifi_power_save(int val)
+{
+	struct img_priv *priv = wifi->hw->priv;
+	int if_index;
+
+	if (priv->state != STARTED) {
+		return;
+	}
+
+	if_index = find_main_iface(priv);
+	priv->power_save = val;
+
+	rpu_prog_ps_state(if_index,
+				priv->vifs[if_index]->addr,
+				val);
+}
+
+void cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+void trigger_wifi_scan_abort(int if_idx)
+{
+	struct ieee80211_vif *vif;
+	struct img_priv *priv = wifi->hw->priv;
+
+	if (if_idx > 1)
+		return;
+
+	rcu_read_lock();
+
+	vif = (struct ieee80211_vif *)rcu_dereference(priv->vifs[if_idx]);
+	if (vif == NULL) {
+		rcu_read_unlock();
+		return;
+	}
+
+	cancel_hw_scan(wifi->hw, vif);
+
+	rcu_read_unlock();
+}
+
+#ifdef ENABLE_KEEP_ALIVE
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+void keep_alive_expiry(struct timer_list *t)
+#else
+extern void keep_alive_expiry(unsigned long data);
+#endif
+static void init_keep_alive_timer (struct img_priv *priv)
+{
+	RPU_DEBUG_UMACIF("%s: %p\n", __func__, priv);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+	timer_setup(&priv->keep_alive_timer, keep_alive_expiry, 0);
+#else
+	init_timer(&priv->keep_alive_timer);
+	priv->keep_alive_timer.data = (unsigned long)priv;
+	priv->keep_alive_timer.function = keep_alive_expiry;
+#endif
+	priv->null_frame_seq_no = 0;
+	priv->null_frame_sending = 0;
+	priv->null_frame_send_count = 0;
+}
+
+static void start_keep_alive_timer(struct img_priv *priv, int index)
+{
+	if (is_wlan_connected(priv) && index == find_main_iface(priv)) {
+		RPU_DEBUG_UMACIF("%s: %p\n", __func__, priv);
+		mod_timer(&priv->keep_alive_timer, jiffies + SEND_NULL_FRAME_INTERVAL_SECONDS * HZ);
+	}
+}
+
+static void deinit_keep_alive_timer (struct img_priv *priv)
+{
+	RPU_DEBUG_UMACIF("%s: %p\n", __func__, priv);
+	del_timer(&priv->keep_alive_timer);
+}
+#endif
+
+static void tx(struct ieee80211_hw *hw,
+	       struct ieee80211_tx_control *txctl,
+	       struct sk_buff *skb)
+{
+	struct img_priv *priv = hw->priv;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
+	struct umac_vif *uvif;
+	unsigned char null_bssid[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	struct iphdr *iphdr;
+	unsigned char *pktgen_magic;
+	unsigned int orig_pktgen_magic = 0x55e99bbe; /*Endianness 0xbe9be955*/
+	struct umac_event_noa noa_event;
+
+	if (tx_info->control.vif == NULL) {
+		RPU_ERROR_UMACIF("%s: Dropping injected TX frame\n",
+			 priv->name);
+		dev_kfree_skb_any(skb);
+		return;
+	}
+
+	if (hpriv->fw_error_processing) {
+		dev_kfree_skb_any(skb);
+		return;
+	}
+
+	uvif = (struct umac_vif *)(tx_info->control.vif->drv_priv);
+
+#ifdef ENABLE_KEEP_ALIVE
+	start_keep_alive_timer(priv, uvif->vif_index);
+#endif
+
+	RPU_DEBUG_UMACIF("%s: %s: %s\n", 
+		VIF_INDEX_TO_INTERFACE_NAME(uvif->vif_index),
+		UMAC_IF_TAG, __func__);
+
+	if (wifi->params.production_test) {
+		if (((hdr->frame_control &
+		      IEEE80211_FCTL_FTYPE) != IEEE80211_FTYPE_DATA) ||
+		    (tx_info->control.vif == NULL))
+			goto tx_status;
+
+		iphdr = (struct iphdr *) skb_network_header(skb);
+		if (iphdr->protocol == IPPROTO_UDP) {
+			pktgen_magic = skb_transport_header(skb);
+			pktgen_magic += sizeof(struct udphdr);
+			/*If not PKTGEN, then drop it*/
+			if (memcmp(pktgen_magic, &orig_pktgen_magic, 4) != 0) {
+				RPU_DEBUG_UMACIF("%s:%d Prod_Mode: The pkt ",
+						   __func__, __LINE__);
+				RPU_DEBUG_UMACIF("is NOT PKTGEN so ");
+				RPU_DEBUG_UMACIF("dropping it\n");
+				goto tx_status;
+			}
+		} else {
+			RPU_DEBUG_UMACIF("%s:%d prod_mode: The pkt is NOT ",
+					   __func__, __LINE__);
+			RPU_DEBUG_UMACIF("PKTGEN so dropping it\n");
+			goto tx_status;
+		}
+	}
+	if (ether_addr_equal(hdr->addr3, null_bssid)) {
+		RPU_INFO_UMACIF("%s: null bssid\n", __func__);
+		goto tx_status;
+	}
+
+	if (uvif->vif->type != NL80211_IFTYPE_AP) {
+		if ((priv->power_save == PWRSAVE_STATE_DOZE) &&
+		    (!wifi->params.disable_power_save) &&
+		    (((hdr->frame_control &
+		      IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA) ||
+			 is_bufferable_mgmt_frame(hdr))) {
+			hdr->frame_control |= IEEE80211_FCTL_PM;
+		}
+	}
+#ifdef RPU_SLEEP_ENABLE
+#ifdef PS_SLEEP_TEST
+	hdr->frame_control |= IEEE80211_FCTL_PM;
+#endif
+#endif
+
+	if (uvif->noa_active) {
+		memset(&noa_event, 0, sizeof(noa_event));
+		noa_event.if_index = uvif->vif_index;
+		rpu_noa_event(FROM_TX, &noa_event, priv, skb);
+		return;
+	}
+
+
+	rpu_tx_frame(skb,
+			     txctl->sta,
+			     priv,
+			     false);
+
+	return;
+
+tx_status:
+	tx_info->flags |= IEEE80211_TX_STAT_ACK;
+	tx_info->status.rates[0].count = 1;
+	ieee80211_tx_status(hw, skb);
+}
+
+static int start(struct ieee80211_hw *hw)
+{
+	struct img_priv *priv = (struct img_priv *)hw->priv;
+	int ret = 0;
+
+	RPU_DEBUG_UMACIF("%s-80211IF: In start\n", priv->name);
+
+	mutex_lock(&priv->mutex);
+
+	hpriv->fw_error = 0;
+	if (!down_fw_in_probe && !wifi->params.fw_loaded) {
+		if (hpriv->fw_bring_up_func((void *)hpriv) != 0) {
+			ret = -ENODEV;
+			goto out;
+		}
+		wifi->params.fw_loaded = 1;
+	}
+
+	if ((rpu_core_init(priv, ftm)) < 0) {
+		RPU_ERROR_UMACIF("%s-80211IF: umac init failed\n", priv->name);
+		ret = -ENODEV;
+		goto out;
+	}
+
+	INIT_DELAYED_WORK(&priv->roc_complete_work, rpu_roc_complete_work);
+
+	priv->state = STARTED;
+	memset(priv->params->pdout_voltage, 0,
+	       sizeof(char) * MAX_AUX_ADC_SAMPLES);
+
+	priv->roc_params.roc_in_progress = 0;
+	priv->roc_params.roc_starting = 0;
+	priv->params->hw_scan_status = HW_SCAN_STATUS_NONE;
+
+out:
+	mutex_unlock(&priv->mutex);
+	return ret;
+}
+
+void stop(struct ieee80211_hw *hw)
+{
+	struct img_priv    *priv= (struct img_priv *)hw->priv;
+
+	RPU_DEBUG_UMACIF("%s-80211IF:In stop\n", priv->name);
+
+	mutex_lock(&priv->mutex);
+
+	rpu_core_deinit(priv, ftm);
+	priv->state = STOPPED;
+
+	if (hpriv->fw_error && !down_fw_in_probe && wifi->params.fw_loaded) {
+		hpriv->fw_tear_down_func((void *)hpriv);
+		wifi->params.fw_loaded = 0;
+	}
+
+	mutex_unlock(&priv->mutex);
+
+	hal_ops.reset_hal_params();
+
+}
+
+static int add_interface(struct ieee80211_hw *hw,
+		struct ieee80211_vif *vif)
+{
+	struct img_priv    *priv= hw->priv;
+	struct ieee80211_vif *v;
+	struct umac_vif   *uvif;
+	struct ieee80211_sub_if_data *sdata;
+	int vif_index, iftype;
+
+	/*if (priv->fw_error) {
+		return 0;
+	}*/
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	mutex_lock(&priv->mutex);
+	iftype = vif->type;
+	v = vif;
+	vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
+
+	sdata = vif_to_sdata(vif);
+	if (sdata) {
+		if (is_main_iface(vif->addr)) {
+			priv->net_dev = (void *)sdata->dev;
+			priv->sdata = (void *)sdata;
+		}
+	}
+
+	if (priv->current_vif_count == wifi->params.num_vifs) {
+		RPU_ERROR_UMACIF("%s: Exceeded Maximum supported VIF's cur:%d max: %d.\n",
+		       __func__,
+		       priv->current_vif_count,
+		       wifi->params.num_vifs);
+
+		mutex_unlock(&priv->mutex);
+		return -ENOTSUPP;
+	}
+
+	priv->iftype = iftype;
+	if (!(iftype == NL80211_IFTYPE_STATION ||
+	      iftype == NL80211_IFTYPE_ADHOC ||
+	      iftype == NL80211_IFTYPE_AP)) {
+		RPU_ERROR_UMACIF("Invalid Interface type\n");
+		mutex_unlock(&priv->mutex);
+		return -ENOTSUPP;
+	}
+
+	if (wifi->params.production_test) {
+		if (priv->active_vifs || iftype != NL80211_IFTYPE_ADHOC) {
+			mutex_unlock(&priv->mutex);
+			return -EBUSY;
+		}
+	}
+
+	for (vif_index = 0; vif_index < wifi->params.num_vifs; vif_index++) {
+		if (!(priv->active_vifs & (1 << vif_index)))
+			break;
+	}
+
+	/* This should never happen, we have taken care of this above */
+	if (vif_index == wifi->params.num_vifs) {
+		RPU_ERROR_UMACIF("%s: All VIF's are busy: %pM\n", __func__, vif->addr);
+		mutex_unlock(&priv->mutex);
+		return -EINVAL;
+	}
+
+	uvif = (struct umac_vif *)&v->drv_priv;
+	uvif->vif_index = vif_index;
+	uvif->vif = v;
+	uvif->priv = priv;
+	uvif->seq_no = 0;
+	rpu_vif_add(uvif);
+	priv->active_vifs |= (1 << vif_index);
+	priv->current_vif_count++;
+
+	if (iftype == NL80211_IFTYPE_ADHOC)
+		priv->tx_last_beacon = 0;
+
+	rcu_assign_pointer(priv->vifs[vif_index], v);
+	synchronize_rcu();
+
+#ifdef ENABLE_DAPT
+	dapt_param_late_init(priv);
+#endif
+
+	mutex_unlock(&priv->mutex);
+
+	return 0;
+}
+
+static void remove_interface(struct ieee80211_hw *hw,
+		struct ieee80211_vif *vif)
+{
+	struct img_priv    *priv= hw->priv;
+	struct ieee80211_vif *v;
+	int vif_index;
+
+#ifdef RK3036_DONGLE
+	wait_for_scan_complete(priv);
+#endif
+
+	/*if (priv->fw_error) {
+		return;
+	}*/
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	mutex_lock(&priv->mutex);
+	v = vif;
+	vif_index = ((struct umac_vif *)&v->drv_priv)->vif_index;
+
+	rpu_vif_remove((struct umac_vif *)&v->drv_priv);
+	priv->active_vifs &= ~(1 << vif_index);
+	rcu_assign_pointer(priv->vifs[vif_index], NULL);
+	synchronize_rcu();
+	wifi->params.sync[vif_index].status = 0;
+	priv->current_vif_count--;
+	mutex_unlock(&priv->mutex);
+
+}
+
+static int change_interface(struct ieee80211_hw *dev,
+		struct ieee80211_vif *vif,
+		enum nl80211_iftype new_type,
+		bool p2p)
+{
+	int ret = 0;
+
+	RPU_DEBUG_UMACIF("change_interface new: %d (%d), old: %d (%d)\n", new_type,
+			p2p, vif->type, vif->p2p);
+
+#ifdef RK3036_DONGLE
+	if (new_type != vif->type /*|| vif->p2p != p2p*/) {
+#else
+	if (new_type != vif->type || vif->p2p != p2p) {
+#endif
+		remove_interface(dev, vif);
+		vif->type = new_type;
+		vif->p2p = p2p;
+		ret = add_interface(dev, vif);
+	}
+
+	return ret;
+}
+
+static int config(struct ieee80211_hw *hw,
+		unsigned int changed)
+{
+	struct img_priv *priv = hw->priv;
+	struct ieee80211_conf *conf = &hw->conf;
+	unsigned int pri_chnl_num;
+	unsigned int freq_band;
+	unsigned int ch_width;
+	unsigned int center_freq = 0;
+	unsigned int center_freq1 = 0;
+	unsigned int center_freq2 = 0;
+	int i = 0;
+	int err = 0;
+	struct ieee80211_vif *vif = NULL;
+	int ret = 0;
+
+	/*if (priv->fw_error) {
+		return 0;
+	}*/
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	dump_conf_changed_info(changed);
+
+	mutex_lock(&priv->mutex);
+
+	if (changed & IEEE80211_CONF_CHANGE_POWER) {
+		priv->txpower = conf->power_level;
+		CALL_RPU(rpu_prog_txpower, priv->txpower);
+	}
+
+	/* Check for change in channel */
+	if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
+		center_freq = conf->chandef.chan->center_freq;
+		center_freq1 = conf->chandef.center_freq1;
+		center_freq2 = conf->chandef.center_freq2;
+		freq_band = conf->chandef.chan->band;
+		ch_width = conf->chandef.width;
+
+		pri_chnl_num = ieee80211_frequency_to_channel(center_freq);
+		RPU_DEBUG_UMACIF("%s-80211IF:Primary Channel is %d\n",
+				   priv->name,
+				   pri_chnl_num);
+		priv->pri_chnl_num = pri_chnl_num;
+
+		err = rpu_prog_channel(pri_chnl_num,
+					       center_freq1, center_freq2,
+					       ch_width,
+					       freq_band);
+
+		if (err) {
+			RPU_ERROR_UMACIF("%s: rpu_prog_channel failed\n", __func__);
+			mutex_unlock(&priv->mutex);
+			return err;
+		}
+	}
+
+	/* Check for change in Power save state */
+	for (i = 0; i < MAX_VIFS; i++) {
+		if (!(changed & IEEE80211_CONF_CHANGE_PS))
+			break;
+
+		if (!(priv->active_vifs & (1 << i)))
+			continue;
+
+		/* When ROC is in progress, do not mess with
+		 * PS state
+		 */
+		if (priv->roc_params.roc_in_progress)
+			continue;
+
+		if (wifi->params.disable_power_save)
+			continue;
+
+		if (conf->flags & IEEE80211_CONF_PS)
+			priv->power_save = PWRSAVE_STATE_DOZE;
+		else
+			priv->power_save = PWRSAVE_STATE_AWAKE;
+
+		RPU_DEBUG_UMACIF("%s-80211IF:PS state of VIF", priv->name);
+		RPU_DEBUG_UMACIF(" %d changed to %d\n", i, priv->power_save);
+
+		rcu_read_lock();
+		vif = rcu_dereference(priv->vifs[i]);
+		rcu_read_unlock();
+
+		rpu_prog_ps_state(i,
+					  vif->addr,
+					  priv->power_save);
+	}
+
+	/* TODO: Make this global config as it effects all VIF's */
+	for (i = 0; i < MAX_VIFS; i++) {
+		if (!(changed & IEEE80211_CONF_CHANGE_SMPS))
+			break;
+
+		if (wifi->params.production_test == 1)
+			break;
+
+		if (!(priv->active_vifs & (1 << i)))
+			continue;
+
+		RPU_DEBUG_UMACIF("%s-80211IF:MIMO PS state of VIF %d -> %d\n",
+				   priv->name,
+				   i,
+				   conf->smps_mode);
+
+		rcu_read_lock();
+		vif = rcu_dereference(priv->vifs[i]);
+		rcu_read_unlock();
+
+		rpu_prog_vif_smps(i,
+					  vif->addr,
+					  conf->smps_mode);
+	}
+
+	/* Check for change in Retry Limits */
+	if (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {
+		RPU_DEBUG_UMACIF("%s-80211IF:Retry Limits changed",
+				   priv->name);
+		RPU_DEBUG_UMACIF(" to %d and %d\n",
+				   conf->short_frame_max_tx_count,
+				   conf->long_frame_max_tx_count);
+	}
+
+	for (i = 0; i < MAX_VIFS; i++) {
+		if (!(changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS))
+			break;
+
+		if (!(priv->active_vifs & (1 << i)))
+			continue;
+
+		rcu_read_lock();
+		vif = rcu_dereference(priv->vifs[i]);
+		rcu_read_unlock();
+
+		rpu_prog_short_retry(i,
+					     vif->addr,
+					     conf->short_frame_max_tx_count);
+		rpu_prog_long_retry(i,
+					    vif->addr,
+					    conf->long_frame_max_tx_count);
+	}
+
+	RPU_DEBUG_UMACIF("%s: %s exit\n", UMAC_IF_TAG, __func__);
+prog_rpu_fail:
+	mutex_unlock(&priv->mutex);
+	return ret;
+}
+
+
+static u64 prepare_multicast(struct ieee80211_hw *hw,
+			     struct netdev_hw_addr_list *mc_list)
+{
+	struct img_priv *priv = hw->priv;
+	int i;
+	struct netdev_hw_addr *ha;
+	int mc_count = 0;
+	int ret = 0;
+
+	/*if (priv->fw_error) {
+		return 0;
+	}*/
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	if (priv->state != STARTED) {
+		RPU_ERROR_UMACIF("%s: state != STARTED\n", __func__);
+		return 0;
+	}
+
+	mc_count = netdev_hw_addr_list_count(mc_list);
+	{
+		if (mc_count > MCST_ADDR_LIMIT) {
+			mc_count = 0;
+			RPU_INFO_UMACIF("%s-80211IF:Disabling MCAST filter (cnt=%d)\n",
+				priv->name, mc_count);
+			goto out;
+		}
+	}
+	RPU_DEBUG_UMACIF("%s-80211IF: Multicast filter count\n", priv->name);
+	RPU_DEBUG_UMACIF("adding: %d removing: %d\n", mc_count,
+			priv->mc_filter_count);
+
+	if (priv->mc_filter_count > 0) {
+		/* Remove all previous multicast addresses from the LMAC */
+		for (i = 0; i < priv->mc_filter_count; i++)
+			rpu_prog_mcast_addr_cfg(priv->mc_filters[i],
+							WLAN_MCAST_ADDR_REM);
+	}
+
+	i = 0;
+
+	netdev_hw_addr_list_for_each(ha, mc_list) {
+		/* Prog the multicast address into the LMAC */
+		CALL_RPU(rpu_prog_mcast_addr_cfg,
+			  ha->addr,
+			  WLAN_MCAST_ADDR_ADD);
+		memcpy(priv->mc_filters[i], ha->addr, 6);
+		i++;
+	}
+
+	priv->mc_filter_count = mc_count;
+out:
+	return mc_count;
+prog_rpu_fail:
+	return ret;
+}
+
+
+static void configure_filter(struct ieee80211_hw *hw,
+		unsigned int changed_flags,
+		unsigned int *new_flags,
+		u64 mc_count)
+{
+	struct img_priv *priv = hw->priv;
+	int ret = 0;
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	mutex_lock(&priv->mutex);
+
+	changed_flags &= SUPPORTED_FILTERS;
+	*new_flags &= SUPPORTED_FILTERS;
+
+	/*if (priv->fw_error) {
+		mutex_unlock(&priv->mutex);
+		return;
+	}*/
+
+	if (priv->state != STARTED) {
+		RPU_ERROR_UMACIF("%s: state != STARTED\n", __func__);
+		mutex_unlock(&priv->mutex);
+		return;
+	}
+
+	if ((*new_flags & FIF_ALLMULTI) || (mc_count == 0)) {
+		/* Disable the multicast filter in LMAC */
+		RPU_DEBUG_UMACIF("%s-80211IF: Multicast filters disabled\n",
+				   priv->name);
+		CALL_RPU(rpu_prog_mcast_filter_control,
+			  MCAST_FILTER_DISABLE);
+	} else if (mc_count) {
+		/* Enable the multicast filter in LMAC */
+		RPU_DEBUG_UMACIF("%s-80211IF: Multicast filters enabled\n",
+			       priv->name);
+		CALL_RPU(rpu_prog_mcast_filter_control,
+			  MCAST_FILTER_ENABLE);
+	}
+
+	if (changed_flags == 0)
+		/* No filters which we support changed */
+		goto out;
+
+	if (wifi->params.production_test == 0) {
+		if (*new_flags & FIF_BCN_PRBRESP_PROMISC) {
+			/* Receive all beacons and probe responses */
+			RPU_DEBUG_UMACIF("%s-80211IF: RCV ALL bcns\n",
+				       priv->name);
+			CALL_RPU(rpu_prog_rcv_bcn_mode, RCV_ALL_BCNS);
+		} else {
+			/* Receive only network beacons and probe responses */
+			RPU_DEBUG_UMACIF("%s-80211IF: RCV NW bcns\n",
+					   priv->name);
+			CALL_RPU(rpu_prog_rcv_bcn_mode,
+				  RCV_ALL_NETWORK_ONLY);
+		}
+	}
+out:
+	if (wifi->params.production_test == 1) {
+		RPU_DEBUG_UMACIF("%s-80211IF: RCV ALL bcns\n", priv->name);
+		CALL_RPU(rpu_prog_rcv_bcn_mode, RCV_ALL_BCNS);
+	}
+
+prog_rpu_fail:
+	mutex_unlock(&priv->mutex);
+}
+
+
+static int conf_vif_tx(struct ieee80211_hw  *hw,
+		       struct ieee80211_vif *vif,
+		       unsigned short queue,
+		       const struct ieee80211_tx_queue_params *txq_params)
+{
+	struct img_priv *priv = hw->priv;
+	int vif_index, vif_active;
+	struct edca_params params;
+	struct ieee80211_vif *vif_local = NULL;
+
+	/*if (priv->fw_error) {
+		return 0;
+	}*/
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	mutex_lock(&priv->mutex);
+
+	for (vif_index = 0; vif_index < wifi->params.num_vifs; vif_index++) {
+		if (!(priv->active_vifs & (1 << vif_index)))
+			continue;
+
+		rcu_read_lock();
+		vif_local = rcu_dereference(priv->vifs[vif_index]);
+		rcu_read_unlock();
+
+		if (ether_addr_equal(vif_local->addr,
+				     vif->addr))
+			break;
+	}
+
+	if (WARN_ON(vif_index == wifi->params.num_vifs)) {
+		mutex_unlock(&priv->mutex);
+		return -EINVAL;
+	}
+
+	vif_active = 0;
+
+	if ((priv->active_vifs & (1 << vif_index)))
+		vif_active = 1;
+
+	memset(&params, 0, sizeof(params));
+	params.aifs = txq_params->aifs;
+	params.txop = txq_params->txop;
+	params.cwmin = txq_params->cw_min;
+	params.cwmax = txq_params->cw_max;
+	params.uapsd = txq_params->uapsd;
+
+	rpu_vif_set_edca_params(queue,
+					(struct umac_vif *)&vif->drv_priv,
+					&params,
+					vif_active);
+	mutex_unlock(&priv->mutex);
+	return 0;
+}
+
+
+static int set_key(struct ieee80211_hw *hw,
+		   enum set_key_cmd cmd,
+		   struct ieee80211_vif *vif,
+		   struct ieee80211_sta *sta,
+		   struct ieee80211_key_conf *key_conf)
+{
+
+	struct umac_key sec_key;
+	unsigned int result = 0;
+	struct img_priv *priv = hw->priv;
+	unsigned int cipher_type, key_type;
+	int vif_index;
+	struct umac_vif *uvif;
+
+	/*if (priv->fw_error) {
+		return 0;
+	}*/
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	uvif = ((struct umac_vif *)&vif->drv_priv);
+
+	memset(&sec_key, 0, sizeof(struct umac_key));
+
+	switch (key_conf->cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+		sec_key.key = key_conf->key;
+		cipher_type = CIPHER_TYPE_WEP40;
+		break;
+	case WLAN_CIPHER_SUITE_WEP104:
+		sec_key.key = key_conf->key;
+		cipher_type = CIPHER_TYPE_WEP104;
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		key_conf->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;
+		/* We get the key in the following form:
+		 * KEY (16 bytes) - TX MIC (8 bytes) - RX MIC (8 bytes)
+		 */
+		sec_key.key = key_conf->key;
+		sec_key.tx_mic = key_conf->key + 16;
+		sec_key.rx_mic = key_conf->key + 24;
+		cipher_type = CIPHER_TYPE_TKIP;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		sec_key.key = key_conf->key;
+		cipher_type = CIPHER_TYPE_CCMP;
+		break;
+	default:
+		result = -EOPNOTSUPP;
+		RPU_ERROR_CRYPTO("%s: not support cipher (%x)\n", __func__, key_conf->cipher);
+		mutex_unlock(&priv->mutex);
+		goto out;
+	}
+
+	g_cipher_type = cipher_type;
+	vif_index = ((struct umac_vif *)&vif->drv_priv)->vif_index;
+
+	mutex_lock(&priv->mutex);
+
+	if (cmd == SET_KEY) {
+		key_conf->hw_key_idx = 0; /* Don't really use this */
+
+		/* This flag indicate that it requires IV generation */
+		key_conf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
+
+
+		if (cipher_type == CIPHER_TYPE_WEP40 ||
+		    cipher_type == CIPHER_TYPE_WEP104) {
+			RPU_DEBUG_CRYPTO("%s-80211IF: ADD IF KEY (WEP).",
+					  priv->name);
+			RPU_DEBUG_CRYPTO(" vif_index = %d,", vif_index);
+			RPU_DEBUG_CRYPTO(" keyidx = %d, cipher_type = %d\n",
+					  key_conf->keyidx, cipher_type);
+
+			rpu_prog_if_key(vif_index,
+						vif->addr,
+						KEY_CTRL_ADD,
+						key_conf->keyidx,
+						cipher_type,
+						&sec_key);
+		} else if (sta) {
+			sec_key.peer_mac = sta->addr;
+
+			if (key_conf->flags & IEEE80211_KEY_FLAG_PAIRWISE)
+				key_type = KEY_TYPE_UCAST;
+			else
+				key_type = KEY_TYPE_BCAST;
+			RPU_DEBUG_CRYPTO("%s-80211IF: ADD PEER KEY (WPA/WPA2)",
+					  priv->name);
+			RPU_DEBUG_CRYPTO(" vif_index = %d,", vif_index);
+			RPU_DEBUG_CRYPTO(" keyidx = %d, keytype = %d,",
+					  key_conf->keyidx, key_type);
+			RPU_DEBUG_CRYPTO(" cipher_type = %d\n", cipher_type);
+
+			rpu_prog_peer_key(vif_index,
+						  vif->addr,
+						  KEY_CTRL_ADD,
+						  key_conf->keyidx,
+						  key_type,
+						  cipher_type,
+						  &sec_key);
+		} else {
+			key_type = KEY_TYPE_BCAST;
+
+			if (vif->type == NL80211_IFTYPE_STATION) {
+				sec_key.peer_mac =
+					(unsigned char *)vif->bss_conf.bssid;
+
+				memcpy(uvif->bssid,
+				       (vif->bss_conf.bssid),
+				       ETH_ALEN);
+				RPU_DEBUG_CRYPTO("%s-80211IF: ADD PEER KEY ",
+						  priv->name);
+				RPU_DEBUG_CRYPTO("(BCAST-STA). vif_index = %d",
+						  vif_index);
+				RPU_DEBUG_CRYPTO(", keyidx = %d, keytype = %d",
+						key_conf->keyidx, key_type);
+				RPU_DEBUG_CRYPTO(", cipher_type = %d\n",
+						  cipher_type);
+
+				rpu_prog_peer_key(vif_index,
+							  vif->addr,
+							  KEY_CTRL_ADD,
+							  key_conf->keyidx,
+							  key_type, cipher_type,
+							  &sec_key);
+
+			} else if (vif->type == NL80211_IFTYPE_AP) {
+				RPU_DEBUG_CRYPTO("%s-80211IF: ADD IF KEY ",
+						  priv->name);
+				RPU_DEBUG_CRYPTO("(BCAST-AP). vif_index = %d",
+						  vif_index);
+				RPU_DEBUG_CRYPTO(", keyidx = %d",
+						  key_conf->keyidx);
+				RPU_DEBUG_CRYPTO(", cipher_type = %d\n",
+						  cipher_type);
+
+				rpu_prog_if_key(vif_index,
+							vif->addr,
+							KEY_CTRL_ADD,
+							key_conf->keyidx,
+							cipher_type,
+							&sec_key);
+			} else {
+				/* ADHOC */
+				/* TODO: Check this works for IBSS RSN */
+				RPU_DEBUG_CRYPTO("%s-80211IF: ADD IF KEY ",
+						  priv->name);
+				RPU_DEBUG_CRYPTO("(BCAST-IBSS).vif_index = %d",
+						  vif_index);
+				RPU_DEBUG_CRYPTO(", keyidx = %d",
+						  key_conf->keyidx);
+				RPU_DEBUG_CRYPTO(", cipher_type = %d\n",
+						  cipher_type);
+
+				rpu_prog_if_key(vif_index,
+							vif->addr,
+							KEY_CTRL_ADD,
+							key_conf->keyidx,
+							cipher_type,
+							&sec_key);
+			}
+		}
+	} else if (cmd == DISABLE_KEY) {
+		if ((cipher_type == CIPHER_TYPE_WEP40) ||
+		    (cipher_type == CIPHER_TYPE_WEP104)) {
+			rpu_prog_if_key(vif_index,
+						vif->addr,
+						KEY_CTRL_DEL,
+						key_conf->keyidx,
+						cipher_type,
+						&sec_key);
+			RPU_DEBUG_CRYPTO("%s-80211IF: DEL IF KEY (WEP).",
+					  priv->name);
+			RPU_DEBUG_CRYPTO(" vif_index = %d, keyidx = %d",
+					  vif_index, key_conf->keyidx);
+			RPU_DEBUG_CRYPTO(", cipher_type = %d\n", cipher_type);
+		} else if (sta) {
+			sec_key.peer_mac = sta->addr;
+
+			if (key_conf->flags & IEEE80211_KEY_FLAG_PAIRWISE)
+				key_type = KEY_TYPE_UCAST;
+			else
+				key_type = KEY_TYPE_BCAST;
+			RPU_DEBUG_CRYPTO("%s-80211IF: DEL IF KEY (WPA/WPA2).",
+					  priv->name);
+			RPU_DEBUG_CRYPTO(" vif_index = %d, keyidx = %d",
+					  vif_index, key_conf->keyidx);
+			RPU_DEBUG_CRYPTO(", cipher_type = %d\n", cipher_type);
+
+			rpu_prog_peer_key(vif_index,
+						  vif->addr,
+						  KEY_CTRL_DEL,
+						  key_conf->keyidx,
+						  key_type,
+						  cipher_type,
+						  &sec_key);
+		} else {
+			if (vif->type == NL80211_IFTYPE_STATION) {
+				sec_key.peer_mac = uvif->bssid;
+				RPU_DEBUG_CRYPTO("%s-80211IF: DEL IF KEY ",
+						  priv->name);
+				RPU_DEBUG_CRYPTO("(BCAST-STA). vif_index = %d",
+						  vif_index);
+				RPU_DEBUG_CRYPTO(", keyidx = %d",
+						  key_conf->keyidx);
+				RPU_DEBUG_CRYPTO(", cipher_type = %d\n",
+						  cipher_type);
+
+				rpu_prog_peer_key(vif_index,
+							  vif->addr,
+							  KEY_CTRL_DEL,
+							  key_conf->keyidx,
+							  KEY_TYPE_BCAST,
+							  cipher_type,
+							  &sec_key);
+
+			} else if (vif->type == NL80211_IFTYPE_AP) {
+				RPU_DEBUG_CRYPTO("%s-80211IF: DEL IF KEY ",
+						  priv->name);
+				RPU_DEBUG_CRYPTO("(BCAST-AP). vif_index = %d",
+						  vif_index);
+				RPU_DEBUG_CRYPTO(", keyidx = %d",
+						  key_conf->keyidx);
+				RPU_DEBUG_CRYPTO(", cipher_type = %d\n",
+						  cipher_type);
+
+				rpu_prog_if_key(vif_index,
+							vif->addr,
+							KEY_CTRL_DEL,
+							key_conf->keyidx,
+							cipher_type,
+							&sec_key);
+			} else {
+				RPU_DEBUG_CRYPTO("%s-80211IF: DEL IF KEY ",
+						  priv->name);
+				RPU_DEBUG_CRYPTO("(BCAST-IBSS).vif_index = %d",
+						  vif_index);
+				RPU_DEBUG_CRYPTO(", keyidx = %d",
+						  key_conf->keyidx);
+				RPU_DEBUG_CRYPTO(", cipher_type = %d\n",
+						  cipher_type);
+
+				rpu_prog_if_key(vif_index,
+							vif->addr,
+							KEY_CTRL_DEL,
+							key_conf->keyidx,
+							cipher_type,
+							&sec_key);
+			}
+		}
+	}
+
+	mutex_unlock(&priv->mutex);
+
+out:
+	return result;
+}
+
+
+static void bss_info_changed(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif,
+			     struct ieee80211_bss_conf *bss_conf,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+                             u32 changed)
+#else
+			     unsigned int changed)
+#endif
+{
+	struct img_priv   *priv= hw->priv;
+
+	/*if (priv->fw_error) {
+		return;
+	}*/
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	dump_bss_changed_info(changed);
+
+	mutex_lock(&priv->mutex);
+
+	if (wifi->params.production_test || wifi->params.disable_beacon_ibss) {
+		/* Disable beacon generation when running pktgen
+		 * for performance
+		 */
+		changed &= ~BSS_CHANGED_BEACON_INT;
+		changed &= ~BSS_CHANGED_BEACON_ENABLED;
+	}
+
+	rpu_vif_bss_info_changed((struct umac_vif *)&vif->drv_priv,
+					 bss_conf,
+					 changed);
+	mutex_unlock(&priv->mutex);
+}
+
+/* 802.11 high throughput*/
+static void setup_ht_cap(struct ieee80211_sta_ht_cap *ht_info)
+{
+	int i;
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	memset(ht_info, 0, sizeof(*ht_info));
+	ht_info->ht_supported = true;
+	//RPU_DEBUG_IF("SETUP HT CALLED\n");
+
+	ht_info->cap = 0;
+	ht_info->cap |= IEEE80211_HT_CAP_MAX_AMSDU;
+	/*We support SMPS*/
+
+	ht_info->ampdu_factor = IEEE80211_HT_MAX_AMPDU_32K;
+	ht_info->ampdu_density = IEEE80211_HT_MPDU_DENSITY_4;
+
+	memset(&ht_info->mcs, 0, sizeof(ht_info->mcs));
+
+	if (wifi->params.max_tx_streams != wifi->params.max_rx_streams) {
+		ht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_RX_DIFF;
+		ht_info->mcs.tx_params |= ((wifi->params.max_tx_streams - 1)
+				<< IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT);
+	}
+
+	ht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_DEFINED;
+
+	for (i = 0; i < wifi->params.max_rx_streams; i++)
+#ifdef RK3036_DONGLE	
+		ht_info->mcs.rx_mask[i] = 0x1f;
+#else
+		ht_info->mcs.rx_mask[i] = 0xff;
+#endif
+}
+
+
+
+static void set_hw_flags(struct ieee80211_hw *hw)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	ieee80211_hw_set(hw, SIGNAL_DBM);
+	ieee80211_hw_set(hw, SUPPORTS_PS);
+	ieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);
+	ieee80211_hw_set(hw, AMPDU_AGGREGATION);
+	ieee80211_hw_set(hw, MFP_CAPABLE);
+	ieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);
+	ieee80211_hw_set(hw, SUPPORTS_PER_STA_GTK);
+	ieee80211_hw_set(hw, CONNECTION_MONITOR);
+#else
+	hw->flags = IEEE80211_HW_SIGNAL_DBM;
+	hw->flags |= IEEE80211_HW_SUPPORTS_PS;
+	hw->flags |= IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING;
+	hw->flags |= IEEE80211_HW_AMPDU_AGGREGATION;
+	hw->flags |= IEEE80211_HW_MFP_CAPABLE;
+	hw->flags |= IEEE80211_HW_REPORTS_TX_ACK_STATUS;
+	hw->flags |= IEEE80211_HW_SUPPORTS_PER_STA_GTK;
+	hw->flags |= IEEE80211_HW_CONNECTION_MONITOR;
+#endif
+	if (!wifi->params.disable_power_save &&
+	    !wifi->params.disable_sm_power_save) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		hw->wiphy->features |= NL80211_FEATURE_STATIC_SMPS |
+					NL80211_FEATURE_DYNAMIC_SMPS;
+#else
+		hw->flags |= IEEE80211_HW_SUPPORTS_STATIC_SMPS;
+		hw->flags |= IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS;
+#endif
+	}
+#ifdef RPU_SLEEP_ENABLE
+#ifdef PS_SLEEP_TEST
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	ieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);
+#else
+	hw->flags |= IEEE80211_HW_SUPPORTS_DYNAMIC_PS;
+#endif
+#endif
+#endif
+}
+
+static void init_hw(struct ieee80211_hw *hw)
+{
+	struct img_priv  *priv= (struct img_priv *)hw->priv;
+	int num_if_comb = 0;
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	/* Supported Interface Types and other Default values*/
+	hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+				     BIT(NL80211_IFTYPE_ADHOC) |
+				     BIT(NL80211_IFTYPE_AP) |
+				     BIT(NL80211_IFTYPE_P2P_CLIENT) |
+				     BIT(NL80211_IFTYPE_P2P_GO);
+
+	hw->wiphy->iface_combinations = if_comb;
+
+	num_if_comb = (sizeof(if_comb) /
+		       sizeof(struct ieee80211_iface_combination));
+	hw->wiphy->n_iface_combinations = num_if_comb;
+
+	set_hw_flags(hw);
+	hw->wiphy->max_scan_ssids = MAX_NUM_SSIDS; /* 4 */
+	 /* Low priority bg scan */
+	hw->wiphy->features |= NL80211_FEATURE_LOW_PRIORITY_SCAN;
+	hw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
+	hw->max_listen_interval = 10;
+	hw->wiphy->max_remain_on_channel_duration = 5000; /*ROC*/
+	hw->offchannel_tx_hw_queue = WLAN_AC_VO;
+	hw->max_rates = 4;
+	hw->max_rate_tries = 5;
+	hw->queues = 4;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0))
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	/*
+	 * The value is a bit-shift of 1 second, 
+	 * so 5 is ~31ms (1000ms >> 5) of queued data
+	 */
+	hw->tx_sk_pacing_shift = 5;
+#endif
+
+	//hw->max_rx_aggregation_subframes = 32;
+
+	/* Size */
+	hw->extra_tx_headroom = 0;
+	hw->vif_data_size = sizeof(struct umac_vif);
+	hw->sta_data_size = sizeof(struct umac_sta);
+
+	if (wifi->params.dot11g_support) {
+		hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &band_2ghz;
+		if (ht_support)
+			setup_ht_cap(&hw->wiphy->bands[IEEE80211_BAND_2GHZ]->ht_cap);
+	}
+
+
+	memset(hw->wiphy->addr_mask, 0, sizeof(hw->wiphy->addr_mask));
+
+	if (wifi->params.num_vifs == 1) {
+		hw->wiphy->addresses = NULL;
+		SET_IEEE80211_PERM_ADDR(hw, priv->if_mac_addresses[0].addr);
+	} else {
+		hw->wiphy->n_addresses = wifi->params.num_vifs;
+		hw->wiphy->addresses = priv->if_mac_addresses;
+	}
+
+	hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
+	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
+	hw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0))
+#ifdef WOWLAN_SUPPORT
+	hw->wiphy->wowlan = &uccp_wowlan_support;
+#else
+	hw->wiphy->wowlan = NULL;
+#endif
+#else
+        hw->wiphy->wowlan.flags = WIPHY_WOWLAN_ANY;
+#endif
+#endif
+}
+
+
+static int ampdu_action(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+				struct ieee80211_ampdu_params *params)
+#else
+				enum ieee80211_ampdu_mlme_action action,
+				struct ieee80211_sta *sta,
+				u16 tid, u16 *ssn, u8 buf_size)
+#endif
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+        struct ieee80211_sta *sta = params->sta;
+        enum ieee80211_ampdu_mlme_action action = params->action;
+        u16 tid = params->tid;
+        u16 *ssn = &params->ssn;
+	u8 buf_size = params->buf_size;
+#endif
+	int ret = 0;
+	unsigned int val = 0;
+	struct img_priv *priv = (struct img_priv *)hw->priv;
+
+	/*if (priv->fw_error) {
+		return 0;
+	}*/
+
+	RPU_DEBUG_UMACIF("%s: %s: tid = %d, ssn = %d, buf_szie = %d\n",
+					UMAC_IF_TAG, __func__, tid, (ssn!=NULL)?*ssn:0, buf_size);
+	dump_ampdu_action_info(action);
+	switch (action) {
+	case IEEE80211_AMPDU_RX_START:
+		{
+		val = tid | TID_INITIATOR_AP;
+		priv->tid_info[val].tid_state = TID_STATE_AGGR_START;
+		priv->tid_info[val].ssn = *ssn;
+		rpu_prog_ba_session_data(1,
+						 tid,
+						 &priv->tid_info[val].ssn,
+						 1,
+						 vif->addr,
+				   (unsigned char *)(vif->bss_conf.bssid));
+		}
+		break;
+	case IEEE80211_AMPDU_RX_STOP:
+		{
+		val = tid | TID_INITIATOR_AP;
+		priv->tid_info[val].tid_state = TID_STATE_AGGR_STOP;
+		rpu_prog_ba_session_data(0,
+						 tid,
+						 &priv->tid_info[val].ssn,
+						 1,
+						 vif->addr,
+				   (unsigned char *)(vif->bss_conf.bssid));
+		}
+		break;
+	case IEEE80211_AMPDU_TX_START:
+		{
+		val = tid | TID_INITIATOR_STA;
+		ieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		priv->tid_info[val].tid_state = TID_STATE_AGGR_START;
+		priv->tid_info[val].ssn = *ssn;
+		}
+		break;
+	case IEEE80211_AMPDU_TX_STOP_FLUSH:
+	case IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:
+	case IEEE80211_AMPDU_TX_STOP_CONT:
+		{
+		val = tid | TID_INITIATOR_STA;
+		priv->tid_info[val].tid_state = TID_STATE_AGGR_STOP;
+		ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		}
+		break;
+	case IEEE80211_AMPDU_TX_OPERATIONAL:
+		{
+		val = tid | TID_INITIATOR_STA;
+		priv->tid_info[val].tid_state = TID_STATE_AGGR_OPERATIONAL;
+		}
+		break;
+	default:
+		RPU_ERROR_UMACIF("%s: Invalid command (%d), ignoring\n",
+		       __func__, action);
+	}
+	return ret;
+}
+
+
+static int set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
+{
+	struct img_priv *priv = (struct img_priv *)hw->priv;
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	/* Maximum no of antenna supported =2 */
+	if (!tx_ant || (tx_ant & ~3) || !rx_ant || (rx_ant & ~3)) {
+		RPU_ERROR_UMACIF("%s: invalid antenna parameter (%x, %x)\n", __func__, tx_ant, rx_ant);
+		return -EINVAL;
+	}
+
+	priv->tx_antenna = (tx_ant & 3);
+
+	return 0;
+}
+
+
+
+/* Needed in case of IBSS to send out probe responses when we are beaconing */
+static int tx_last_beacon(struct ieee80211_hw *hw)
+{
+	struct img_priv *priv = (struct img_priv *)hw->priv;
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	return priv->tx_last_beacon;
+}
+
+#ifdef HW_SCAN_TIMEOUT_ABORT
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+extern void scan_timer_expiry(struct timer_list *t);
+#else
+extern void scan_timer_expiry(unsigned long data);
+#endif
+static void init_scan_timeout_timer (struct img_priv *priv)
+{
+	RPU_DEBUG_UMACIF("%s: %p\n", __func__, priv);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+	timer_setup(&priv->scan_timer, scan_timer_expiry, 0);
+#else
+	init_timer(&priv->scan_timer);
+	priv->scan_timer.data = (unsigned long)NULL;
+	priv->scan_timer.function = scan_timer_expiry;
+#endif
+	priv->in_scan_timeout = 0;
+}
+
+static void start_scan_timeout_timer(struct img_priv *priv, int p2p)
+{
+	RPU_DEBUG_UMACIF("%s: %p\n", __func__, priv);
+#ifdef RK3036_DONGLE	
+	if (p2p)
+		mod_timer(&priv->scan_timer, jiffies + 2 * HZ);
+	else
+#endif	
+		mod_timer(&priv->scan_timer, jiffies + HW_SCAN_TIMEOUT * HZ);
+}
+
+static void deinit_scan_timeout_timer (struct img_priv *priv)
+{
+	RPU_DEBUG_UMACIF("%s: %p\n", __func__, priv);
+	del_timer(&priv->scan_timer);
+}
+#endif
+
+#ifdef ENABLE_SPLIT_MULT_SSID_SCAN
+static int split_mult_ssid_scan(struct img_priv *priv, int do_scan, int vif_index)
+{
+	struct scan_req *scan_req = &priv->remain_scan_req;
+	int ret = 0;
+
+	//mutex_lock(&priv->scan_mutex);
+
+	if (scan_req->n_ssids > 0) {
+		RPU_DEBUG_SCAN("%s: n_ssids = %d, do_scan = %d\n",
+							__func__, scan_req->n_ssids, do_scan);	
+		//mutex_unlock(&priv->scan_mutex);
+		
+		if (do_scan) {
+			struct scan_req req;
+
+			ret = 1;
+			memcpy(&req, scan_req, sizeof(struct scan_req));
+			req.n_ssids = 1;
+			rpu_scan(vif_index, &req);
+		}
+
+		//mutex_lock(&priv->scan_mutex);
+		scan_req->n_ssids -= 1;
+		if (scan_req->n_ssids > 0) {
+			memcpy(&scan_req->ssids[0], &scan_req->ssids[1], scan_req->n_ssids*sizeof(struct ssid_desc));
+		}
+	}
+
+	//mutex_unlock(&priv->scan_mutex);
+
+	return ret;
+}
+#endif
+
+int scan(struct ieee80211_hw *hw,
+	 struct ieee80211_vif *vif,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	 struct ieee80211_scan_request *hw_req)
+#else
+	 struct cfg80211_scan_request *req)
+#endif
+{
+	struct umac_vif *uvif = (struct umac_vif *)vif->drv_priv;
+	struct scan_req scan_req = {0};
+	int i = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	struct cfg80211_scan_request *req = &hw_req->req;
+#endif
+
+	/*if (uvif->priv->fw_error) {
+		return -EBUSY;
+	}*/
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	scan_req.n_ssids = req->n_ssids;
+	scan_req.n_channels = req->n_channels;
+	scan_req.ie_len = req->ie_len;
+
+	if (wifi->params.hw_scan_status != HW_SCAN_STATUS_NONE) {
+		RPU_INFO_UMACIF("%s: Already in HW SCAN State\n", __func__);
+		return -EBUSY; /* Already in HW SCAN State */
+	}
+
+	if (uvif->priv->roc_params.roc_starting == 1) {
+		RPU_INFO_UMACIF("%s: Already in roc_starting State\n", __func__);
+		return -EBUSY;
+	}
+
+#ifdef RK3036_DONGLE
+	if (req->n_channels == 3 && req->no_cck) {
+		ieee80211_scan_completed(uvif->priv->hw, false);
+		return 0;
+	}
+#endif
+
+	/* Keep track of HW Scan requests and compeltes */
+	wifi->params.hw_scan_status = HW_SCAN_STATUS_PROGRESS;
+
+	if (uvif->priv->params->production_test == 1) {
+		/* Drop scan, its just intended for IBSS
+		 * and some data traffic
+		 */
+		if (wifi->params.hw_scan_status != HW_SCAN_STATUS_NONE) {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+			struct cfg80211_scan_info info = {
+				.aborted = false,
+ 			};
+			ieee80211_scan_completed(uvif->priv->hw, &info);
+#else
+			ieee80211_scan_completed(uvif->priv->hw, false);
+#endif
+			wifi->params.hw_scan_status = HW_SCAN_STATUS_NONE;
+		}
+
+		return 0;
+	}
+
+#ifdef HW_SCAN_TIMEOUT_ABORT
+	start_scan_timeout_timer(uvif->priv, req->no_cck && (req->n_channels <= 3));
+#endif
+
+	if (req->ie_len)
+		memcpy(scan_req.ie, req->ie, req->ie_len);
+
+	for (i = 0; i < req->n_channels; i++) {
+		scan_req.center_freq[i] = req->channels[i]->center_freq;
+		scan_req.freq_max_power[i] = req->channels[i]->max_power;
+		scan_req.chan_flags[i] = req->channels[i]->flags;
+		/* The type of scan comes from mac80211 so its taken care of */
+	}
+
+	scan_req.p2p_probe = req->no_cck;
+
+	/* For hostapd scan (40MHz) and scan_type=passive, n_ssids=0
+	 * and req->ssids is NULL
+	 */
+	if (req->n_ssids > 0) {
+		for (i = 0; i < req->n_ssids; i++) {
+			scan_req.ssids[i].ssid_len = req->ssids[i].ssid_len;
+			if (req->ssids[i].ssid_len > 0)
+				memcpy(scan_req.ssids[i].ssid,
+				       req->ssids[i].ssid,
+				       req->ssids[i].ssid_len);
+		}
+	}
+
+	uvif->priv->p2p_scan = scan_req.p2p_probe;
+#ifdef ENABLE_DAPT
+	dapt_scan(uvif->priv);
+#endif
+
+#ifdef ENABLE_SPLIT_MULT_SSID_SCAN
+	if (req->n_ssids > 1) {
+		memcpy(&uvif->priv->remain_scan_req, &scan_req, sizeof(struct scan_req));
+		uvif->priv->scan_req_vif_iface = uvif->vif_index;
+
+		RPU_DEBUG_SCAN("start split ssid scan: n_ssids = %d\n", scan_req.n_ssids);
+		for (i = 0; i < scan_req.n_ssids; i++) {
+			if (scan_req.ssids[i].ssid_len != 0)
+				RPU_DEBUG_SCAN("SSID: %s\n", scan_req.ssids[i].ssid);
+			else
+				RPU_DEBUG_SCAN("SSID: EMPTY\n");
+		}
+
+		split_mult_ssid_scan(uvif->priv, 0, uvif->vif_index);
+		scan_req.n_ssids = 1;
+	} else {
+		uvif->priv->remain_scan_req.n_ssids = 0;
+	}
+#endif
+
+	return rpu_scan(uvif->vif_index, &scan_req);
+}
+
+
+void rpu_scan_complete(void *context,
+			       struct host_event_scanres *scan_res,
+			       unsigned char *skb,
+			       unsigned int len)
+{
+	struct img_priv *priv = (struct img_priv *)context;
+
+#ifdef ENABLE_SPLIT_MULT_SSID_SCAN
+	if (split_mult_ssid_scan(priv, 1, priv->scan_req_vif_iface)) {
+		// split_mult_ssid_scan do not finish
+		priv->stats->umac_scan_complete++;
+		return;
+	}
+#endif
+
+	RPU_DEBUG_SCAN("Event Scan Complete from RPU:");
+	RPU_DEBUG_SCAN(" More_results: 0, if_index = %d, Scan is Completed\n", scan_res->if_index);
+	/* There can be a race where we receive remove_interface and
+	 * abort the scan(1)
+	 * But we get scan_complete from the FW(2), this check will make
+	 * sure we are not calling scan_complete when we have already
+	 * aborted the scan. Eg: Killing wpa_supplicant in middle of
+	 * scanning
+	 */
+	spin_lock_bh(&priv->scan_cancel_lock);
+	if (wifi->params.hw_scan_status != HW_SCAN_STATUS_NONE) {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+		struct cfg80211_scan_info info = {
+			.aborted = false,
+		};
+#endif
+
+		/* Keep track of HW Scan requests and compeltes */
+		wifi->params.hw_scan_status = HW_SCAN_STATUS_NONE;
+		spin_unlock_bh(&priv->scan_cancel_lock);
+
+		priv->stats->umac_scan_complete++;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+		ieee80211_scan_completed(priv->hw, &info);
+#else
+		ieee80211_scan_completed(priv->hw, false);
+#endif
+
+#ifdef ENABLE_DAPT
+		dapt_scan_complete(priv);
+#endif
+	} else {
+		spin_unlock_bh(&priv->scan_cancel_lock);
+	}
+
+}
+
+void cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	//struct umac_vif *uvif = (struct umac_vif *)vif->drv_priv;
+	struct umac_vif *uvif = NULL;
+	struct img_priv *priv = NULL;
+	int lock = 1;
+
+	if(vif != NULL)
+		uvif = (struct umac_vif *)vif->drv_priv;
+	else
+		lock = 0;
+	
+	priv= (struct img_priv *)hw->priv;
+	if (wifi->hw == NULL || priv->state != STARTED)
+		return;
+
+	/*if (priv->fw_error) {
+		return;
+	}*/
+
+#ifdef ENABLE_SPLIT_MULT_SSID_SCAN
+	//mutex_lock(&priv->scan_mutex);
+	priv->remain_scan_req.n_ssids = 0;
+	//mutex_unlock(&priv->scan_mutex);
+#endif
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+
+	spin_lock_bh(&priv->scan_cancel_lock);
+	if (wifi->params.hw_scan_status == HW_SCAN_STATUS_PROGRESS) {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+		struct cfg80211_scan_info info = {
+ 			.aborted = true,
+		};
+#endif
+		wifi->params.hw_scan_status = HW_SCAN_STATUS_NONE;
+		spin_unlock_bh(&priv->scan_cancel_lock);
+
+		RPU_INFO_UMACIF("Aborting pending scan request...\n");
+		
+		if(vif != NULL)
+		{
+			//when FW error and recovery, no need to call rpu scan abort
+			priv->scan_abort_done = 0;
+			if (rpu_scan_abort(uvif->vif_index)) {
+				return;
+			}
+
+			//As wait for scan abort should always return 0
+			wait_for_scan_abort(priv);
+		}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4, 6, 0))
+		ieee80211_scan_completed(hw, &info);
+#else
+		ieee80211_scan_completed(hw, true);
+#endif
+		priv->stats->umac_scan_complete++;
+
+#ifdef ENABLE_DAPT
+		dapt_scan_complete(priv);
+#endif
+#ifdef RK3036_DONGLE
+		if (priv->in_scan_timeout /*&& !priv->p2p_scan*/) {
+#else
+		if (priv->in_scan_timeout && !priv->p2p_scan) {
+#endif
+			priv->in_scan_timeout = 0;
+			hpriv->fw_error_counter_scan++;
+			rk915_io_reset(hpriv);
+			rk915_signal_io_error(FW_ERR_SDIO);
+		}
+ 	} else {
+		spin_unlock_bh(&priv->scan_cancel_lock);
+ 	}
+}
+
+
+int set_rts_threshold(struct ieee80211_hw *hw,
+		      u32 value)
+{
+	struct img_priv *priv = NULL;
+
+	priv = (struct img_priv *)hw->priv;
+	/*if thres>=2347 (default case) hostapd sends down (u32) -1*/
+	if (value > 65536)
+		priv->rts_threshold = 65536;
+	else
+		priv->rts_threshold = value;
+	return 0;
+
+}
+
+
+#if 0
+int load_fw(struct ieee80211_hw *hw)
+{
+        int err = 0;
+        int i = 0;
+        struct img_priv *dev = (struct img_priv *)hw->priv;
+        const struct firmware *fw = NULL;
+
+        do {
+                err = request_firmware(&fw, bin_name[i], dev->dev);
+
+		/* Proceed even if there is no patch file
+		 */
+		if (err)
+			err = fwldr_load_fw(NULL, fw->size, i);
+		else
+			err = fwldr_load_fw(fw->data, fw->size, i);
+
+                if (err == FWLDR_SUCCESS)
+                        pr_info("%s is loaded\n", bin_name[i]);
+                else
+                        pr_err("Loading of %s failed\n", bin_name[i]);
+
+                release_firmware(fw);
+
+                i++;
+
+        } while ((i < FWLDR_NUM_BINS) && (!err));
+
+        return err;
+}
+#endif
+
+
+
+
+static struct ieee80211_ops ops = {
+	.tx                 = tx,
+	.start              = start,
+	.stop               = stop,
+	.add_interface      = add_interface,
+	.remove_interface   = remove_interface,
+	.change_interface   = change_interface,
+	.config             = config,
+	.prepare_multicast  = prepare_multicast,
+	.configure_filter   = configure_filter,
+	.sw_scan_start      = NULL,
+	.sw_scan_complete   = NULL,
+	.get_stats          = NULL,
+	.sta_notify         = NULL,
+	.conf_tx            = conf_vif_tx,
+	.bss_info_changed   = bss_info_changed,
+	.set_tim            = NULL,
+	.set_key            = set_key,
+	.tx_last_beacon     = tx_last_beacon,
+	.ampdu_action       = ampdu_action,
+	.set_antenna	    = set_antenna,
+	.remain_on_channel = remain_on_channel,
+	.cancel_remain_on_channel = cancel_remain_on_channel,
+#ifdef CONFIG_PM
+	.suspend	    = img_suspend,
+	.resume		    = img_resume,
+#endif
+	.hw_scan	    = scan,
+	.cancel_hw_scan	    = cancel_hw_scan,
+	.set_rekey_data     = NULL,
+	.set_rts_threshold  = set_rts_threshold,
+};
+
+void rpu_exit(void)
+{
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+
+	wifi->params.pkt_gen_val = 0;
+
+#ifdef HW_SCAN_TIMEOUT_ABORT
+	deinit_scan_timeout_timer(wifi->hw->priv);
+#endif
+#ifdef RK3036_DONGLE
+    deinit_roc_timeout_timer(wifi->hw->priv);
+#endif
+#ifdef ENABLE_KEEP_ALIVE
+	deinit_keep_alive_timer(wifi->hw->priv);
+#endif
+
+	if (wifi->hw) {
+		ieee80211_unregister_hw(wifi->hw);
+		ieee80211_free_hw(wifi->hw);
+		wifi->hw = NULL;
+	}
+}
+
+void init_mac_addr(void)
+{
+	if (rockchip_wifi_mac_addr(vif_macs[0]) != 0) {
+		random_ether_addr(vif_macs[0]);
+	}
+	img_ether_addr_copy(vif_macs[1], vif_macs[0]);
+
+	/* Set the Locally Administered bit*/
+	vif_macs[1][0] |= 0x02;
+
+	/* Increment the MSB by 1 (excluding 2 special bits)*/
+	vif_macs[1][0] += (1 << 2);
+}
+
+int rpu_init(void)
+{
+	struct ieee80211_hw *hw;
+	int error;
+	struct img_priv *priv = NULL;
+	int i;
+
+	RPU_DEBUG_UMACIF("%s: %s\n", UMAC_IF_TAG, __func__);
+	/* Allocate new hardware device */
+	hw = ieee80211_alloc_hw(sizeof(struct img_priv), &ops);
+
+	if (hw == NULL) {
+		RPU_ERROR_UMACIF("Failed to allocate memory for ieee80211_hw\n");
+		error = -ENOMEM;
+		goto out;
+	}
+
+	priv = (struct img_priv *)hw->priv;
+	memset(priv, 0, sizeof(struct img_priv));
+
+	init_mac_addr();
+	RPU_INFO_UMACIF("MAC ADDR: %pM\n", vif_macs);
+
+	priv->dev = hal_ops.get_dev();
+	SET_IEEE80211_DEV(hw, priv->dev);
+
+	mutex_init(&priv->mutex);
+	mutex_init(&priv->scan_mutex);
+	mutex_init(&priv->scan_cancel_mutex);
+#ifdef ENABLE_DAPT	
+	spin_lock_init(&priv->dapt_lock);
+#endif
+	spin_lock_init(&priv->bcast_lock);
+	spin_lock_init(&priv->scan_cancel_lock);
+
+	spin_lock_init(&priv->roc_lock);
+	priv->state = STOPPED;
+	priv->active_vifs = 0;
+	priv->txpower = DEFAULT_TX_POWER;
+	priv->tx_antenna = DEFAULT_TX_ANT_SELECT;
+	priv->rts_threshold = DEFAULT_RTS_THRESHOLD;
+	strncpy(priv->name, RPU_DRIVER_NAME, 11);
+	priv->name[11] = '\0';
+
+	for (i = 0; i < wifi->params.num_vifs; i++)
+		img_ether_addr_copy(priv->if_mac_addresses[i].addr, vif_macs[i]);
+
+	/* Initialize HW parameters */
+	init_hw(hw);
+	priv->hw = hw;
+	priv->params = &wifi->params;
+	priv->stats = &wifi->stats;
+	priv->fw_info = &wifi->fw_info;
+	priv->umac_proc_dir_entry = wifi->umac_proc_dir_entry;
+	priv->current_vif_count = 0;
+	priv->stats->system_rev = system_rev;
+
+	/*Register hardware*/
+	error = ieee80211_register_hw(hw);
+
+	/* Production test hack: Set all channel flags to 0 to allow IBSS
+	 * creation in all channels
+	 */
+	if (wifi->params.production_test && !error) {
+		enum ieee80211_band band;
+		struct ieee80211_supported_band *sband;
+
+		for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+			sband = hw->wiphy->bands[band];
+			if (sband)
+				for (i = 0; i < sband->n_channels; i++)
+					sband->channels[i].flags = 0;
+		}
+	}
+
+#ifdef HW_SCAN_TIMEOUT_ABORT
+	init_scan_timeout_timer(priv);
+#endif
+#ifdef RK3036_DONGLE
+    init_roc_timeout_timer(priv);
+#endif
+#ifdef ENABLE_KEEP_ALIVE
+	init_keep_alive_timer(priv);
+#endif
+	init_vif_info(priv);
+
+	if (!error) {
+		wifi->hw = hw;
+		//rpu_if_init(priv, priv->name);
+		goto out;
+	} else {
+		RPU_ERROR_UMACIF("%s: ieee80211_register_hw failed\n", __func__);
+		rpu_exit();
+		goto out;
+	}
+
+out:
+	return error;
+}
+
+#ifdef CONFIG_WIRELESS_EXT
+int iw_send_hang_event(struct img_priv *priv)
+{
+	struct net_device *dev;
+	union iwreq_data wrqu;
+	char extra[IW_CUSTOM_MAX + 1];
+	int cmd;
+
+	dev = (struct net_device *)priv->net_dev;
+	if (!dev) {
+		RPU_ERROR_UMACIF("%s failed\n", __func__);
+		return -1;
+	}
+
+	cmd = IWEVCUSTOM;
+	memset(&wrqu, 0, sizeof(wrqu));
+
+	strcpy(extra, "HANG");
+	wrqu.data.length = strlen(extra);
+	wireless_send_event(dev, cmd, &wrqu, extra);
+	RPU_INFO_UMACIF("Send IWEVCUSTOM Event as %s\n", extra);
+
+	return 0;
+}
+#endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/utils.c b/drivers/net/wireless/rockchip_wlan/rk915/src/utils.c
new file mode 100755
index 000000000..0a802e507
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/utils.c
@@ -0,0 +1,468 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include "core.h"
+#include "if_io.h"
+
+int wait_for_fw_error_cmd_done(struct img_priv *priv);
+
+int conv_str_to_byte(unsigned char *byte,
+		     unsigned char *str,
+		     int len)
+{
+	int  i, j = 0;
+	unsigned char ch, val = 0;
+
+	for (i = 0; i < (len * 2); i++) {
+		/*convert to lower*/
+		ch = ((str[i] >= 'A' && str[i] <= 'Z') ? str[i] + 32 : str[i]);
+
+		if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))
+			return -1;
+
+		if (ch >= '0' && ch <= '9')  /*check is digit*/
+			ch = ch - '0';
+		else
+			ch = ch - 'a' + 10;
+
+		val += ch;
+
+		if (!(i%2))
+			val <<= 4;
+		else {
+			byte[j] = val;
+			j++;
+			val = 0;
+		}
+	}
+
+	return 0;
+}
+
+int wait_for_scan_abort(struct img_priv *priv)
+{
+	int count;
+
+	count = 0;
+
+check_scan_abort_complete:
+	if (!hpriv->fw_error && !priv->scan_abort_done && (count < SCAN_ABORT_TIMEOUT_TICKS)) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (schedule_timeout(1) == 0)
+			count++;
+
+		goto check_scan_abort_complete;
+	}
+
+	if (!priv->scan_abort_done) {
+		RPU_ERROR_SCAN("%s-UMAC: No SCAN_ABORT_DONE after %ld ticks\n",
+			   priv->name, SCAN_ABORT_TIMEOUT_TICKS);
+		return 0;
+	}
+
+	RPU_INFO_SCAN("%s-UMAC: Scan abort complete after %d timer ticks\n",
+					priv->name,
+					count);
+
+	return 0;
+
+}
+
+int wait_for_scan_complete(struct img_priv *priv)
+{
+        int count;
+
+        count = 0;
+
+check_scan_complete:
+        if (!hpriv->fw_error && wifi->params.hw_scan_status != HW_SCAN_STATUS_NONE &&
+		(count < msecs_to_jiffies(5000))) {
+                current->state = TASK_INTERRUPTIBLE;
+
+                if (schedule_timeout(1) == 0)
+                        count++;
+
+                goto check_scan_complete;
+        }
+
+        if (wifi->params.hw_scan_status != HW_SCAN_STATUS_NONE) {
+                RPU_ERROR_SCAN("%s-UMAC: No Scan complete after %ld ticks\n",
+                           priv->name, msecs_to_jiffies(5000));
+                return 0;
+        }
+
+        RPU_INFO_SCAN("%s-UMAC: Scan complete after %d timer ticks\n",
+                                        priv->name,
+                                        count);
+
+        return 0;
+
+}
+
+int wait_for_cancel_hw_roc(struct img_priv *priv)
+{
+	int count = 0;
+
+check_cancel_hw_roc_complete:
+	if (!hpriv->fw_error && !priv->cancel_hw_roc_done && (count < CANCEL_HW_ROC_TIMEOUT_TICKS)) {
+		current->state = TASK_INTERRUPTIBLE;
+		if (schedule_timeout(1) == 0)
+			count++;
+		goto check_cancel_hw_roc_complete;
+	}
+
+	if (!priv->cancel_hw_roc_done) {
+		RPU_ERROR_ROC("%s-UMAC: Warning: Didn't get CANCEL_HW_ROC_DONE after %ld timer ticks\n",
+		       priv->name,
+		       CANCEL_HW_ROC_TIMEOUT_TICKS);
+		if (hpriv->fw_error_processing)
+			return 0;
+		return -1;
+	}
+
+	RPU_DEBUG_ROC("%s-UMAC: Cancel HW RoC complet after %d timer ticks\n",
+					priv->name,
+					count);
+
+	return 0;
+
+}
+
+int wait_for_channel_prog_complete(struct img_priv *priv)
+{
+	int count;
+
+	count = 0;
+
+	if (hpriv->during_pm_resume)
+		return 0;
+
+check_ch_prog_complete:
+	if (!hpriv->fw_error && !priv->chan_prog_done && (count < CH_PROG_TIMEOUT_TICKS)) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (schedule_timeout(1) == 0)
+			count++;
+
+		goto check_ch_prog_complete;
+	}
+
+	if (!priv->chan_prog_done) {
+		RPU_ERROR_UMACIF("%s-UMAC: No channel prog done after %ld ticks\n",
+			   priv->name, CH_PROG_TIMEOUT_TICKS);
+		return -1;
+	}
+
+	RPU_DEBUG_UMACIF("%s-UMAC: Channel Prog Complete after %d timer ticks\n",
+			priv->name, count);
+
+	return 0;
+
+}
+
+
+int wait_for_reset_complete(struct img_priv *priv, int enable)
+{
+	int count;
+	int timeout;
+
+	count = 0;
+
+	if (enable)
+		timeout = RESET_TIMEOUT_TICKS;
+	else
+		timeout = msecs_to_jiffies(3000);
+
+check_reset_complete:
+	if (/*!hpriv->fw_error &&*/ !priv->reset_complete && (count < timeout)) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (schedule_timeout(1) == 0)
+			count++;
+
+		goto check_reset_complete;
+	}
+
+	if (!priv->reset_complete) {
+		RPU_ERROR_MAIN("%s-UMAC: No reset complete after %d ticks\n",
+			   priv->name, timeout);
+		rk915_signal_io_error(FW_ERR_RESET_CMD);
+		wait_for_fw_error_cmd_done(priv);
+		return -1;
+	}
+
+	RPU_DEBUG_MAIN("%s-UMAC: Reset complete after %d timer ticks\n",
+		   priv->name, count);
+	return 0;
+
+}
+
+int wait_for_read_csr_cmp(struct img_priv *priv)
+{
+	int count;
+
+	count = 0;
+
+check_read_csr_complete:
+	if (!hpriv->fw_error && !priv->read_csr_complete && (count < msecs_to_jiffies(1000))) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (schedule_timeout(1) == 0)
+			count++;
+
+		goto check_read_csr_complete;
+	}
+
+	if (!priv->read_csr_complete) {
+		RPU_ERROR_SCAN("%s-UMAC: No read_csr_complete after %ld ticks\n",
+			   priv->name, msecs_to_jiffies(1000));
+		return 0;
+	}
+
+	RPU_INFO_SCAN("%s-UMAC: read_csr_complete after %d timer ticks\n",
+					priv->name,
+					count);
+
+	return 0;
+
+}
+
+#ifdef RPU_SLEEP_ENABLE
+int wait_for_hp_ready_blocking_sleep(void)
+{
+	int count;
+
+	count = 0;
+
+check_rpu_ready:
+	if (!waiting_for_rpu_ready && (count < RPU_READY_TIMEOUT_TICKS)) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (0 == schedule_timeout(1))
+			count++;
+
+		goto check_rpu_ready;
+	}
+
+	if (!waiting_for_rpu_ready) {
+		RPU_ERROR_MAIN("%s-UMAC: No RPU ready interrupt after %ld ticks\n",
+			   __func__, RPU_READY_TIMEOUT_TICKS);
+		return -1;
+	}
+
+	RPU_DEBUG_MAIN("%s-UMAC: RPU is ready after %d timer ticks\n",
+					__func__,
+					count);
+
+	return 0;
+
+}
+
+int wait_for_hp_ready_blocking_busy_wait(void)
+{
+	int count;
+	unsigned long start = 0;
+
+	count = 0;
+
+	start = jiffies;
+
+	while (!waiting_for_rpu_ready &&
+	     time_before(jiffies, start + msecs_to_jiffies(1000))) {
+		cpu_relax();
+	}
+
+
+	if (!waiting_for_rpu_ready) {
+		RPU_ERROR_MAIN("%s-UMAC: No RPU ready interrupt after %ld ticks\n",
+			   hal_name, RPU_READY_TIMEOUT_TICKS);
+		return -1;
+	}
+
+	RPU_DEBUG_MAIN("%s-UMAC: RPU is ready after %d timer ticks\n",
+					hal_name,
+					count);
+
+	return 0;
+
+}
+#endif
+
+int wait_for_fw_error_process_complete(struct img_priv *priv)
+{
+	int count;
+
+	count = 0;
+
+fw_error_processing_complete:
+	if (hpriv->fw_error_processing && (count < FW_ERR_PROCESS_TIMEOUT_TICKS)) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (schedule_timeout(1) == 0)
+			count++;
+
+		goto fw_error_processing_complete;
+	}
+
+	if (hpriv->fw_error_processing) {
+		RPU_ERROR_UMACIF("%s-UMAC: No fw_error_process complete after %ld ticks\n",
+			   priv->name, FW_ERR_PROCESS_TIMEOUT_TICKS);
+		return -1;
+	}
+
+	RPU_DEBUG_UMACIF("%s-UMAC: fw_error_process complete after %d timer ticks\n",
+			priv->name, count);
+
+	return 0;
+
+}
+
+int wait_for_fw_error_cmd_done(struct img_priv *priv)
+{
+	int count;
+
+	count = 0;
+
+fw_error_cmd_done:
+	if (!hpriv->fw_error_cmd_done && (count < msecs_to_jiffies(1000))) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (schedule_timeout(1) == 0)
+			count++;
+
+		goto fw_error_cmd_done;
+	}
+
+	if (!hpriv->fw_error_cmd_done) {
+		RPU_ERROR_UMACIF("No fw_error_cmd done after %ld ticks\n",
+			   msecs_to_jiffies(1000));
+		return -1;
+	}
+
+	RPU_DEBUG_UMACIF("fw_error_cmd_done after %d timer ticks\n",
+			count);
+
+	return 0;
+
+}
+
+int wait_for_pm_resume_done(struct img_priv *priv)
+{
+	int count;
+
+	count = 0;
+
+pm_resume_done:
+	if (hpriv->during_pm_resume && (count < msecs_to_jiffies(1000))) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (schedule_timeout(1) == 0)
+			count++;
+
+		goto pm_resume_done;
+	}
+
+	if (hpriv->during_pm_resume) {
+		RPU_ERROR_UMACIF("No pm_resume done after %ld ticks\n",
+			   msecs_to_jiffies(1000));
+		return -1;
+	}
+
+	RPU_DEBUG_UMACIF("pm_resume done after %d timer ticks\n",
+			count);
+
+	return 0;
+
+}
+
+int wait_for_rxq_empty(struct img_priv *priv)
+{
+	int count;
+
+	count = 0;
+
+rxq_empty:
+	if (skb_queue_len(&hpriv->rxq) > 0 && (count < RXQ_EMPTY_TIMEOUT_TICKS)) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (schedule_timeout(1) == 0)
+			count++;
+
+		goto rxq_empty;
+	}
+
+	if (skb_queue_len(&hpriv->rxq) > 0) {
+		RPU_ERROR_ROCOVERY("rxq not empty after %ld ticks\n",
+			   RXQ_EMPTY_TIMEOUT_TICKS);
+		return -1;
+	}
+
+	RPU_DEBUG_ROCOVERY("wait_for_rxq_empty complete after %d timer ticks\n",
+			count);
+
+	return 0;
+
+}
+
+void update_aux_adc_voltage(struct img_priv *priv,
+				   unsigned char pdout)
+{
+	static unsigned int index;
+
+	if (index > MAX_AUX_ADC_SAMPLES)
+		index = 0;
+
+	priv->params->pdout_voltage[index++] = pdout;
+}
+
+/*
+ * find iterface index of main interface of wlan0
+ */
+int find_main_iface(struct img_priv *priv)
+{
+	int i, index = MAX_VIFS;
+
+	for (i = 0; i < MAX_VIFS; i++) {
+		if (priv->vifs[i] &&
+			ether_addr_equal(priv->vifs[i]->addr, vif_macs[0])) {
+			index = i;
+			break;
+		}
+	}
+	return index;
+}
+
+/*
+ * find iterface index of main interface of p2p0
+ */
+int find_p2p_iface(struct img_priv *priv)
+{
+	int i, index = MAX_VIFS;
+
+	for (i = 0; i < MAX_VIFS; i++) {
+		if (priv->vifs[i] &&
+			ether_addr_equal(priv->vifs[i]->addr, vif_macs[1])) {
+			index = i;
+			break;
+		}
+	}
+	return index;
+}
+
+/*
+ * is main interface wlan0
+ */
+bool is_main_iface(u8 *if_addr)
+{
+	if (ether_addr_equal(if_addr, vif_macs[0])) {
+		return true;
+	}
+	return false;
+}
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/vif.c b/drivers/net/wireless/rockchip_wlan/rk915/src/vif.c
new file mode 100755
index 000000000..34c0110de
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/vif.c
@@ -0,0 +1,504 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include "core.h"
+#include "utils.h"
+
+void init_vif_info(struct img_priv *priv)
+{
+	struct vif_info_s *vif_info = &priv->vif_info;
+
+	memset(vif_info, 0, sizeof(struct vif_info_s));
+}
+
+bool is_wlan_connected(struct img_priv *priv)
+{
+	struct vif_info_s *vif_info = &priv->vif_info;
+	int idx = find_main_iface(priv);
+
+	if (idx > MAX_VIFS -1)
+		return false;
+
+	if (vif_info->conn_state[idx])
+		return true;
+	return false;
+}
+
+bool is_p2p_connected(struct img_priv *priv)
+{
+	struct vif_info_s *vif_info = &priv->vif_info;
+	int idx = find_main_iface(priv);
+
+	if (idx > MAX_VIFS -1)
+		return false;
+
+	if (vif_info->conn_state[idx])
+		return true;
+	return false;
+}
+
+static void notify_bssid_change(struct img_priv *priv,
+					int index,
+					unsigned char *vif_addr,
+					unsigned char *bssid)
+{
+	struct vif_info_s *vif_info = &priv->vif_info;
+
+	RPU_DEBUG_VIF("%s: index = %d, vif_addr = %pM, bssid = %pM\n",
+			__func__, index, vif_addr, bssid);
+
+	if (index > MAX_VIFS -1)
+		return;
+
+	if (vif_addr)
+		memcpy(vif_info->vif_addr[index], vif_addr, ETH_ALEN);
+	else
+		memset(vif_info->vif_addr[index], 0, ETH_ALEN);
+	if (bssid)
+		memcpy(vif_info->bssid[index], bssid, ETH_ALEN);
+	else
+		memset(vif_info->bssid[index], 0, ETH_ALEN);
+}
+
+static void  notify_conn_state(struct img_priv *priv,
+					int index,
+					unsigned char *vif_addr,
+					unsigned int connect_state)
+{
+	struct vif_info_s *vif_info = &priv->vif_info;
+
+	RPU_DEBUG_VIF("%s: index = %d, vif_addr = %pM, connect_state = %s\n",
+			__func__, index, vif_addr, connect_state==STA_CONN ? "CONN":"DISCONN");
+
+	if (index > MAX_VIFS -1)
+		return;
+
+	memcpy(vif_info->vif_addr[index], vif_addr, ETH_ALEN);
+	if (connect_state == STA_CONN) {
+		vif_info->conn_state[index] = 1;
+	} else {
+		vif_info->conn_state[index] = 0;
+	}
+}
+
+void rpu_vif_add(struct umac_vif *uvif)
+{
+	unsigned int type;
+	struct ieee80211_conf *conf = &uvif->priv->hw->conf;
+	int ret = 0;
+
+	RPU_DEBUG_VIF("%s-UMAC: Add VIF %d Type = %d\n",
+		   uvif->priv->name,
+		   uvif->vif_index,
+		   uvif->vif->type);
+
+	uvif->config.atim_window = uvif->config.bcn_lost_cnt =
+		uvif->config.aid = 0;
+
+	switch (uvif->vif->type) {
+	case NL80211_IFTYPE_STATION:
+		type = IF_MODE_STA_BSS;
+		uvif->noa_active = 0;
+		skb_queue_head_init(&uvif->noa_que);
+		spin_lock_init(&uvif->noa_que.lock);
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		type = IF_MODE_STA_IBSS;
+		init_beacon(uvif);
+		break;
+	case NL80211_IFTYPE_AP:
+		type = IF_MODE_AP;
+		init_beacon(uvif);
+		break;
+	default:
+		WARN_ON(1);
+		return;
+	}
+
+	CALL_RPU(rpu_prog_vif_ctrl,
+		  uvif->vif_index,
+		  uvif->vif->addr,
+		  type,
+		  IF_ADD);
+
+#ifdef ENABLE_DAPT
+	dapt_notify_bssid_change(uvif->priv,
+			uvif->vif_index,
+			uvif->vif->addr,
+			NULL);
+#endif
+	notify_bssid_change(uvif->priv,
+			uvif->vif_index,
+			uvif->vif->addr,
+			NULL);
+
+	/* Reprogram retry counts */
+	CALL_RPU(rpu_prog_short_retry,
+		  uvif->vif_index, uvif->vif->addr,
+		  conf->short_frame_max_tx_count);
+
+	CALL_RPU(rpu_prog_long_retry,
+		  uvif->vif_index, uvif->vif->addr,
+		  conf->long_frame_max_tx_count);
+
+	if (uvif->vif->type == NL80211_IFTYPE_AP) {
+		/* Program the EDCA params */
+		unsigned int queue;
+		unsigned int aifs;
+		unsigned int txop;
+		unsigned int cwmin;
+		unsigned int cwmax;
+		unsigned int uapsd;
+
+		for (queue = 0; queue < 4; queue++) {
+			aifs = uvif->config.edca_params[queue].aifs;
+			txop = uvif->config.edca_params[queue].txop;
+			cwmin = uvif->config.edca_params[queue].cwmin;
+			cwmax = uvif->config.edca_params[queue].cwmax;
+			uapsd = uvif->config.edca_params[queue].uapsd;
+			RPU_DEBUG_VIF("%s: queue=%d, aifs=%d, txop=%d, cwmin=%d, cwmax=%d, uapsd=%d\n",
+							__func__, queue, aifs, txop, cwmin, cwmax, uapsd);
+
+			CALL_RPU(rpu_prog_txq_params,
+				  uvif->vif_index,
+				  uvif->vif->addr,
+				  queue,
+				  aifs,
+				  txop,
+				  cwmin,
+				  cwmax,
+				  uapsd);
+		}
+	}
+prog_rpu_fail:
+	return;
+}
+
+
+void rpu_vif_remove(struct umac_vif *uvif)
+{
+	struct sk_buff *skb;
+	unsigned int type;
+	int ret = 0;
+
+	RPU_DEBUG_VIF("%s-UMAC: Remove VIF %d called\n",
+					uvif->priv->name,
+					uvif->vif_index);
+
+	switch (uvif->vif->type) {
+	case NL80211_IFTYPE_STATION:
+		type = IF_MODE_STA_BSS;
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		type = IF_MODE_STA_IBSS;
+		deinit_beacon(uvif);
+		break;
+	case NL80211_IFTYPE_AP:
+		type = IF_MODE_AP;
+		deinit_beacon(uvif);
+		break;
+	default:
+		WARN_ON(1);
+		return;
+	}
+
+
+	if (type == IF_MODE_STA_BSS) {
+		spin_lock_bh(&uvif->noa_que.lock);
+
+		while ((skb = __skb_dequeue(&uvif->noa_que)))
+			dev_kfree_skb(skb);
+
+		spin_unlock_bh(&uvif->noa_que.lock);
+	}
+
+	CALL_RPU(rpu_prog_vif_ctrl,
+		  uvif->vif_index,
+		  uvif->vif->addr,
+		  type,
+		  IF_REM);
+
+#ifdef ENABLE_DAPT
+	dapt_notify_bssid_change(uvif->priv,
+			uvif->vif_index,
+			NULL,
+			NULL);
+#endif
+	notify_bssid_change(uvif->priv,
+			uvif->vif_index,
+			NULL,
+			NULL);
+
+prog_rpu_fail:
+	return;
+}
+
+
+void rpu_vif_set_edca_params(unsigned short queue,
+				     struct umac_vif *uvif,
+				     struct edca_params *params,
+				     unsigned int vif_active)
+{
+	int ret = 0;
+
+	switch (queue) {
+	case 0:
+		queue = 3; /* Voice */
+		break;
+	case 1:
+		queue = 2; /* Video */
+		break;
+	case 2:
+		queue = 1; /* Best effort */
+		break;
+	case 3:
+		queue = 0; /* Back groud */
+		break;
+	}
+
+	RPU_DEBUG_VIF("%s-UMAC:Set EDCA params for VIF %d,",
+		   uvif->priv ? uvif->priv->name : 0, uvif->vif_index);
+	RPU_DEBUG_VIF(" Values: %d, %d, %d, %d, %d\n",
+		   queue, params->aifs, params->txop,
+		   params->cwmin, params->cwmax);
+
+	if (uvif->priv->params->production_test == 0) {
+		/* arbitration interframe space [0..255] */
+		uvif->config.edca_params[queue].aifs = params->aifs;
+
+		/* maximum burst time in units of 32 usecs, 0 meaning disabled*/
+		uvif->config.edca_params[queue].txop = params->txop;
+
+		/* minimum contention window in units of  2^n-1 */
+		uvif->config.edca_params[queue].cwmin = params->cwmin;
+
+		/*  maximum contention window in units of 2^n-1 */
+		uvif->config.edca_params[queue].cwmax = params->cwmax;
+		uvif->config.edca_params[queue].uapsd = params->uapsd;
+	} else {
+		uvif->config.edca_params[queue].aifs = 3;
+		uvif->config.edca_params[queue].txop = 0;
+		uvif->config.edca_params[queue].cwmin = 0;
+		uvif->config.edca_params[queue].cwmax = 0;
+		uvif->config.edca_params[queue].uapsd = 0;
+	}
+
+	/* For the AP case, EDCA params are set before ADD interface is called.
+	 * Since this is not supported, we simply store the params and program
+	 * them to the LMAC after the interface is added
+	 */
+	if (!vif_active) {
+		WARN_ON(1);
+		return;
+	}
+
+	/* Program the txq parameters into the LMAC */
+	CALL_RPU(rpu_prog_txq_params,
+		  uvif->vif_index,
+		  uvif->vif->addr,
+		  queue,
+		  params->aifs,
+		  params->txop,
+		  params->cwmin,
+		  params->cwmax,
+		  params->uapsd);
+prog_rpu_fail:
+	return;
+}
+
+
+void rpu_vif_bss_info_changed(struct umac_vif *uvif,
+				      struct ieee80211_bss_conf *bss_conf,
+				      unsigned int changed)
+{
+	unsigned int caps = 0;
+	int center_freq = 0;
+	int chan = 0;
+	int ret = 0;
+
+	RPU_DEBUG_VIF("%s-CORE: BSS INFO changed %d, %d, %d\n",
+		uvif->priv->name, uvif->vif_index, uvif->vif->type, changed);
+
+
+	if (changed & BSS_CHANGED_BSSID) {
+		CALL_RPU(rpu_prog_vif_bssid,
+			   uvif->vif_index,
+			   uvif->vif->addr,
+			   (unsigned char *)bss_conf->bssid);
+#ifdef ENABLE_DAPT
+		dapt_notify_bssid_change(uvif->priv,
+			   uvif->vif_index,
+			   uvif->vif->addr,
+			   (unsigned char *)bss_conf->bssid);
+#endif
+		notify_bssid_change(uvif->priv,
+			   uvif->vif_index,
+			   uvif->vif->addr,
+			   (unsigned char *)bss_conf->bssid);
+#if 0
+		// 
+		// must set CONNECT_STATE_CHANGED and connect_state = 0
+		// oterwise auth will failed
+		CALL_RPU(rpu_prog_vif_conn_state,
+			   uvif->vif_index,
+			   uvif->vif->addr,
+			   0);
+#endif
+	}
+
+	if (changed & BSS_CHANGED_BASIC_RATES) {
+		if (bss_conf->basic_rates)
+			CALL_RPU(rpu_prog_vif_basic_rates,
+				  uvif->vif_index,
+				  uvif->vif->addr,
+				  bss_conf->basic_rates);
+		else
+			CALL_RPU(rpu_prog_vif_basic_rates,
+				  uvif->vif_index,
+				  uvif->vif->addr,
+				  0x153);
+	}
+
+	if (changed & BSS_CHANGED_ERP_SLOT) {
+		unsigned int queue = 0;
+		unsigned int aifs = 0;
+		unsigned int txop = 0;
+		unsigned int cwmin = 0;
+		unsigned int cwmax = 0;
+		unsigned int uapsd = 0;
+
+		CALL_RPU(rpu_prog_vif_short_slot,
+			  uvif->vif_index,
+			  uvif->vif->addr,
+			  bss_conf->use_short_slot);
+
+		for (queue = 0; queue < WLAN_AC_MAX_CNT; queue++) {
+			aifs = uvif->config.edca_params[queue].aifs;
+			txop = uvif->config.edca_params[queue].txop;
+			cwmin = uvif->config.edca_params[queue].cwmin;
+			cwmax = uvif->config.edca_params[queue].cwmax;
+			uapsd = uvif->config.edca_params[queue].uapsd;
+
+			if (uvif->config.edca_params[queue].cwmin != 0)
+				CALL_RPU(rpu_prog_txq_params,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  queue,
+					  aifs,
+					  txop,
+					  cwmin,
+					  cwmax,
+					  uapsd);
+		}
+	}
+
+	switch (uvif->vif->type) {
+	case NL80211_IFTYPE_STATION:
+		if (changed & BSS_CHANGED_ASSOC) {
+			if (bss_conf->assoc) {
+				RPU_DEBUG_VIF("%s-CORE: AID %d,",
+					   uvif->priv->name, bss_conf->aid);
+				RPU_DEBUG_VIF(" CAPS 0x%04x\n",
+					   bss_conf->assoc_capability |
+					   (bss_conf->qos << 9));
+
+				CALL_RPU(rpu_prog_vif_conn_state,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  STA_CONN);
+#ifdef ENABLE_DAPT
+				dapt_notify_conn_state(uvif->priv,
+					  uvif->vif_index,
+					  uvif->vif->addr,					  
+					  STA_CONN);
+#endif
+				notify_conn_state(uvif->priv,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  STA_CONN);
+				CALL_RPU(rpu_prog_vif_aid,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  bss_conf->aid);
+
+				center_freq = bss_conf->chandef.chan->center_freq;
+				chan = ieee80211_frequency_to_channel(center_freq);
+				CALL_RPU(rpu_prog_vif_op_channel,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  chan);
+
+				caps = (bss_conf->assoc_capability |
+					(bss_conf->qos << 9));
+
+				CALL_RPU(rpu_prog_vif_assoc_cap,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  caps);
+
+
+				uvif->noa_active = 0;
+				uvif->priv->params->is_associated = 1;
+
+			} else {
+				uvif->priv->params->is_associated = 0;
+
+				CALL_RPU(rpu_prog_vif_conn_state,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  STA_DISCONN);
+#ifdef ENABLE_DAPT
+				dapt_notify_conn_state(uvif->priv,
+					  uvif->vif_index,
+					  uvif->vif->addr,					  
+					  STA_DISCONN);
+#endif
+				notify_conn_state(uvif->priv,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  STA_DISCONN);
+			}
+		}
+
+		if (changed & BSS_CHANGED_BEACON_INT) {
+			CALL_RPU(rpu_prog_vif_beacon_int,
+				  uvif->vif_index,
+				  uvif->vif->addr,
+				  bss_conf->beacon_int);
+
+		}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		if (changed & BSS_CHANGED_BEACON_INFO) {
+#else
+		if (changed & BSS_CHANGED_DTIM_PERIOD) {
+#endif
+			CALL_RPU(rpu_prog_vif_dtim_period,
+				  uvif->vif_index,
+				  uvif->vif->addr,
+				   bss_conf->dtim_period);
+
+		}
+
+		break;
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_AP:
+		if ((changed & BSS_CHANGED_BEACON_ENABLED) ||
+		    (changed & BSS_CHANGED_BEACON_INT))
+			modify_beacon_params(uvif, bss_conf);
+		break;
+	default:
+		WARN_ON(1);
+		return;
+	}
+prog_rpu_fail:
+	return;
+}
+
+
diff --git a/drivers/net/wireless/rockchip_wlan/rk915/src/wow.c b/drivers/net/wireless/rockchip_wlan/rk915/src/wow.c
new file mode 100755
index 000000000..89b37030d
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rk915/src/wow.c
@@ -0,0 +1,265 @@
+/*
+ * Copyright (c) 2021, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include "wow.h"
+#include "core.h"
+#include "hal_io.h"
+
+#ifdef CONFIG_PM
+
+unsigned char img_suspend_status;
+static int host_suspend(void);
+struct syscore_ops host_syscore_ops = {
+	.suspend = host_suspend,
+};
+
+#if 0
+static int wait_for_econ_ps_cfg(struct img_priv *priv)
+{
+	int count = 0;
+	char econ_ps_cfg_done = 0;
+
+check_econ_ps_cfg_complete:
+	mutex_lock(&priv->mutex);
+	econ_ps_cfg_done = priv->econ_ps_cfg_stats.completed;
+	mutex_unlock(&priv->mutex);
+
+	if (!econ_ps_cfg_done && (count < PS_ECON_CFG_TIMEOUT_TICKS)) {
+		count++;
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(1);
+		goto check_econ_ps_cfg_complete;
+	}
+
+	if (!econ_ps_cfg_done) {
+		RPU_INFO_UMACIF("%s: Didn't get ECON_PS_CFG_DONE event\n",
+		       __func__);
+		return -1;
+	}
+
+	RPU_DEBUG_UMACIF("%s : Received ECON_PS_CFG_DONE event\n",
+						__func__);
+	return 0;
+}
+#endif
+
+static int wait_for_all_cmd_done(struct img_priv *priv)
+{
+	int count = 0;
+
+check_all_cmd_done:
+
+	if (cmd_info.outstanding_ctrl_req && (count < msecs_to_jiffies(1000))) {
+		count++;
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(1);
+		goto check_all_cmd_done;
+	}
+
+	if (cmd_info.outstanding_ctrl_req) {
+		RPU_INFO_UMACIF("%s: Failed to wait all cmd done\n",
+		       __func__);
+		return -1;
+	}
+
+	RPU_DEBUG_UMACIF("%s : All cmd done\n",
+						__func__);
+	return 0;
+}
+
+int img_resume(struct ieee80211_hw *hw)
+{
+	//int i = 0, ret = 0;
+	//int active_vif_index = -1;
+	struct img_priv *priv = NULL;
+
+	if (hw == NULL) {
+		RPU_ERROR_UMACIF("%s: Invalid parameters\n",
+		       __func__);
+		return -EINVAL;
+	}
+
+	priv = (struct img_priv *)hw->priv;
+
+	if (!priv->params->is_associated) {
+		rk915_notify_pm(hpriv, 1);
+		return 0;
+	}
+
+#if 1
+	rk915_notify_pm(hpriv, 1);
+	hal_ops.disable_irq_wake();
+	img_suspend_status = 0;
+
+	return 0;
+#else
+	mutex_lock(&priv->mutex);
+
+	for (i = 0; i < MAX_VIFS; i++) {
+		if (priv->active_vifs & (1 << i))
+			active_vif_index = i;
+	}
+
+	priv->econ_ps_cfg_stats.completed = 0;
+	priv->econ_ps_cfg_stats.result = 0;
+	priv->econ_ps_cfg_stats.processing = 1;
+
+	ret = rpu_prog_econ_ps_state(active_vif_index,
+					     PWRSAVE_STATE_AWAKE);
+	if (ret) {
+		RPU_ERROR_UMACIF("%s : prog econ ps failed\n",
+		       __func__);
+		mutex_unlock(&priv->mutex);
+		priv->econ_ps_cfg_stats.processing = 0;
+		return ret;
+	}
+
+	mutex_unlock(&priv->mutex);
+
+	if (!wait_for_econ_ps_cfg(priv)) {
+		if (!priv->econ_ps_cfg_stats.result) {
+			RPU_INFO_UMACIF("%s: Successful\n",
+				 __func__);
+			rk915_notify_pm(hpriv, 1);
+			hal_ops.disable_irq_wake();
+			img_suspend_status = 0;
+			return 0;
+		}
+		RPU_INFO_UMACIF("%s: Unable to Resume\n", __func__);
+	}
+	priv->econ_ps_cfg_stats.processing = 0;	
+
+	return -ETIME;
+#endif	
+}
+
+int img_suspend(struct ieee80211_hw *hw,
+		       struct cfg80211_wowlan *wowlan)
+{
+	int i = 0, ret = 0;
+	int active_vif_index = -1;
+	int count = 0;
+	struct img_priv *priv = NULL;
+	struct ieee80211_vif *vif = NULL;
+
+	if (hw == NULL) {
+		RPU_ERROR_UMACIF("%s: Invalid parameters\n",
+		       __func__);
+		return -EINVAL;
+	}
+
+	priv = (struct img_priv *)hw->priv;
+
+	if (!priv->params->is_associated) {
+		rk915_notify_pm(hpriv, 0);
+		return ret;
+	}
+
+	if ((wifi->params.hw_scan_status == HW_SCAN_STATUS_PROGRESS) ||
+		(priv->roc_params.roc_starting == 1))
+		return -EBUSY;
+
+	/*if (priv->power_save == PWRSAVE_STATE_AWAKE)
+		return -EBUSY;*/
+
+	// TODO: need to wait all outstanding cmds and tx cmd done before suspend
+
+	mutex_lock(&priv->mutex);
+
+	for (i = 0; i < MAX_VIFS; i++) {
+		if (priv->active_vifs & (1 << i)) {
+			active_vif_index = i;
+			count++;
+		}
+	}
+
+	if (count != 1) {
+		RPU_ERROR_UMACIF("%s: Economy mode supp only for single VIF(STA mode)\n",
+		       __func__);
+		mutex_unlock(&priv->mutex);
+		return -ENOTSUPP;
+	}
+
+	rcu_read_lock();
+	vif = rcu_dereference(priv->vifs[active_vif_index]);
+	rcu_read_unlock();
+
+	if (vif->type != NL80211_IFTYPE_STATION) {
+		RPU_ERROR_UMACIF("%s: VIF is not in STA Mode\n",
+		       __func__);
+		mutex_unlock(&priv->mutex);
+		return -ENOTSUPP;
+	 }
+
+	if (priv->power_save == PWRSAVE_STATE_AWAKE) {
+		priv->power_save = PWRSAVE_STATE_DOZE;
+		rpu_prog_ps_state(active_vif_index, vif->addr, priv->power_save);
+		if (wait_for_all_cmd_done(priv) != 0) {
+			mutex_unlock(&priv->mutex);
+			return -EBUSY;
+		}
+	}
+
+#if 1
+	mutex_unlock(&priv->mutex);
+
+	rk915_notify_pm(hpriv, 0);
+	hal_ops.enable_irq_wake();
+	img_suspend_status = 1;
+
+	return 0;
+#else
+	priv->econ_ps_cfg_stats.completed = 0;
+	priv->econ_ps_cfg_stats.result = 0;
+	priv->econ_ps_cfg_stats.wake_trig = -1;
+	priv->econ_ps_cfg_stats.processing = 1;
+
+	ret = rpu_prog_econ_ps_state(active_vif_index,
+				PWRSAVE_STATE_DOZE);
+	if (ret) {
+		RPU_ERROR_UMACIF("%s : Error Occured\n",
+		       __func__);
+		mutex_unlock(&priv->mutex);
+		priv->econ_ps_cfg_stats.processing = 0;
+		return ret;
+	}
+
+	mutex_unlock(&priv->mutex);
+
+	if (!wait_for_econ_ps_cfg(priv)) {
+		if (!priv->econ_ps_cfg_stats.result) {
+			RPU_INFO_UMACIF("%s: Successful\n",
+				 __func__);
+			rk915_notify_pm(hpriv, 0);
+			hal_ops.enable_irq_wake();
+			img_suspend_status = 1;
+			return 0;
+		}
+		RPU_INFO_UMACIF("%s: Unable to Suspend: Active Traffic.\n", __func__);
+	}
+	priv->econ_ps_cfg_stats.processing = 0;
+
+	return -ETIME;
+#endif
+}
+
+
+static int host_suspend(void)
+{
+	/*if ((img_suspend_status == 1) && (rx_interrupt_status == 1)) {
+		RPU_ERROR_UMACIF("%s: Interrupt raised during Suspend, cancel suspend",
+				__func__);
+		return -EBUSY;
+	} else */{
+		return 0;
+	}
+}
+#endif
+
+
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index 8935b1e63..1f41f64fa 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -199,6 +199,7 @@ struct gendisk {
 	struct request_queue *queue;
 	void *private_data;
 
+	int emmc_disk;			/* Flag for emmc devive */
 	int flags;
 	unsigned long state;
 #define GD_NEED_PART_SCAN		0
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 6fa9e476e..8101701a8 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -145,6 +145,7 @@ struct mmc_host_ops {
 
 	/* Check if the card is pulling dat[0:3] low */
 	int	(*card_busy)(struct mmc_host *host);
+	int     (*set_sdio_status)(struct mmc_host *host, int val);
 
 	/* The tuning command opcode value is different for SD and eMMC cards */
 	int	(*execute_tuning)(struct mmc_host *host, u32 opcode);
@@ -390,10 +391,15 @@ struct mmc_host {
 #else
 #define MMC_CAP2_CRYPTO		0
 #endif
+#define MMC_CAP2_WIFI_RK912 (1 << 28)   /* Host supports WIFI RK912 */
 
 	int			fixed_drv_type;	/* fixed driver type for non-removable media */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
+	u32			restrict_caps;  /* Indicate slot specific card type */
+#define RESTRICT_CARD_TYPE_SD   (1 << 0)        /* Can support Secure-Digital Card */
+#define RESTRICT_CARD_TYPE_SDIO (1 << 1)        /* Can support Secure-Digital I/O Card or Combo-Mem */
+#define RESTRICT_CARD_TYPE_EMMC (1 << 2)        /* Can support embedded Multi-Media Card */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
diff --git a/net/mac80211/main.c b/net/mac80211/main.c
index ae90ac3be..3e485039a 100644
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -1311,6 +1311,18 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 				   "Failed to add default virtual iface\n");
 	}
 
+	if (local->hw.wiphy->interface_modes & (BIT(NL80211_IFTYPE_P2P_GO) |
+		BIT(NL80211_IFTYPE_P2P_CLIENT)) &&
+		!ieee80211_hw_check(hw, NO_AUTO_VIF)) {
+		struct vif_params params = {0};
+
+		result = ieee80211_if_add(local, "p2p%d", NET_NAME_ENUM, NULL,
+                      NL80211_IFTYPE_STATION, &params);
+		if (result)
+			wiphy_warn(local->hw.wiphy,
+					"Failed to add second virtual iface\n");
+	}
+
 	rtnl_unlock();
 
 #ifdef CONFIG_INET
diff --git a/net/rfkill/rfkill-wlan.c b/net/rfkill/rfkill-wlan.c
index 338b59c53..b2b563d82 100644
--- a/net/rfkill/rfkill-wlan.c
+++ b/net/rfkill/rfkill-wlan.c
@@ -345,9 +345,11 @@ EXPORT_SYMBOL(rockchip_wifi_power);
  * Wifi Sdio Detect Func
  *
  *************************************************************************/
+extern int mmc_host_rescan(struct mmc_host *host, int val, int irq_type);
 int rockchip_wifi_set_carddetect(int val)
 {
-	return 0;
+	//return 0;
+	return mmc_host_rescan(NULL, val, 1);
 }
 EXPORT_SYMBOL(rockchip_wifi_set_carddetect);
 
-- 
2.47.0

